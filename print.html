<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rainning in the utopia</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
                <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">概述</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">JavaScript</li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.</strong> 基础</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="JavaScript/作用域和闭包.html"><strong aria-hidden="true">1.1.</strong> 作用域和闭包</a></li><li class="chapter-item expanded "><a href="JavaScript/JS变量.html"><strong aria-hidden="true">1.2.</strong> JS 变量</a></li><li class="chapter-item expanded "><a href="JavaScript/防抖和节流.html"><strong aria-hidden="true">1.3.</strong> 防抖和节流</a></li><li class="chapter-item expanded "><a href="JavaScript/异步.html"><strong aria-hidden="true">1.4.</strong> 异步</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> 进阶</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="JavaScript/函数相关（compose，pip，memoize，curry，偏函数）.html"><strong aria-hidden="true">2.1.</strong> 函数相关（compose，pip，memoize，curry，偏函数）</a></li><li class="chapter-item expanded "><a href="JavaScript/过滤重复请求-时间窗口.html"><strong aria-hidden="true">2.2.</strong> 过滤重复请求 - 时间窗口</a></li><li class="chapter-item expanded "><a href="JavaScript/不稳定网络环境下的指数补偿.html"><strong aria-hidden="true">2.3.</strong> 不稳定网络环境下的指数补偿</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> ES6</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="JavaScript/ES6中继承对static函数，箭头函数，普通函数的处理.html"><strong aria-hidden="true">3.1.</strong> ES6 中的继承各种形式的函数处理</a></li><li class="chapter-item expanded "><a href="JavaScript/各种各样的模块化.html"><strong aria-hidden="true">3.2.</strong> 各种各样的模块化</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> 工程化</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="JavaScript/Webpack.html"><strong aria-hidden="true">4.1.</strong> Webpack</a></li><li class="chapter-item expanded "><a href="JavaScript/webpack-dev-server.html"><strong aria-hidden="true">4.2.</strong> webpack-dev-server</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">CSS</li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> 基础</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="CSS/居中布局.html"><strong aria-hidden="true">5.1.</strong> 居中布局的几种方式</a></li><li class="chapter-item expanded "><a href="CSS/高度塌陷和垂直外边距重叠.html"><strong aria-hidden="true">5.2.</strong> 高度塌陷和垂直外边距重叠</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">React</li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> 虚拟 DOM</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="React/虚拟DOM.html"><strong aria-hidden="true">6.1.</strong> 虚拟 DOM</a></li><li class="chapter-item expanded "><a href="React/手动实现一个虚拟DOM.html"><strong aria-hidden="true">6.2.</strong> 手动实现一个虚拟 DOM</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> React 事件</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="React/React事件简单记录.html"><strong aria-hidden="true">7.1.</strong> 简单记录</a></li><li class="chapter-item expanded "><a href="React/React事件机制.html"><strong aria-hidden="true">7.2.</strong> React 事件机制源码简单分析</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> Hooks</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="React/ReactHooks详解.html"><strong aria-hidden="true">8.1.</strong> React Hooks 详解</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Vue</li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> Vue</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="Vue/Vue2.x响应式原理简单解析.html"><strong aria-hidden="true">9.1.</strong> Vue2.x 响应式原理简单解析</a></li><li class="chapter-item expanded "><a href="Vue/异步更新队列.html"><strong aria-hidden="true">9.2.</strong> 异步更新队列</a></li><li class="chapter-item expanded "><a href="Vue/computed,watch,watchEffect.html"><strong aria-hidden="true">9.3.</strong> computed,watch,watchEffect</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.</strong> Vuex</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="Vue/Vuex简单源码.html"><strong aria-hidden="true">10.1.</strong> Vuex 简单源码</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">网络</li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.</strong> 网络基础</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="Network/加密和HTTPS.html"><strong aria-hidden="true">11.1.</strong> 加密和 HTTPS</a></li><li class="chapter-item expanded "><a href="Network/TCP_IP三次握手和四次挥手.html"><strong aria-hidden="true">11.2.</strong> TCP/IP 三次握手和四次挥手</a></li><li class="chapter-item expanded "><a href="Network/HTTP缓存.html"><strong aria-hidden="true">11.3.</strong> HTTP 缓存</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.</strong> 扩展阅读</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="Network/HTTP2.0_&_HTTP3.0.html"><strong aria-hidden="true">12.1.</strong> HTTP2.0 &amp; HTTP3.0</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Linux</li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.</strong> 基础</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="Linux/vim编辑器.html"><strong aria-hidden="true">13.1.</strong> vim 编辑器</a></li><li class="chapter-item expanded "><a href="Linux/初始命令.html"><strong aria-hidden="true">13.2.</strong> 初始命令</a></li><li class="chapter-item expanded "><a href="Linux/文件内容操作命令.html"><strong aria-hidden="true">13.3.</strong> 文件内容操作命令</a></li><li class="chapter-item expanded "><a href="Linux/网络命令等.html"><strong aria-hidden="true">13.4.</strong> 网络命令等</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">14.</strong> 安装</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="Linux/centos7升级python.html"><strong aria-hidden="true">14.1.</strong> centos7 升级 python</a></li><li class="chapter-item expanded "><a href="Linux/VMWare15.html"><strong aria-hidden="true">14.2.</strong> VMWare15</a></li><li class="chapter-item expanded "><a href="Linux/Centos7安装docker（华为源）.html"><strong aria-hidden="true">14.3.</strong> Centos7 安装 docker（华为源）</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Git</li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.</strong> 个人记录</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="Git/git代理.html"><strong aria-hidden="true">15.1.</strong> Git 代理</a></li><li class="chapter-item expanded "><a href="Git/Gitlab-ce备份和恢复.html"><strong aria-hidden="true">15.2.</strong> Gitlab-ce 备份和恢复</a></li><li class="chapter-item expanded "><a href="Git/保存本地commit记录的同时合并提交到origin.html"><strong aria-hidden="true">15.3.</strong> 保存本地 commit 记录的同时合并提交到 origin</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">JAVA</li><li class="chapter-item expanded "><div><strong aria-hidden="true">16.</strong> 基础</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="Java/01-Java实现多线程的三种方式.html"><strong aria-hidden="true">16.1.</strong> Java 实现多线程的三种方式</a></li><li class="chapter-item expanded "><a href="Java/02-多线程的常用操作方法.html"><strong aria-hidden="true">16.2.</strong> 多线程的常用操作方法</a></li><li class="chapter-item expanded "><a href="Java/03-生产者消费者实战.html"><strong aria-hidden="true">16.3.</strong> 生产者消费者实战</a></li><li class="chapter-item expanded "><a href="Java/04-StringBuffer类.html"><strong aria-hidden="true">16.4.</strong> StringBuffer 类</a></li><li class="chapter-item expanded "><a href="Java/05-RunTime类.html"><strong aria-hidden="true">16.5.</strong> RunTime 类</a></li><li class="chapter-item expanded "><a href="Java/06-System类.html"><strong aria-hidden="true">16.6.</strong> System 类</a></li><li class="chapter-item expanded "><a href="Java/07-对象克隆.html"><strong aria-hidden="true">16.7.</strong> 对象克隆</a></li><li class="chapter-item expanded "><a href="Java/08-Math类.html"><strong aria-hidden="true">16.8.</strong> Math 类</a></li><li class="chapter-item expanded "><a href="Java/09-日期处理.html"><strong aria-hidden="true">16.9.</strong> 日期处理</a></li><li class="chapter-item expanded "><a href="Java/10-比较器.html"><strong aria-hidden="true">16.10.</strong> 比较器</a></li><li class="chapter-item expanded "><a href="Java/11-正则表达式.html"><strong aria-hidden="true">16.11.</strong> 正则表达式</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">17.</strong> 其他</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="Java/单点登录.html"><strong aria-hidden="true">17.1.</strong> 单点登录</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Python</li><li class="chapter-item expanded "><div><strong aria-hidden="true">18.</strong> 乱七八糟</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="Python/Flask入门.html"><strong aria-hidden="true">18.1.</strong> Flask 入门</a></li><li class="chapter-item expanded "><a href="Python/HTTPserver.html"><strong aria-hidden="true">18.2.</strong> HTTPserver</a></li><li class="chapter-item expanded "><a href="Python/Python数据结构.html"><strong aria-hidden="true">18.3.</strong> Python 数据结构</a></li><li class="chapter-item expanded "><a href="Python/Python高阶-1.html"><strong aria-hidden="true">18.4.</strong> Python 高阶-1</a></li><li class="chapter-item expanded "><a href="Python/Python高阶-2.html"><strong aria-hidden="true">18.5.</strong> Python 高阶-2</a></li><li class="chapter-item expanded "><a href="Python/Python高阶-3.html"><strong aria-hidden="true">18.6.</strong> Python 高阶-3</a></li><li class="chapter-item expanded "><a href="Python/Python高阶-4.html"><strong aria-hidden="true">18.7.</strong> Python 高阶-4</a></li><li class="chapter-item expanded "><a href="Python/Python高阶-5.html"><strong aria-hidden="true">18.8.</strong> Python 高阶-5</a></li><li class="chapter-item expanded "><a href="Python/爬坑1-10.html"><strong aria-hidden="true">18.9.</strong> 爬坑 1-10</a></li><li class="chapter-item expanded "><a href="Python/爬坑11-20.html"><strong aria-hidden="true">18.10.</strong> 爬坑 11-20</a></li><li class="chapter-item expanded "><a href="Python/爬坑21-30.html"><strong aria-hidden="true">18.11.</strong> 爬坑 21-30</a></li><li class="chapter-item expanded "><a href="Python/爬坑31-40.html"><strong aria-hidden="true">18.12.</strong> 爬坑 31-40</a></li><li class="chapter-item expanded "><a href="Python/爬坑41-50.html"><strong aria-hidden="true">18.13.</strong> 爬坑 41-50</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">算法</li><li class="chapter-item expanded "><div><strong aria-hidden="true">19.</strong> LeetCode</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="Algorithm/各种排序算法的比较.html"><strong aria-hidden="true">19.1.</strong> 各种排序算法的比较</a></li><li class="chapter-item expanded "><a href="Algorithm/斐波那契进阶.html"><strong aria-hidden="true">19.2.</strong> 斐波那契进阶</a></li><li class="chapter-item expanded "><a href="Algorithm/1-两数之和.html"><strong aria-hidden="true">19.3.</strong> 1-两数之和</a></li><li class="chapter-item expanded "><a href="Algorithm/2-两数相加.html"><strong aria-hidden="true">19.4.</strong> 2-两数相加</a></li><li class="chapter-item expanded "><a href="Algorithm/3-无重复字符的最长子串.html"><strong aria-hidden="true">19.5.</strong> 3-无重复字符的最长子串</a></li><li class="chapter-item expanded "><a href="Algorithm/4-寻找两个有序数组的中位数.html"><strong aria-hidden="true">19.6.</strong> 4-寻找两个有序数组的中位数</a></li><li class="chapter-item expanded "><a href="Algorithm/5-最长回文子串.html"><strong aria-hidden="true">19.7.</strong> 5-最长回文子串</a></li><li class="chapter-item expanded "><a href="Algorithm/6-Z字形变换.html"><strong aria-hidden="true">19.8.</strong> 6-Z 字形变换</a></li><li class="chapter-item expanded "><a href="Algorithm/7-整数翻转.html"><strong aria-hidden="true">19.9.</strong> 7-整数翻转</a></li><li class="chapter-item expanded "><a href="Algorithm/92-反转链表②.html"><strong aria-hidden="true">19.10.</strong> 92-反转链表 ②</a></li><li class="chapter-item expanded "><a href="Algorithm/206-反转链表.html"><strong aria-hidden="true">19.11.</strong> 206-反转链表</a></li><li class="spacer"></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">Rainning in the utopia</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="概括"><a class="header" href="#概括">概括</a></h1>
<p>记录个人学习经历</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="作用域和闭包"><a class="header" href="#作用域和闭包">作用域和闭包</a></h1>
<h2 id="执行上下文"><a class="header" href="#执行上下文">执行上下文</a></h2>
<p>针对一段 script 标签或者一个函数而言</p>
<ul>
<li>
<p><code>JS</code>只有全局作用域和函数作用域（在 <code>es6</code> 之前）</p>
</li>
<li>
<p>使用 <code>var</code> 声明的变量会在执行之前提升到作用域的最顶端。</p>
</li>
<li>
<p>即可以在函数声明之前调用函数。在变量声明之前调用变量（此时变量的值为 <code>undefined</code> ）。</p>
</li>
<li>
<p>函数还包括 this，arguments</p>
</li>
</ul>
<h2 id="this"><a class="header" href="#this">this</a></h2>
<p>只有在执行的时候才能确定。包括赋值引用。注意区分构造函数内部的 <code>this</code> 。</p>
<p>可以通过 <code>call</code>, <code>apply</code> , <code>bind</code> 来改变 <code>this</code> 的指向。</p>
<h2 id="闭包"><a class="header" href="#闭包">闭包</a></h2>
<p>返回一个函数或者传入一个函数去执行。都可以称之为闭包。</p>
<p>在这个闭包函数内部，可以定义变量来防止外部污染。即，私有变量。</p>
<p>不过需要注意内存泄露问题，因为在这边定义的变量无法自动释放。</p>
<pre><code class="language-js">function F1() {
  var a = 100;
  return function () {
    console.log(a); // 自由变量，取父级作用域中的值。
  };
}

var f1 = F1();
var a = 200;
f1(); // 100
</code></pre>
<h2 id="创建-10-个标签注入点击事件分别按顺序输出-1-10"><a class="header" href="#创建-10-个标签注入点击事件分别按顺序输出-1-10">创建 10 个标签，注入点击事件，分别按顺序输出 1-10</a></h2>
<pre><code class="language-js">var i;

for (i = 0; i &lt; 10; i++) {
  (function (i) {
    var a = document.createElement(&quot;a&quot;);
    a.innerHTML = i + &quot;&lt;br&gt;&quot;;
    a.addEventListener(&quot;click&quot;, function (e) {
      e.preventDefault();
      alert(i);
    });
    document.body.appendChild(a);
  })(i);
}
</code></pre>
<p>新的 es6 可以用 let 来解决这个问题。</p>
<pre><code class="language-js">for (let i = 0; i &lt; 10; i++) {
  var a = document.createElement(&quot;a&quot;);
  a.innerHTML = i + &quot;&lt;br&gt;&quot;;
  a.addEventListener(&quot;click&quot;, function (e) {
    e.preventDefault();
    alert(i);
  });
  document.body.appendChild(a);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="js-变量复习"><a class="header" href="#js-变量复习">JS 变量复习</a></h1>
<ul>
<li>typeof 能得到哪些类型</li>
<li>=== 和 ==</li>
<li>JS 的内置函数</li>
<li>按存储方式划分，js 变量有哪些类型</li>
<li>理解 JSON</li>
</ul>
<h2 id="变量类型"><a class="header" href="#变量类型">变量类型</a></h2>
<h3 id="值类型和引用类型"><a class="header" href="#值类型和引用类型">值类型和引用类型</a></h3>
<p>值类型：undefined, number, boolean, string, symbol, null</p>
<p>引用类型：function, object</p>
<p>还牵扯到堆内存和栈内存的关系，稍微延伸一下。</p>
<h4 id="堆内存和栈内存"><a class="header" href="#堆内存和栈内存">堆内存和栈内存</a></h4>
<p><strong>栈内存</strong>主要用于存储各种<strong>基本类型的</strong>变量，包括
boolean、number、string、undefined、null，以及对象变量的指针，这时候栈内存给人的感觉就像一个线性排列的空间，每个小单元大小基本相等。</p>
<p>而堆内存主要负责像对象 Object 这种变量类型的存储，如下图<img src="JavaScript/./images/JS%E5%8F%98%E9%87%8F%E5%A4%8D%E4%B9%A0-461976-20180823211511434-1707579794.png" alt="img" /></p>
<p>原始数据类型都有固定的大小保存在栈内存中，由系统自动分配存储空间，可以直接进行操作。</p>
<p>对于 new 出来的变量，思考一下 new 关键字所作所为，就知道，new 出来的对象都是存储在堆内存中的。</p>
<p>我们常说的值类型和引用类型其实说的就是栈内存变量和堆内存变量，再想想值传递和引用传递、深拷贝和浅拷贝，都是围绕堆栈内存展开的，一个是处理值，一个是处理指针。</p>
<h4 id="变量定义的过程"><a class="header" href="#变量定义的过程">变量定义的过程</a></h4>
<p>例如<code>var a = 10</code>:</p>
<p>先将<code>10</code>压入栈中，然后在当前作用域中声明一个变量<code>a</code>，此时<code>a = undefined</code>，然后再将 <code>a</code> <strong>关联</strong>到<code>10</code>。</p>
<h4 id="函数定义的过程"><a class="header" href="#函数定义的过程">函数定义的过程</a></h4>
<p>现在堆内存中开辟一块空间，将函数的以字符串的形式存入。然后会有一个十六进制的堆内存的值。然后存入栈内存中。然后声明变量 fn，然后将 fn 关联到这个内存地址上。</p>
<h4 id="垃圾回收机制"><a class="header" href="#垃圾回收机制">垃圾回收机制</a></h4>
<h5 id="浏览器的垃圾回收机制"><a class="header" href="#浏览器的垃圾回收机制">浏览器的垃圾回收机制</a></h5>
<ul>
<li>
<p>引用计数（RC）</p>
</li>
<li>
<p>标记清除</p>
<p>标记清除指的是当变量进入环境时，这个变量标记为“进入环境”;而当变量离开环境时，则将其标记为“离开环境”，最后，垃圾回收器完成内存清除工作，销毁并回收那些被标记为“离开环境”的值所占用的内存空间</p>
</li>
</ul>
<h5 id="v8-的垃圾回收机制"><a class="header" href="#v8-的垃圾回收机制">V8 的垃圾回收机制</a></h5>
<p>分代回收：新生代和老生代。</p>
<h6 id="新生代的垃圾回收"><a class="header" href="#新生代的垃圾回收">新生代的垃圾回收</a></h6>
<p>在堆内存中分两个部分，一个 From（使用中的空间） ，一个 To（闲置状态），分配对象的时候先在 from 空间中进行分配，如果一个对象不再被引用了，那么将会被留在 From
中，将其他被引用的对象移动到 To 空间中，然后对调 From 和 To，最后释放 To 中的空间。</p>
<h6 id="晋升"><a class="header" href="#晋升">晋升</a></h6>
<p>在新生代垃圾回收的过程中，当一个对象经过多次复制后依然存活，他将会被认为是生命周期较长的对象，随后会被移动到老生代中，采用新的算法进行管理</p>
<p>在 From 空间和 To 空间进行反转的过程中，如果 To 空间中的使用量已经超过了 25%,那么就将 From 中的对象直接晋升到老生代内存空间中</p>
<h6 id="老生代的垃圾回收"><a class="header" href="#老生代的垃圾回收">老生代的垃圾回收</a></h6>
<p>老生代的内存空间是一个连续的结构。</p>
<p>标记清除（Mark Sweep）：标记要回收的对象，直接释放相应的地址空间。执行完成之后会导致内存不连续 。</p>
<p>标记合并（Mark Compact）：将存活的对象移动到一边，需要被回收的移动到另一边。然后对需要被回收的区域进行整体垃圾回收。</p>
<h3 id="typeof"><a class="header" href="#typeof">typeof</a></h3>
<p><img src="JavaScript/./images/JS%E5%8F%98%E9%87%8F%E5%A4%8D%E4%B9%A0-image-20210718123027904.png" alt="image-20210718123027904" /></p>
<h2 id="变量计算"><a class="header" href="#变量计算">变量计算</a></h2>
<h3 id="强制类型转换的场景"><a class="header" href="#强制类型转换的场景">强制类型转换的场景</a></h3>
<ul>
<li>字符串拼接</li>
<li>== 运算符</li>
<li>if 语句</li>
<li>逻辑运算</li>
</ul>
<p><img src="JavaScript/./images/JS%E5%8F%98%E9%87%8F%E5%A4%8D%E4%B9%A0-image-20210718131419517.png" alt="image-20210718131419517" /></p>
<p><img src="JavaScript/./images/JS%E5%8F%98%E9%87%8F%E5%A4%8D%E4%B9%A0-image-20210718131523165.png" alt="image-20210718131523165" /></p>
<h4 id="双等号的比较的时候的类型转换"><a class="header" href="#双等号的比较的时候的类型转换">双等号的比较的时候的类型转换</a></h4>
<p><img src="JavaScript/./images/JS%E5%8F%98%E9%87%8F%E5%A4%8D%E4%B9%A0-image-20210718131629045.png" alt="image-20210718131629045" /></p>
<p><img src="JavaScript/./images/JS%E5%8F%98%E9%87%8F%E5%A4%8D%E4%B9%A0-image-20210718134441100.png" alt="image-20210718134441100" /></p>
<p><img src="JavaScript/./images/JS%E5%8F%98%E9%87%8F%E5%A4%8D%E4%B9%A0-image-20210718135241174.png" alt="image-20210718135241174" /></p>
<p><img src="JavaScript/./images/JS%E5%8F%98%E9%87%8F%E5%A4%8D%E4%B9%A0-image-20210718135354266.png" alt="image-20210718135354266" /></p>
<p><img src="JavaScript/./images/JS%E5%8F%98%E9%87%8F%E5%A4%8D%E4%B9%A0-image-20210718135544734.png" alt="image-20210718135544734" /></p>
<p><img src="JavaScript/./images/JS%E5%8F%98%E9%87%8F%E5%A4%8D%E4%B9%A0-image-20210718135613363.png" alt="image-20210718135613363" /></p>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-js">// 防抖。当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。
let deBounce = (fn, delay) =&gt; {
  let timer = null;
  return function (...args) {
    if (timer) {
      clearTimeout(timer);
    }
    timer = setTimeout(() =&gt; {
      fn(...args);
    }, delay);
  };
};

// 节流。当持续触发事件时，保证一定时间段内只调用一次事件处理函数。
let throttle = (fn, delay) =&gt; {
  let flag = true;
  return function (...args) {
    if (!flag) return;
    flag = false;
    setTimeout(() =&gt; {
      fn(...args);
      flag = true;
    }, delay);
  };
};

let deBounce2 = (fn, delay) =&gt; {
  let start = Date.now();
  return function (...args) {
    if (Date.now() - start &gt; delay) {
      fn(...args);
    }
    start = Date.now();
  };
};

let throttle2 = (fn, delay) =&gt; {
  let start = Date.now();
  return function (...args) {
    if (Date.now() - start &gt; delay) {
      fn(...args);
      start = Date.now();
    }
  };
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="异步"><a class="header" href="#异步">异步</a></h1>
<p><code>JS</code> 中的几种异步场景。</p>
<ol>
<li><code>setTimeout</code>，<code>setInterval</code></li>
<li>网络请求</li>
<li>事件绑定</li>
</ol>
<p>主要是因为 <code>JS</code> 是单线程的。</p>
<p>所以为了实现异步， <code>JS</code> 实现了事件循环机制。</p>
<p>循环过程如下：</p>
<ol>
<li>
<p>执行<code>script</code>主线程，</p>
</li>
<li>
<p>遇到 <code>setTimeout</code> ， <code>setInterval</code> 等宏任务，丢到宏任务队列中去，遇到 <code>Promise</code> ， <code>nextTick</code> 等微任务，丢到微任务队列中去。</p>
</li>
<li>
<p>当前宏任务执行完毕之后，拉取所有微任务队列中的数据，全部执行完毕。</p>
</li>
<li>
<p>再取宏任务队列中的第一个任务执行。回到 2。</p>
</li>
</ol>
<h2 id="事件绑定"><a class="header" href="#事件绑定">事件绑定</a></h2>
<p>一个简单的通用的事件绑定函数：</p>
<pre><code class="language-js">function bindEvent(elem, type, selector, fn) {
  if (fn == null) {
    fn = selector;
    selector = null;
  }
  elem.addEventListener(type, function (e) {
    var target;
    if (selector) {
      target = e.target;
      if (target.matches(selector)) {
        fn.call(target, e);
      }
    } else {
      fn(e);
    }
  });
}
</code></pre>
<h2 id="网络请求"><a class="header" href="#网络请求">网络请求</a></h2>
<p>一个简单的基于原生 <code>XMLHTTPRequest</code> 实现的网络请求</p>
<pre><code class="language-js">var xhr = new XMLHttpRequest();
xhr.open(&quot;GET&quot;, &quot;/api&quot;, false);
xhr.onreadystatechange = function () {
  if (xhr.readyState == 4) {
    if (xhr.status === 200) {
      alert(xhr.responseText);
    }
  }
};
xhr.send(null);
</code></pre>
<p><code>readyState</code> 的几种状态：</p>
<ul>
<li>0 - 未初始化，还没有调用 send()方法</li>
<li>1 - 载入，已调用 <code>send()</code> 方法，正在发送请求</li>
<li>2 - 载入完成，<code>send()</code> 方法执行完成，已经接收到全部响应内容</li>
<li>3 - 交互，正在解析响应内容</li>
<li>4 - 完成，响应内容解析完成，可以在客户端调用了</li>
</ul>
<h2 id="promise"><a class="header" href="#promise">Promise</a></h2>
<pre><code class="language-js">// 步骤一：了解promise规范
// 步骤二：实现
// 步骤三：测试
const statusMap = {
  PENDING: &quot;pending&quot;,
  FULFILLED: &quot;fulfilled&quot;,
  REJECTED: &quot;rejected&quot;,
};

// 将promise设置为fulfilled状态
function fulfilledPromise(promise, value) {
  // 只能从pending状态转换为其他状态
  if (promise.status !== statusMap.PENDING) {
    return;
  }
  promise.status = statusMap.FULFILLED;
  promise.value = value;
  runCbs(promise.fulfilledCbs, value);
}
// 将promise设置为rejected状态
function rejectedPromise(promise, reason) {
  // 只能从pending状态转换为其他状态
  if (promise.status !== statusMap.PENDING) {
    return;
  }
  promise.status = statusMap.REJECTED;
  promise.reason = reason;
  runCbs(promise.rejectedCbs, reason);
}
function runCbs(cbs, value) {
  cbs.forEach((cb) =&gt; cb(value));
}
function isFunction(fn) {
  return (
    Object.prototype.toString.call(fn).toLocaleLowerCase() ===
    &quot;[object function]&quot;
  );
}
function isObject(obj) {
  return (
    Object.prototype.toString.call(obj).toLocaleLowerCase() ===
    &quot;[object object]&quot;
  );
}
function isPromise(p) {
  return p instanceof Promise;
}

// promise的解析
function resolvePromise(promise, x) {
  // x 与promise相同
  if (promise === x) {
    rejectedPromise(promise, new TypeError(&quot;cant be the same&quot;));
    return;
  }
  // x 是promise
  if (isPromise(x)) {
    if (x.status === statusMap.FULFILLED) {
      fulfilledPromise(promise, x.value);
      return;
    }
    if (x.status === statusMap.REJECTED) {
      rejectedPromise(promise, x.reason);
      return;
    }
    if (x.status === statusMap.PENDING) {
      x.then(
        () =&gt; {
          fulfilledPromise(promise, x.value);
        },
        () =&gt; {
          rejectedPromise(promise, x.reason);
        }
      );
      return;
    }
    return;
  }
  if (isObject(x) || isFunction(x)) {
    let then;
    let called = false;
    try {
      then = x.then;
    } catch (error) {
      rejectedPromise(promise, error);
      return;
    }
    if (isFunction(then)) {
      try {
        then.call(
          x,
          (y) =&gt; {
            if (called) {
              return;
            }
            called = true;
            resolvePromise(promise, y);
          },
          (r) =&gt; {
            if (called) {
              return;
            }
            called = true;
            rejectedPromise(promise, r);
          }
        );
      } catch (error) {
        if (called) {
          return;
        }
        called = true;
        rejectedPromise(promise, error);
      }
      return;
    } else {
      fulfilledPromise(promise, x);
      return;
    } // x不是对象或者函数
  } else {
    fulfilledPromise(promise, x);
    return;
  }
}
class Promise {
  constructor(fn) {
    this.status = statusMap.PENDING;
    this.value = undefined;
    this.reason = undefined;
    this.fulfilledCbs = []; // then fulfilled callback
    this.rejectedCbs = []; // then rejected callback
    fn(
      (value) =&gt; {
        // fulfilledPromise(this, value);
        resolvePromise(this, value);
      },
      (reason) =&gt; {
        rejectedPromise(this, reason);
      }
    );
  }

  // 两个参数
  then(onFulfilled, onRejected) {
    const promise1 = this;
    const promise2 = new Promise(() =&gt; {});
    if (promise1.status === statusMap.FULFILLED) {
      if (!isFunction(onFulfilled)) {
        return promise1;
      }
      setTimeout(() =&gt; {
        try {
          const x = onFulfilled(promise1.value);
          resolvePromise(promise2, x);
        } catch (error) {
          rejectedPromise(promise2, error);
        }
      }, 0);
    }
    if (promise1.status === statusMap.REJECTED) {
      if (!isFunction(onRejected)) {
        return promise1;
      }
      setTimeout(() =&gt; {
        try {
          const x = onRejected(promise1.reason);
          resolvePromise(promise2, x);
        } catch (error) {
          rejectedPromise(promise2, error);
        }
      }, 0);
    }
    if (promise1.status === statusMap.PENDING) {
      onFulfilled = isFunction(onFulfilled)
        ? onFulfilled
        : (value) =&gt; {
            return value;
          };
      onRejected = isFunction(onRejected)
        ? onRejected
        : (err) =&gt; {
            throw err;
          };
      promise1.fulfilledCbs.push(() =&gt; {
        setTimeout(() =&gt; {
          try {
            const x = onFulfilled(promise1.value);
            resolvePromise(promise2, x);
          } catch (error) {
            rejectedPromise(promise2, error);
          }
        }, 0);
      });
      promise1.rejectedCbs.push(() =&gt; {
        setTimeout(() =&gt; {
          try {
            const x = onRejected(promise1.reason);
            resolvePromise(promise2, x);
          } catch (error) {
            rejectedPromise(promise2, error);
          }
        }, 0);
      });
    }
    return promise2;
  }
}

// 测试用到的钩子
Promise.deferred = function () {
  const deferred = {};
  deferred.promise = new Promise((resolve, reject) =&gt; {
    deferred.resolve = resolve;
    deferred.reject = reject;
  });
  return deferred;
};

module.exports = Promise;
</code></pre>
<h2 id="generator"><a class="header" href="#generator">Generator</a></h2>
<p>一个可迭代的对象的例子：</p>
<pre><code class="language-js">function createIterator(items) {
  var i = 0;
  return {
    next: function () {
      var done = i &gt;= items.length;
      var value = !done ? items[i++] : undefined;
      return {
        done: done,
        value: value,
      };
    },
  };
}

var iterator = createIterator([1, 2, 3]);

iterator.next();
iterator.next();
iterator.next();
iterator.next();
</code></pre>
<p>使用 <code>yield</code> 的情况， <code>yield</code> 会替换前一个的返回值。</p>
<pre><code class="language-js">// yield 例子
function* createIterator() {
  let first = yield 1;
  let second = yield first + 2;
  yield second + 3;
}
let iterator = createIterator();

iterator.next();
iterator.next(4);
iterator.next(5);
iterator.next();
</code></pre>
<p>Thunk 函数自动执行 generator：</p>
<pre><code class="language-js">// 代码
function run(fn) {
  var gen = fn(); //获得生成器对象

  // 递归调用自身的方法（类似尾递归的思路，执行完之后调用自身）
  function next(err, data) {
    // 获取生成器next执行之后的返回值。
    var result = gen.next(data);
    // 如果done了，就返回
    if (result.done) return;
    // 如果没有done，就调用自身，给fs.readFile的回调，让它在执行完之后
    // 执行next，next的传参是callback的传参
    result.value(next);
  }

  // 先执行一次
  next();
}

const Thunk = function (fn) {
  return function (...args) {
    return function (callback) {
      return fn.call(this, ...args, callback);
    };
  };
};

// 使用
const fs = require(&quot;fs&quot;);

const readFileThunk = Thunk(fs.readFile);

const g = function* () {
  const s1 = yield readFileThunk(&quot;xxx.xx&quot;);
  console.log(s1);
  const s2 = yield readFileThunk(&quot;xxx.xx&quot;);
  console.log(s2);
};
</code></pre>
<h2 id="asyncawait"><a class="header" href="#asyncawait">async/await</a></h2>
<p><code>async/await</code> 其实就是 <code>generator</code> 的语法糖， <code>await</code> 会被转译成 <code>yield</code> ，然后通过 <code>generator</code> 自执行来完成异步。</p>
<p>其实就是使用了 <code>Promise.then</code> 来完成上面的 <code>callback</code> 完成的东西，保证了返回值是 <code>Promise</code>。</p>
<pre><code class="language-js">async function example(params) {
  // xxx
}

// =&gt;

function example(params) {
  return spawn(function* () {
    // xxx
  });
}

function spawn(genF) {
  return new Promise(function (resolve, reject) {
    const gen = genF(); // 生成器对象
    function step(nextF) {
      let next;
      try {
        next = nextF(); // 执行gen.next
      } catch (e) {
        return reject(e);
      }
      if (next.done) {
        return resolve(next.value);
      }
      Promise.resolve(next.value).then(
        function (v) {
          step(function () {
            return gen.next(v);
          });
        },
        function (e) {
          step(function () {
            return gen.throw(e);
          });
        }
      );
    }
    step(function () {
      return gen.next(undefined);
    });
  });
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="函数相关"><a class="header" href="#函数相关">函数相关</a></h1>
<h2 id="compose-函数和-pipe-函数"><a class="header" href="#compose-函数和-pipe-函数">compose 函数和 pipe 函数</a></h2>
<p>函数组合，将多个函数组合在一起。</p>
<h3 id="compose-函数"><a class="header" href="#compose-函数">compose 函数</a></h3>
<ul>
<li>将需要嵌套执行的函数平铺</li>
<li>嵌套执行指的是，一个函数的返回值作为另一个函数的参数</li>
</ul>
<p><code>compose</code> 函数主要是实现了函数式编程中的 <code>pointfree</code> ，使我们专注于转换而不是数据本身。</p>
<p>也就是说，我们可以把数据处理的过程，定义成一种与参数无关合成运算。不需要关注参数本身，只需要将运算合成即可。</p>
<p><code>pointfree</code> 就是不使用所要处理的值，只合成运算过程。即无参数分隔。</p>
<pre><code class="language-js">let compose = function () {
  // 将arguments转为数组
  let args = [].slice.call(arguments);
  return function (params) {
    // 自右向左，依次执行
    return args.reduceRight(function (res, cb) {
      return cb(res);
    }, params);
  };
};
</code></pre>
<p>es6 版：</p>
<pre><code class="language-js">const compost =
  (...args) =&gt;
  (params) =&gt;
    args.reduceRight((res, cb) =&gt; cb(res), params);
</code></pre>
<p>Redux 就是依赖 compose 来实现中间件的功能的。</p>
<p>Webpack 的 loader 也是。</p>
<h3 id="pipe-函数"><a class="header" href="#pipe-函数">pipe 函数</a></h3>
<p>pipe 就是 compose 的复制版，只不过执行方向变了，改为从左向右</p>
<pre><code class="language-js">export default function Pipe(...funcs) {
  return (params) =&gt; funcs.reduce((res, cb) =&gt; cb(res), params);
}
</code></pre>
<h2 id="常用函数"><a class="header" href="#常用函数">常用函数</a></h2>
<h3 id="memozition"><a class="header" href="#memozition">memozition</a></h3>
<p>将上次的计算结果缓存起来，当下次调用时，如果遇到了相同的参数，就直接返回缓存中的数据</p>
<p>原理：</p>
<p>将参数和对应结果存储到一个对象中，调用时，先判断参数对应的数据是否存在，如果存在则直接返回，如果不存在才计算并存到缓存中。</p>
<p>闭包的灵魂体现！</p>
<p>lodash 中的 memoize 实现：</p>
<pre><code class="language-js">// func是需要缓存的函数，resolver是计算key的函数
function memoize(func, resolver) {
  // 类型校验
  if (
    typeof func !== &quot;function&quot; ||
    (resolver != null &amp;&amp; typeof resolver !== &quot;function&quot;)
  ) {
    throw new TypeError(&quot;Expected a function&quot;);
  }
  const memoized = function (...args) {
    // 先计算一下key，如果没有计算函数，则取第一个参数
    const key = resolver ? resolver.apply(this, args) : args[0];

    // 取缓存
    const cache = memoized.cache;

    // 如果缓存中有值，则直接返回
    if (cache.has(key)) {
      return cache.get(key);
    }
    // 缓存中没有值，先计算，再放入缓存中，再更新缓存
    const result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  // 缓存初始化为Map
  memoized.cache = new (memoize.Cache || Map)();
  // 返回缓存函数
  return memoized;
}

memoize.Cache = Map;

export default memoize;
</code></pre>
<p>使用场景：</p>
<p>需要大量重复计算或依赖之前的结果的情况</p>
<p>比如斐波那契数列</p>
<h3 id="curry"><a class="header" href="#curry">curry</a></h3>
<p>将使用多个参数的一个函数，转化成一系列使用一个参数的函数的技术。</p>
<p><img src="JavaScript/./images/image-20210819164407867.png" alt="image-20210819164407867" /></p>
<p>比如，使用正则校验一个字符串：</p>
<p><img src="JavaScript/./images/image-20210819164453937.png" alt="image-20210819164453937" /></p>
<p>或者从对象数组中取某一个字符的值</p>
<p><img src="JavaScript/./images//image-20210819165020776.png" alt="image-20210819165020776" /></p>
<p>在调用 <code>getProp(&quot;age&quot;)</code> 之后，这个的返回值，就变成了接受一个对象并返回对象的 <code>age</code> 属性的函数，放在 map 中就很舒服了。</p>
<h3 id="偏函数"><a class="header" href="#偏函数">偏函数</a></h3>
<p>如果说，柯里化是将一个多参数函数转换成多个单参数函数，也就是将一个 n 元函数转换成 n 个一元函数。</p>
<p>那么偏函数就是固定一个函数的一个或者多个参数，也就是将一个 n 元函数转换成一个 n-x 元函数。</p>
<p>也就是：</p>
<pre><code class="language-js">柯里化： f(a,b,c) =&gt; f(a)(b)(c)
偏函数： f(a,b,c) =&gt; f(a,b)(c)
</code></pre>
<p>可以简单实用 bind 来实现</p>
<pre><code class="language-js">let add = (x, y) =&gt; x + y;
let rst = add.bind(null, 1);
rst(2); // 3
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="时间窗口"><a class="header" href="#时间窗口">时间窗口</a></h1>
<p>在一定时间内，如果请求同一个 url，则只请求一次。</p>
<pre><code class="language-javascript">const fetch = require(&quot;node-fetch&quot;);

function hash(...args) {
  return args.join(&quot;,&quot;);
}

function window_request(f, time = 50) {
  let w = {};
  // 是否有时间窗口
  let flag = false;

  return (...args) =&gt; {
    return new Promise((resolve) =&gt; {
      // 如果w中没有这次请求（通过hash存入）, 如果有，则在最后 L54 将resolve存入到对应的resolvers里
      if (!w[hash(args)]) {
        w[hash(args)] = {
          func: f,
          args,
          // 将不同的request的resolve也添加进来，方便最后统一做处理。
          resolvers: [],
        };
      }

      // 如果没有时间窗口
      if (!flag) {
        // 接下来是创建一个时间窗口
        console.log(&quot;create a window&quot;);
        flag = true;
        setTimeout(() =&gt; {
          // 对w中每一个请求进行处理。
          Object.keys(w).forEach((key) =&gt; {
            // 获取参数进行执行
            const { func, args, resolvers } = w[key];
            console.log(&quot;run once ---- &quot;, resolvers.length);
            func(...args)
              .then((res) =&gt; {
                return res.text();
              })
              .then((t) =&gt; {
                // 将获取到的结果批量放到resolve中处理
                resolvers.forEach((r) =&gt; {
                  console.log(&quot;result anywhere&quot;);
                  r(t);
                });
                // 重置访问窗口
                flag = false;
                w = {};
              });
          });
        }, time);
      }

      w[hash(args)].resolvers.push(resolve);
    });
  };
}

const request = window_request(fetch, 20);

request(&quot;https://www.baidu.com&quot;);
request(&quot;https://www.baidu.com&quot;);
request(&quot;https://www.baidu.com&quot;);
request(&quot;https://www.baidu.com&quot;);
request(&quot;https://www.baidu.com&quot;);
request(&quot;https://www.baidu.com&quot;);
request(&quot;https://www.baidu.com&quot;);
console.log(&quot;break&quot;);
setTimeout(() =&gt; {
  request(&quot;https://www.baidu.com&quot;);
  request(&quot;https://www.baidu.com&quot;);
  request(&quot;https://www.baidu.com&quot;);
  request(&quot;https://www.baidu.com&quot;);
  request(&quot;https://www.baidu.com&quot;);
  request(&quot;https://www.baidu.com&quot;);
  request(&quot;https://www.baidu.com&quot;);
}, 10000);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="指数补偿"><a class="header" href="#指数补偿">指数补偿</a></h1>
<h2 id="在网络环境不稳定的情况下以指数级别的时间间隔发送请求直到任意某一次请求得到了返回"><a class="header" href="#在网络环境不稳定的情况下以指数级别的时间间隔发送请求直到任意某一次请求得到了返回">在网络环境不稳定的情况下，以指数级别的时间间隔发送请求，直到任意某一次请求得到了返回</a></h2>
<pre><code class="language-javascript">function request(url) {
  // 判断是否已经完成请求
  let resolved = false;
  // 次数
  let t = 1;

  return new Promise((resolve, reject) =&gt; {
    function doFetch() {
      // 如果已经完成请求，或者次数已达上限，则直接返回
      if (resolved || t &gt; 16) {
        return;
      }
      // 否则发送请求
      fetch(url).then((resp) =&gt; {
        // 如果标记还处在未完成的状态
        if (!resolved) {
          // 将结果返回
          resolve(resp);
          // 将标记置为已完成
          resolved = true;
        }
      });
      // 指数级的时间间隔发送请求
      setTimeout(() =&gt; {
        // 调用自己
        doFetch();
        t *= 2;
      }, t * 100);
    }

    // 首次调用
    doFetch();
  });
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="问题引入"><a class="header" href="#问题引入">问题引入</a></h1>
<p>最近一直在看原型继承相关的东西，翻到这么一篇文章：
<a href="http://wulv.site/2017-05-29/%E4%BB%8EES6%E4%B8%AD%E7%9A%84extends%E8%AE%B2js%E5%8E%9F%E5%9E%8B%E9%93%BE%E4%B8%8E%E7%BB%A7%E6%89%BF.html">从 ES6 中的 extends 讲 js 原型链与继承</a></p>
<p>文中有一个点让我很感兴趣，箭头函数在继承过程中无法通过 super 关键字获取，这是为什么呢？</p>
<h1 id="前置知识"><a class="header" href="#前置知识">前置知识</a></h1>
<h2 id="mdn-上关于-super-的介绍"><a class="header" href="#mdn-上关于-super-的介绍">MDN 上关于 super 的介绍</a></h2>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/super">The super keyword is used to access and call functions on an object's parent - in
MDN</a> 大概有这么几个关键点：</p>
<ol>
<li>子类中存在 constructor 方法的时候，需要调用 super 方法，并且需要在使用 this 关键字之前调用</li>
<li>super 关键字可以用来调用父对象上的方法</li>
<li>可以使用 super 来调用父对象上的静态方法</li>
<li>不可以使用 delete 来删除 super 上的属性</li>
<li>不可以复写 super 对象上的只读属性</li>
</ol>
<h2 id="子类中是否必须主动调用-super-方法"><a class="header" href="#子类中是否必须主动调用-super-方法">子类中是否必须主动调用 super 方法？</a></h2>
<p>我的看法是不需要。 网上有些文章（<a href="https://segmentfault.com/a/1190000008165717">比如这篇</a>）写道：</p>
<blockquote>
<p>因为若不执行 super，则 this 无法初始化。</p>
</blockquote>
<p>我的个人理解是，this 是指代执行上下文环境的，不存在无法初始化的情况。更准确的说法是这样：如果不使用 super 方法，那么父类中的属性值无法进行初始化，如果这个时候子类通过 this
字段来访问了父类中的属性值，那么只能得到一个 undefined。至于为什么这么写编译的时候会报错？我的理解是，这应该是一种语法错误，而且是一种规范要求，ES6
语法的规范要求，这种要求并不是说会影响到代码的实际执行。举个栗子：</p>
<pre><code>// typescript中一段简单的继承代码实现
class Parent {
    name = 'parent';
    func = function() {
        console.log('func in parent called.');
    }
}

class Child extends Parent {
    age = 3;
    func = function() {
        console.log('age is: ', this.age);    // 使用了this，不会报错
    }
}
</code></pre>
<p>这段代码非常简单，在子类中使用了 this 关键字，编译时不会报错，也可以正常执行。然后我们进行一点修改，在子类中引入 constructor 方法</p>
<pre><code>class Child extends Parent {
    age = 3;
    // error TS2377: Constructors for derived classes must contain a 'super' call.
    constructor() {

    }
    func = function() {
        console.log('age is: ', this.age);
    }
}
</code></pre>
<p>可以看到，编译阶段已经开始报错了。在 typescript 的语法中，子类的 constructor 方法中不但需要调用 super 方法，而且必须在第一行代码就调用
super，否则都是会报错的。看下面这段代码:</p>
<pre><code>class Child extends Parent {
    age = 3;
    constructor() {
        console.log('First line in constructor without super method');
        super();    // error TS2376: A 'super' call must be the first statement in the constructor when a class contains initialized properties or has parameter properties.
    }
    func = function() {
        console.log('age is: ', this.age);
    }
}
</code></pre>
<p>来，我们接着改</p>
<pre><code>class Parent {
    name = 'parent';
    func = function() {
        console.log('func in parent called.');
    }
}

class Child extends Parent {
    age = 3;
    constructor() {
        console.log('Show property of parent, name is: ', this.name);    // error TS17009: 'super' must be called before accessing 'this' in the constructor of a derived class.
        console.log('Show property of child, age is: ', this.age);        // error TS17009: 'super' must be called before accessing 'this' in the constructor of a derived class.
        super();    // error TS2376: A 'super' call must be the first statement in the constructor when a class contains initialized properties or has parameter properties.
        console.log('Show property of parent, name is: ', this.name);
        console.log('Show property of child, age is: ', this.age);
    }
    func = function() {
        console.log('age is: ', this.age);
    }
}
</code></pre>
<p>可以看到，编译期已经开始报各种错误了，不过这不重要，我们这里利用 typescript 的编译器（tsc）来进行编译，并查看编译后的代码内容：</p>
<pre><code>var __extends = (this &amp;&amp; this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array &amp;&amp; function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var Parent = (function () {
    function Parent() {
        this.name = 'parent';
        this.func = function () {
            console.log('func in parent called.');
        };
    }
    return Parent;
}());
var Child = (function (_super) {
    __extends(Child, _super);
    function Child() {
        var _this = this;
        _this.age = 3;
        _this.func = function () {
            console.log('age is: ', this.age);
        };
        console.log('Show property of parent, name is: ', _this.name); // 输出undefined，因为此时子类的实例上还没有继承到父类的属性值
        console.log('Show property of child, age is: ', _this.age); // 输出3，子类实例自己的属性值可以访问
        _this = _super.call(this) || this; // 构造函数式的继承实现，这一步就是讲父类的属性值设置到子类实例上
        console.log('Show property of parent, name is: ', _this.name); // 输出parent，此时子类的实例上经过上一步的继承，得到了父类的属性值
        console.log('Show property of child, age is: ', _this.age);  // 输出3，子类实例自己的属性值可以访问
        return _this;
    }
    return Child;
}(Parent));
//# sourceMappingURL=demo.js.map
</code></pre>
<p>由此可以知道，在 ES6 中使用 extends 进行继承操作的过程中，</p>
<ul>
<li>子类并非必须调用 super 方法，除非存在 constructor 方法</li>
<li>在 constructor 方法中应该首先调用 super 方法，这是语法要求，不过这不是必须的</li>
<li>在调用 super 方法之前，将无法通过 this 关键字来访问父类的属性（这里就可以解释其他文章中提到的 ‘若不执行 super，则 this 无法初始化’，更准确的说法应该是‘若不执行
super，则无法将父类的属性值初始化到当前子类实例上’）</li>
</ul>
<h2 id="子类中使用-superprop-和-superexpr的方式是如何访问父类的属性和方法"><a class="header" href="#子类中使用-superprop-和-superexpr的方式是如何访问父类的属性和方法">子类中使用 super.prop 和 super[expr]的方式是如何访问父类的属性和方法？</a></h2>
<p>我们直接来看代码吧,关键点都注释了的</p>
<pre><code>class Parent {
    public name = 'parent';
    public static staticName = 'staticParent';
    public static staticFunc() {
        console.log('staticFunc called in parent.');
    }

    public arrowFunc = () =&gt; {
        console.log('arrowFunc called in parent.');
    }

    public normalFunc() {
        console.log('normalFunc called in parent.')
    }
}

class Child extends Parent {
    public static staticFunc() {
        super.staticFunc();
        console.log('staticFunc called in Child.');
    }

    arrowFunc = () =&gt; {
        super.arrowFunc();
        console.log('arrowFunc called in Child.');
    }

    normalFunc() {
        super.normalFunc();
        console.log('normalFunc called in Child.')
    }

    getName() {
        console.log('parent name is: ', super.name);
        console.log('parent staticName is: ', super.staticName);
        console.log('child name is: ', this.name);
    }
}

/** 编译后的代码 **/
var __extends = (this &amp;&amp; this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array &amp;&amp; function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var Parent = (function () {
    function Parent() {
        this.name = 'parent';
        this.arrowFunc = function () {
            console.log('arrowFunc called in parent.');
        };
    }
    // 编译后的静态方法可以存在于Parent类的内部
    Parent.staticFunc = function () {
        console.log('staticFunc called in parent.');
    };
    Parent.prototype.normalFunc = function () {
        console.log('normalFunc called in parent.');
    };
    return Parent;
}());
Parent.staticName = 'staticParent'; // 编译后的静态属性依然存在于Parent类外
var Child = (function (_super) {
    __extends(Child, _super);
    function Child() {
        var _this = _super !== null &amp;&amp; _super.apply(this, arguments) || this;
        _this.arrowFunc = function () { // 子类实例调用arrowFunc的时候会报错，因为_super.prototype上是不存在arrowFunc方法的
            _super.prototype.arrowFunc.call(_this); // Uncaught TypeError: Cannot read property 'call' of undefined
            console.log('arrowFunc called in Child.');
        };
        return _this;
    }
    Child.staticFunc = function () {
        _super.staticFunc.call(this);   // super可以正常访问父类的静态方法
        console.log('staticFunc called in Child.');
    };
    Child.prototype.normalFunc = function () {
        _super.prototype.normalFunc.call(this);
        console.log('normalFunc called in Child.');
    };
    Child.prototype.getName = function () {
        console.log('parent name is: ', _super.prototype.name); // 输出undefined， 父类原型（_super.prototype）上不存在name属性
        console.log('parent staticName is: ', _super.prototype.staticName); // 输出undefined，super无法正常访问父类的静态属性
        console.log('child name is: ', this.name);  // 输出parent，这是子类实例上的属性，继承自父类
    };
    return Child;
}(Parent));
//# sourceMappingURL=demo.js.map
</code></pre>
<p>这里再顺嘴提一句，关于静态属性和静态方法的区别。为什么在子类中通过 super
关键字来获取父类的静态方法经过编译后是_super.staticFunc，而获取静态属性依然是_super.prototype.staticName，从原型上获取导致获取失败呢？这个问题目前我还没有找到答案，希望有知道的小伙伴可以不吝指教。
不过我倒是搜到一些其他相关内容。 <a href="http://es6.ruanyifeng.com/#docs/class">Class 的静态属性和实例属性</a></p>
<blockquote>
<p>因为 ES6 明确规定，Class 内部只有静态方法，没有静态属性。</p>
</blockquote>
<p>虽然这种规定从 ES7 开始得到了修正，我们目前已经可以将静态属性写在 Class 的内部，但是经过编译之后可以发现，静态属性依然存在于类的实现的外部。</p>
<pre><code>var Parent = (function () {
    function Parent() {
        this.name = 'parent';
        this.arrowFunc = function () {
            console.log('arrowFunc called in parent.');
        };
    }
    // 编译后的静态方法可以存在于Parent类的内部
    Parent.staticFunc = function () {
        console.log('staticFunc called in parent.');
    };
    Parent.prototype.normalFunc = function () {
        console.log('normalFunc called in parent.');
    };
    return Parent;
}());
Parent.staticName = 'staticParent'; // 编译后的静态属性依然存在于Parent类外
</code></pre>
<h1 id="回到问题本身"><a class="header" href="#回到问题本身">回到问题本身</a></h1>
<p>问：箭头函数在继承过程中无法通过 super 关键字获取，这是为什么呢？ 答：因为子类中使用 super.prop 和
super[expr]的方式获取的是父类原型（prototype）上的方法，静态方法除外。</p>
<h1 id="参考资料"><a class="header" href="#参考资料">参考资料</a></h1>
<p><a href="http://wulv.site/2017-05-29/%E4%BB%8EES6%E4%B8%AD%E7%9A%84extends%E8%AE%B2js%E5%8E%9F%E5%9E%8B%E9%93%BE%E4%B8%8E%E7%BB%A7%E6%89%BF.html">从 ES6 中的 extends 讲 js 原型链与继承</a>
<a href="https://segmentfault.com/a/1190000008165717">React ES6 class constructor super()</a>
<a href="http://es6.ruanyifeng.com/#docs/class">Class 的静态属性和实例属性</a></p>
<p><a href="https://blog.csdn.net/qq_32442967/article/details/100086200?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2.not_use_machine_learn_pai&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2.not_use_machine_learn_pai">备份自</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="require-和-import-和-export-等"><a class="header" href="#require-和-import-和-export-等">Require 和 import 和 export 等</a></h1>
<p>这篇文章主要给大家介绍了关于 <code>javascript</code> 中 <code>require</code> 、 <code>import</code> 与 <code>export</code>
的相关资料，文中通过示例代码介绍的非常详细，对打击大的学习或者工作具有一定的参考学习价值，需要的朋友们下面随着小编来一起学习学习吧。</p>
<h2 id="前言"><a class="header" href="#前言">前言</a></h2>
<p>本文主要给大家介绍了关于 <code>javascript</code> 中 <code>require</code> 、 <code>import</code> 与 <code>export</code> 的相关内容，分享出来供大家参考学习，下面话不多说了，来一起看看详细的介绍吧。</p>
<h3 id="为什么有模块概念"><a class="header" href="#为什么有模块概念">为什么有模块概念</a></h3>
<p>理想情况下，开发者只需要实现核心的业务逻辑，其他都可以加载别人已经写好的模块。</p>
<p>但是， <code>Javascript</code> 不是一种模块化编程语言，在 <code>es6</code> 以前，它是不支持”类”（ <code>class</code> ），所以也就没有”模块”（ <code>module</code> ）了。</p>
<h3 id="require-时代"><a class="header" href="#require-时代">require 时代</a></h3>
<p><code>Javascript</code> 社区做了很多努力，在现有的运行环境中，实现”模块”的效果。</p>
<h4 id="原始写法"><a class="header" href="#原始写法">原始写法</a></h4>
<p>模块就是实现特定功能的一组方法。 只要把不同的函数（以及记录状态的变量）简单地放在一起，就算是一个模块。</p>
<pre><code class="language-js">function m1() {
  //...
}
function m2() {
  //...
}
</code></pre>
<p>上面的函数 <code>m1()</code> 和 <code>m2()</code> ，组成一个模块。使用的时候，直接调用就行了。</p>
<p>这种做法的缺点很明显：”污染”了全局变量，无法保证不与其他模块发生变量名冲突，而且模块成员之间看不出直接关系。</p>
<h4 id="对象写法"><a class="header" href="#对象写法">对象写法</a></h4>
<p>为了解决上面的缺点，可以把模块写成一个对象，所有的模块成员都放到这个对象里面</p>
<pre><code class="language-js">var module1 = new Object({
  _count: 0,
  m1: function () {
    //...
  },
  m2: function () {
    //...
  },
});
</code></pre>
<p>上面的函数 <code>m1()</code> 和 <code>m2()</code>，都封装在 <code>module</code> 1 对象里。使用的时候，就是调用这个对象的属性</p>
<pre><code class="language-js">module1.m1();
</code></pre>
<p>这样的写法会暴露所有模块成员，内部状态可以被外部改写。比如，外部代码可以直接改变内部计数器的值。</p>
<pre><code class="language-js">module._count = 1;
</code></pre>
<h4 id="立即执行函数写法闭包缓存"><a class="header" href="#立即执行函数写法闭包缓存">立即执行函数写法(闭包缓存)</a></h4>
<p>使用”立即执行函数”（<code>Immediately-Invoked Function Expression，IIFE</code>），可以达到不暴露私有成员的目的</p>
<pre><code class="language-js">var module = (function () {
  var _count = 0;
  var m1 = function () {
    alert(_count);
  };
  var m2 = function () {
    alert(_count + 1);
  };
  return {
    m1: m1,
    m2: m2,
  };
})();
</code></pre>
<p>使用上面的写法，外部代码无法读取内部的 <code>_count</code> 变量。</p>
<pre><code class="language-js">console.info(module._count); //undefined
</code></pre>
<p><code>module</code> 就是 <code>Javascript</code> 模块的基本写法。</p>
<h3 id="主流模块规范"><a class="header" href="#主流模块规范">主流模块规范</a></h3>
<p>在 <code>es6</code> 以前，还没有提出一套官方的规范,从社区和框架推广程度而言,目前通行的 <code>javascript</code> 模块规范有两种： <code>CommonJS</code> 和 <code>AMD</code></p>
<h4 id="commonjs-规范"><a class="header" href="#commonjs-规范">CommonJS 规范</a></h4>
<p>2009 年，美国程序员 <code>Ryan Dahl</code> 创造了 <code>node.js</code> 项目，将 <code>javascript</code> 语言用于服务器端编程。</p>
<p>这标志”Javascript 模块化编程”正式诞生。前端的复杂程度有限，没有模块也是可以的，但是在服务器端，一定要有模块，与操作系统和其他应用程序互动，否则根本没法编程。</p>
<p><code>node</code> 编程中最重要的思想之一就是模块，而正是这个思想，让 <code>JavaScript</code> 的大规模工程成为可能。模块化编程在 <code>js</code> 界流行，也是基于此，随后在浏览器端， <code>requirejs</code>
和 <code>seajs</code> 之类的工具包也出现了，可以说在对应规范下， <code>require</code> 统治了 <code>ES6</code> 之前的所有模块化编程，即使现在，在 <code>ES6 module</code> 被完全实现之前，还是这样。</p>
<p>在 <code>CommonJS</code> 中,暴露模块使用 <code>module</code> . <code>exports</code> 和 <code>exports</code> ，很多人不明白暴露对象为什么会有两个,后面会介绍区别</p>
<p>在 <code>CommonJS</code> 中，有一个全局性方法 <code>require()</code> ，用于加载模块。假定有一个数学模块 <code>math.js</code>，就可以像下面这样加载。</p>
<pre><code class="language-js">var math = require(&quot;math&quot;);
</code></pre>
<p>然后，就可以调用模块提供的方法：</p>
<pre><code class="language-js">var math = require(&quot;math&quot;);
math.add(2, 3); // 5
</code></pre>
<p>正是由于 <code>CommonJS</code> 使用的 <code>require</code> 方式的推动，才有了后面的 <code>AMD</code> 、 <code>CMD</code> 也采用的 <code>require</code> 方式来引用模块的风格</p>
<h4 id="amd-规范"><a class="header" href="#amd-规范">AMD 规范</a></h4>
<p>有了服务器端模块以后，很自然地，大家就想要客户端模块。而且最好两者能够兼容，一个模块不用修改，在服务器和浏览器都可以运行。</p>
<p>但是，由于一个重大的局限，使得 <code>CommonJS</code> 规范不适用于浏览器环境。还是上一节的代码，如果在浏览器中运行，会有一个很大的问题</p>
<pre><code class="language-js">var math = require(&quot;math&quot;);
math.add(2, 3);
</code></pre>
<p>第二行 <code>math.add(2, 3)</code> ，在第一行 <code>require('math')</code> 之后运行，因此必须等 <code>math.js</code> 加载完成。也就是说，如果加载时间很长，整个应用就会停在那里等。</p>
<p>这对服务器端不是一个问题，因为所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间。但是，对于浏览器，这却是一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于”假死”状态。</p>
<p>因此，浏览器端的模块，不能采用”同步加载”（ <code>synchronous</code> ），只能采用”异步加载”（ <code>asynchronous</code> ）。这就是 <code>AMD</code> 规范诞生的背景。</p>
<p><code>AMD</code> 是 <code>Asynchronous Module Definition</code>
的缩写，意思就是”异步模块定义”。它采用步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一回调函数中，等到加载完成之后，这个回调函数才会运行。</p>
<p>模块必须采用特定的 <code>define()</code> 函数来定义。</p>
<pre><code class="language-js">define(id?, dependencies?, factory);
</code></pre>
<ul>
<li>id:字符串，模块名称(可选)</li>
<li>dependencies: 是我们要载入的依赖模块(可选)，使用相对路径。,注意是数组格式</li>
<li>factory: 工厂方法，返回一个模块函数</li>
</ul>
<p>如果一个模块不依赖其他模块，那么可以直接定义在 <code>define()</code> 函数之中。</p>
<pre><code class="language-js">// math.js
define(function () {
  var add = function (x, y) {
    return x + y;
  };
  return {
    add: add,
  };
});
</code></pre>
<p>如果这个模块还依赖其他模块，那么 <code>define()</code> 函数的第一个参数，必须是一个数组，指明该模块的依赖性。</p>
<pre><code class="language-js">define([&quot;Lib&quot;], function (Lib) {
  function foo() {
    Lib.doSomething();
  }
  return {
    foo: foo,
  };
});
</code></pre>
<p>当 <code>require()</code> 函数加载上面这个模块的时候，就会先加载 <code>Lib.js</code> 文件。</p>
<p><code>AMD</code> 也采用 <code>require()</code> 语句加载模块，但是不同于 <code>CommonJS</code> ，它要求两个参数：</p>
<pre><code class="language-js">require([module], callback);
</code></pre>
<p>第一个参数 <code>[module]</code> ，是一个数组，里面的成员就是要加载的模块；第二个参数 <code>callback</code> ，则是加载成功之后的回调函数。如果将前面的代码改写成 <code>AMD</code> 形式，就是下面这样：</p>
<pre><code class="language-js">require([&quot;math&quot;], function (math) {
  math.add(2, 3);
});
</code></pre>
<p><code>math.add()</code> 与 <code>math</code> 模块加载不是同步的，浏览器不会发生假死。所以很显然， <code>AMD</code> 比较适合浏览器环境。</p>
<p>目前，主要有两个 <code>Javascript</code> 库实现了 <code>AMD</code> 规范：<code>require.js</code> 和 <code>curl.js</code>。</p>
<h4 id="cmd-规范"><a class="header" href="#cmd-规范">CMD 规范</a></h4>
<p><code>CMD</code> (<code>Common Module Definition</code>), 是 <code>seajs</code> 推崇的规范， <code>CMD</code> 则是依赖就近，用的时候再 <code>require</code> 。它写起来是这样的：</p>
<pre><code class="language-js">define(function (require, exports, module) {
  var clock = require(&quot;clock&quot;);
  clock.start();
});
</code></pre>
<p><code>CMD</code> 与 <code>AMD</code> 一样，也是采用特定的 <code>define()</code> 函数来定义,用 <code>require</code> 方式来引用模块</p>
<pre><code class="language-js">define(id?, dependencies?, factory);
</code></pre>
<ul>
<li>id:字符串，模块名称(可选)</li>
<li>dependencies: 是我们要载入的依赖模块(可选)，使用相对路径。,注意是数组格式</li>
<li>factory: 工厂方法，返回一个模块函数</li>
</ul>
<pre><code class="language-js">define(&quot;hello&quot;, [&quot;jquery&quot;], function (require, exports, module) {
  // 模块代码
});
</code></pre>
<p>如果一个模块不依赖其他模块，那么可以直接定义在 <code>define()</code> 函数之中。</p>
<pre><code class="language-js">define(function (require, exports, module) {
  // 模块代码
});
</code></pre>
<p>注意：带 <code>id</code> 和 <code>dependencies</code> 参数的 <code>define</code> 用法不属于 <code>CMD</code> 规范，而属于 <code>Modules/Transport</code> 规范。</p>
<p><code>CMD</code> 与 <code>AMD</code> 区别</p>
<p><code>AMD</code>和 <code>CMD</code> 最大的区别是对依赖模块的执行时机处理不同，而不是加载的时机或者方式不同，二者皆为异步加载模块。</p>
<p><code>AMD</code> 依赖前置， <code>js</code> 可以方便知道依赖模块是谁，立即加载；</p>
<p>而 <code>CMD</code> 就近依赖，需要使用把模块变为字符串解析一遍才知道依赖了那些模块，这也是很多人诟病 <code>CMD</code> 的一点，牺牲性能来带来开发的便利性，实际上解析模块用的时间短到可以忽略。</p>
<h4 id="现阶段的标准"><a class="header" href="#现阶段的标准">现阶段的标准</a></h4>
<p><code>ES6</code> 标准发布后， <code>module</code> 成为标准，标准使用是以 <code>export</code> 指令导出接口，以 <code>import</code> 引入模块，但是在我们一贯的 <code>node</code> 模块中，我们依然采用的是
<code>CommonJS</code> 规范，使用 <code>require</code> 引入模块，使用 <code>module.exports</code> 导出接口。</p>
<h5 id="export-导出模块"><a class="header" href="#export-导出模块">export 导出模块</a></h5>
<p><code>export</code> 语法声明用于导出函数、对象、指定文件（或模块）的原始值。</p>
<p>注意：在 <code>node</code> 中使用的是 <code>exports</code> ,不要混淆了</p>
<p><code>export</code> 有两种模块导出方式：命名式导出（名称导出）和默认导出（定义式导出），命名式导出每个模块可以多个，而默认导出每个模块仅一个。</p>
<pre><code class="language-js">export { name1, name2, …, nameN };
    export { variable1 as name1, variable2 as name2, …, nameN };
    export let name1, name2, …, nameN; // also var
    export let name1 = …, name2 = …, …, nameN; // also var, const
    export default expression;
    export default function (…) { … } // also class, function*
    export default function name1(…) { … } // also class, function*
    export { name1 as default, … };
    export * from …;
    export { name1, name2, …, nameN } from …;
    export { import1 as name1, import2 as name2, …, nameN } from …;
</code></pre>
<ul>
<li><code>name1… nameN</code>－导出的“标识符”。导出后，可以通过这个“标识符”在另一个模块中使用 <code>import</code> 引用</li>
<li><code>default</code> －设置模块的默认导出。设置后 <code>import</code> 不通过“标识符”而直接引用默认导入</li>
<li>－继承模块并导出继承模块所有的方法和属性</li>
<li><code>as</code> －重命名导出“标识符”</li>
<li><code>from</code> －从已经存在的模块、脚本文件…导出</li>
</ul>
<h5 id="命名式导出"><a class="header" href="#命名式导出">命名式导出</a></h5>
<p>模块可以通过 <code>export</code> 前缀关键词声明导出对象，导出对象可以是多个。这些导出对象用名称进行区分，称之为命名式导出。</p>
<pre><code class="language-js">export { myFunction }; // 导出一个已定义的函数
export const foo = Math.sqrt(2); // 导出一个常量
</code></pre>
<p>我们可以使用 <code>*</code> 和 <code>from</code> 关键字来实现的模块的继承：</p>
<pre><code class="language-js">export * from &quot;article&quot;;
</code></pre>
<p>模块导出时，可以指定模块的导出成员。导出成员可以认为是类中的公有对象，而非导出成员可以认为是类中的私有对象：</p>
<pre><code class="language-js">var name = &quot;IT笔录&quot;;
var domain = &quot;http://itbilu.com&quot;;
export { name, domain }; // 相当于导出{name:name,domain:domain}
</code></pre>
<p>模块导出时，我们可以使用 <code>as</code> 关键字对导出成员进行重命名：</p>
<pre><code class="language-js">var name = &quot;IT笔录&quot;;
var domain = &quot;http://itbilu.com&quot;;
export { name as siteName, domain };
</code></pre>
<p>注意：下面的语法有严重错误的情况：</p>
<pre><code class="language-js">// 错误演示
export 1; // 绝对不可以
var a = 100;
export a;
</code></pre>
<p><code>export</code> 在导出接口的时候，必须与模块内部的变量具有一一对应的关系。直接导出 1 没有任何意义，也不可能在 <code>import</code> 的时候有一个变量与之对应</p>
<p><code>export a</code> 虽然看上去成立，但是 <code>a</code> 的值是一个数字，根本无法完成解构，因此必须写成 <code>export {a}</code> 的形式。即使 <code>a</code> 被赋值为一个 <code>function</code>
，也是不允许的。而且，大部分风格都建议，模块中最好在末尾用一个 <code>export</code> 导出所有的接口，例如：</p>
<pre><code class="language-js">export { fun as default, a, b, c };
</code></pre>
<h5 id="默认导出"><a class="header" href="#默认导出">默认导出</a></h5>
<p>默认导出也被称做定义式导出。命名式导出可以导出多个值，但在在 <code>import</code>
引用时，也要使用相同的名称来引用相应的值。而默认导出每个导出只有一个单一值，这个输出可以是一个函数、类或其它类型的值，这样在模块 <code>import</code> 导入时也会很容易引用。</p>
<pre><code class="language-js">export default function() {}; // 可以导出一个函数
export default class(){}; // 也可以出一个类
</code></pre>
<h5 id="命名式导出与默认导出"><a class="header" href="#命名式导出与默认导出">命名式导出与默认导出</a></h5>
<p>默认导出可以理解为另一种形式的命名导出，默认导出可以认为是使用了 <code>default</code> 名称的命名导出。</p>
<p>下面两种导出方式是等价的：</p>
<pre><code class="language-js">const D = 123;
export default D;
export { D as default };
</code></pre>
<p><code>export</code> 使用示例</p>
<p>使用名称导出一个模块时：</p>
<pre><code class="language-js">// &quot;my-module.js&quot; 模块
export function cube(x) {
  return x * x * x;
}
const foo = Math.PI + Math.SQRT2;
export { foo };
</code></pre>
<p>在另一个模块（脚本文件）中，我们可以像下面这样引用：</p>
<pre><code class="language-js">import { cube, foo } from &quot;my-module&quot;;
console.log(cube(3)); // 27
console.log(foo); // 4.555806215962888
</code></pre>
<p>使用默认导出一个模块时：</p>
<pre><code class="language-js">// &quot;my-module.js&quot;模块
export default function (x) {
  return x * x * x;
}
</code></pre>
<p>在另一个模块（脚本文件）中，我们可以像下面这样引用，相对名称导出来说使用更为简单：</p>
<pre><code class="language-js">// 引用 &quot;my-module.js&quot;模块
import cube from &quot;my-module&quot;;
console.log(cube(3)); // 27
</code></pre>
<h5 id="import-引入模块"><a class="header" href="#import-引入模块">import 引入模块</a></h5>
<p><code>import</code> 语法声明用于从已导出的模块、脚本中导入函数、对象、指定文件（或模块）的原始值。</p>
<p><code>import</code> 模块导入与 <code>export</code> 模块导出功能相对应，也存在两种模块导入方式：命名式导入（名称导入）和默认导入（定义式导入）。</p>
<p><code>import</code> 的语法跟 <code>require</code> 不同，而且 <code>import</code> 必须放在文件的最开始，且前面不允许有其他逻辑代码，这和其他所有编程语言风格一致。</p>
<pre><code class="language-js">import defaultMember from &quot;module-name&quot;;
import * as name from &quot;module-name&quot;;
import { member } from &quot;module-name&quot;;
import { member as alias } from &quot;module-name&quot;;
import { member1 , member2 } from &quot;module-name&quot;;
import { member1 , member2 as alias2 , [...] } from &quot;module-name&quot;;
import defaultMember, { member [ , [...] ] } from &quot;module-name&quot;;
import defaultMember, * as name from &quot;module-name&quot;;
import &quot;module-name&quot;;
</code></pre>
<ul>
<li>name－从将要导入模块中收到的导出值的名称</li>
<li>member, memberN－从导出模块，导入指定名称的多个成员</li>
<li>defaultMember－从导出模块，导入默认导出成员</li>
<li>alias, aliasN－别名，对指定导入成员进行的重命名</li>
<li>module-name－要导入的模块。是一个文件名</li>
<li>as－重命名导入成员名称（“标识符”）</li>
<li>from－从已经存在的模块、脚本文件等导入</li>
</ul>
<h5 id="命名式导入"><a class="header" href="#命名式导入">命名式导入</a></h5>
<p>我们可以通过指定名称，就是将这些成员插入到当作用域中。导出时，可以导入单个成员或多个成员：</p>
<p>注意：花括号里面的变量与 <code>export</code> 后面的变量一一对应</p>
<pre><code class="language-js">import { myMember } from &quot;my-module&quot;;
import { foo, bar } from &quot;my-module&quot;;
</code></pre>
<p>通过*符号，我们可以导入模块中的全部属性和方法。当导入模块全部导出内容时，就是将导出模块（<code>my-module.js</code>）所有的导出绑定内容，插入到当前模块（<code>myModule</code>）的作用域中：</p>
<pre><code class="language-js">import * as myModule from &quot;my-module&quot;;
</code></pre>
<p>导入模块对象时，也可以使用 as 对导入成员重命名，以方便在当前模块内使用：</p>
<pre><code>import {reallyReallyLongModuleMemberName as shortName} from &quot;my-module&quot;;
</code></pre>
<p>导入多个成员时，同样可以使用别名：</p>
<pre><code>import {reallyReallyLongModuleMemberName as shortName, anotherLongModuleName as short} from &quot;my-module&quot;;
</code></pre>
<p>导入一个模块，但不进行任何绑定：</p>
<pre><code>import &quot;my-module&quot;;
</code></pre>
<p>默认导入</p>
<p>在模块导出时，可能会存在默认导出。同样的，在导入时可以使用 import 指令导出这些默认值。</p>
<p>直接导入默认值：</p>
<pre><code>import myDefault from &quot;my-module&quot;;
</code></pre>
<p>也可以在命名空间导入和名称导入中，同时使用默认导入：</p>
<pre><code>import myDefault, * as myModule from &quot;my-module&quot;; // myModule 做为命名空间使用
</code></pre>
<p>或</p>
<pre><code>import myDefault, {foo, bar} from &quot;my-module&quot;; // 指定成员导入
</code></pre>
<p>import 使用示例</p>
<pre><code>// --file.js--
function getJSON(url, callback) {
  let xhr = new XMLHttpRequest();
  xhr.onload = function () {
    callback(this.responseText)
  };
  xhr.open(&quot;GET&quot;, url, true);
  xhr.send();
}
export function getUsefulContents(url, callback) {
  getJSON(url, data =&gt; callback(JSON.parse(data)));
}
// --main.js--
import { getUsefulContents } from &quot;file&quot;;
getUsefulContents(&quot;http://itbilu.com&quot;, data =&gt; {
  doSomethingUseful(data);
});
</code></pre>
<p>default 关键字</p>
<pre><code>// d.js
export default function() {}

// 等效于：
function a() {};
export {a as default};
</code></pre>
<p>在 import 的时候，可以这样用：</p>
<pre><code>import a from './d';

// 等效于，或者说就是下面这种写法的简写，是同一个意思
import {default as a} from './d';
</code></pre>
<p>这个语法糖的好处就是 import 的时候，可以省去花括号{}。</p>
<p>简单的说，如果 import 的时候，你发现某个变量没有花括号括起来（没有*号），那么你在脑海中应该把它还原成有花括号的 as 语法。</p>
<p>所以，下面这种写法你也应该理解了吧：</p>
<pre><code>import $,{each,map} from 'jquery';
</code></pre>
<p>import 后面第一个$是{defalut as $}的替代写法。</p>
<p>as 关键字</p>
<p>as 简单的说就是取一个别名,export 中可以用，import 中其实可以用：</p>
<pre><code>// a.js
var a = function() {};
export {a as fun};

// b.js
import {fun as a} from './a';
a();
</code></pre>
<p>上面这段代码，export 的时候，对外提供的接口是 fun，它是 a.js 内部 a 这个函数的别名，但是在模块外面，认不到 a，只能认到 fun。</p>
<p>import 中的 as 就很简单，就是你在使用模块里面的方法的时候，给这个方法取一个别名，好在当前的文件里面使用。之所以是这样，是因为有的时候不同的两个模块可能通过相同的接口，比如有一个 c.js
也通过了 fun 这个接口：</p>
<pre><code>// c.js
export function fun() {};
</code></pre>
<p>如果在 b.js 中同时使用 a 和 c 这两个模块，就必须想办法解决接口重名的问题，as 就解决了。</p>
<p>CommonJS 中 module.exports 与 exports 的区别</p>
<p>Module.exports</p>
<p>The module.exports object is created by the Module system. Sometimes this is not acceptable; many
want their module to be an instance of some class. To do this, assign the desired export object to
module.exports. Note that assigning the desired object to exports will simply rebind the local
exports variable, which is probably not what you want to do.</p>
<p>译文：module.exports 对象是由模块系统创建的。 有时这是难以接受的；许多人希望他们的模块成为某个类的实例。 为了实现这个，需要将期望导出的对象赋值给 module.exports。
注意，将期望的对象赋值给 exports 会简单地重新绑定到本地 exports 变量上，这可能不是你想要的。</p>
<p>Module.exports</p>
<p>The exports variable is available within a module's file-level scope, and is assigned the value of
module.exports before the module is evaluated. It allows a shortcut, so that module.exports.f = …
can be written more succinctly as exports.f = …. However, be aware that like any variable, if a new
value is assigned to exports, it is no longer bound to module.exports:</p>
<p>译文：exports 变量是在模块的文件级别作用域内有效的，它在模块被执行前被赋于 module.exports 的值。它有一个快捷方式，以便 module.exports.f =
…可以被更简洁地写成 exports.f = …。 注意，就像任何变量，如果一个新的值被赋值给 exports，它就不再绑定到 module.exports(其实是
exports.属性会自动挂载到没有命名冲突的 module.exports.属性)</p>
<p>从 Api 文档上面的可以看出，从 require 导入方式去理解，关键有两个变量(全局变量 module.exports，局部变量 exports)、一个返回值(module.exports)</p>
<pre><code>function require(...) {
var module = { exports: {} };
((module, exports) =&gt; {
// 你的被引入代码 Start
// var exports = module.exports = {}; (默认都有的)
function some_func() {};
exports = some_func;
// 此时，exports不再挂载到module.exports，
// export将导出{}默认对象
module.exports = some_func;
// 此时，这个模块将导出some_func对象，覆盖exports上的some_func
// 你的被引入代码 End
})(module, module.exports);
// 不管是exports还是module.exports，最后返回的还是module.exports
return module.exports;
}
</code></pre>
<p>demo.js:</p>
<pre><code>console.log(exports); // {}
console.log(module.exports); // {}
console.log(exports === module.exports); // true
console.log(exports == module.exports); // true
console.log(module);
/**
Module {
id: '.',
exports: {},
parent: null,
filename: '/Users/larben/Desktop/demo.js',
loaded: false,
children: [],
paths:
[ '/Users/larben/Desktop/node_modules',
'/Users/larben/node_modules',
'/Users/node_modules',
'/node_modules' ] }
*/
</code></pre>
<p>注意</p>
<p>每个 js 文件一创建，都有一个 var exports = module.exports = {} , 使 exports 和 module.exports 都指向一个空对象。</p>
<p>module.exports 和 exports 所指向的内存地址相同</p>
<p>总结</p>
<p>以上就是这篇文章的全部内容了，希望本文的内容对大家的学习或者工作能带来一定的帮助，如果有疑问大家可以留言交流，谢谢大家对脚本之家的支持。</p>
<p><a href="https://www.jb51.net/article/124442.htm" title="原文地址">原文地址</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="模块支持方案"><a class="header" href="#模块支持方案">模块支持方案</a></h1>
<p>webpack 支持 CommonJS（配置文件是 Node 环境下运行的），AMD，ES6 Module 规范。</p>
<h1 id="核心概念"><a class="header" href="#核心概念">核心概念</a></h1>
<p>从 entry 进入项目，经过 loader、plugin 打包，之后输出 output</p>
<h2 id="entryoutput"><a class="header" href="#entryoutput">entry、output</a></h2>
<p><code>entry</code>可以是单个字符串，也可以是一个字符串数组（多入口），一般写成对象格式。 <code>key</code>表示名字，<code>value</code>表示入口文件。
详细可以参考<a href="https://webpack.docschina.org/configuration/entry-context/#entry">官方文档</a>。</p>
<pre><code class="language-js">module.exports = {
  // entry: 'xxx',
  // entry: ['a', 'b'],
  entry: {
    app: &quot;./app.js&quot;,
    app2: &quot;./app2.js&quot;,
  },
};
</code></pre>
<p><code>output</code>就是输出的结果文件。<a href="https://webpack.docschina.org/configuration/output/">官方文档</a>。</p>
<pre><code class="language-js">const path = require(&quot;path&quot;);

module.exports = {
  entry: {
    app: &quot;./app.js&quot;,
  },
  output: {
    path: path.resolve(__dirname, &quot;dist&quot;),
    filename: &quot;[name].[hash:6].[id].[chunkhash].bundle.js&quot;, // name对应上面enrty的key
  },
};
</code></pre>
<h2 id="loader"><a class="header" href="#loader">loader</a></h2>
<p>是<code>webpack</code>的编译方法，<code>webpack</code>自身只能处理<code>JavaScript</code>，所以需要依赖<code>loader</code>来处理别的类型的资源文件。
<code>webpack</code>只能负责打包，相关的编译工作也需要依赖<code>loader</code>处理。 <code>loader</code>本质上只是一个方法，使用时基本需要额外安装。</p>
<p>使用时，在<code>rules</code>数组中使用，<code>loader</code>的执行顺序符合从右往左（从下到上、从数组的最后执行到第一个，<code>compose</code>）</p>
<pre><code class="language-js">module.exports = {
  module: {
    rules: [
      {
        test: /\.css$/, // 用正则匹配什么类型的文件
        use: [
          { loader: &quot;style-loader&quot; }, // 用什么loader处理
          {
            loader: &quot;css-loader&quot;,
            options: {
              // loader的配置项
              modules: true,
            },
          },
          { loader: &quot;sass-loader&quot; },
        ],
      },
    ],
  },
};
</code></pre>
<h3 id="常见的-loader"><a class="header" href="#常见的-loader">常见的 loader</a></h3>
<ul>
<li><code>css-loader</code>，<code>style-loader</code>等处理<code>css</code>的<code>loader</code></li>
<li><code>url-loader</code>，<code>image-loader</code>等图片文字文件等资源处理的<code>loader</code></li>
<li><code>less-loader</code>，<code>sass-loader</code>，<code>babel-loader</code>等编译<code>loader</code></li>
<li><code>vue-loader</code>等语法糖<code>loader</code></li>
</ul>
<h2 id="plugin"><a class="header" href="#plugin">plugin</a></h2>
<p><code>plugin</code>是<code>webpack</code>的额外扩展：</p>
<ul>
<li>一些插件式的额外功能由<code>plugin</code>定义，帮助<code>webpack</code>优化代码，提供功能。</li>
<li><code>plugin</code>也有一些是<code>webpack</code>自带的，也有需要额外安装的。</li>
</ul>
<pre><code class="language-js">const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);
const webpack = require(&quot;webpack&quot;); // 访问内置的插件
const path = require(&quot;path&quot;);

module.exports = {
  entry: &quot;./path/to/my/entry/file.js&quot;,
  output: {
    filename: &quot;my-first-webpack.bundle.js&quot;,
    path: path.resolve(__dirname, &quot;dist&quot;),
  },
  module: {
    rules: [
      {
        test: /\.(js|jsx)$/,
        use: &quot;babel-loader&quot;,
      },
    ],
  },
  plugins: [
    new webpack.ProgressPlugin(),
    new HtmlWebpackPlugin({ template: &quot;./src/index.html&quot; }),
  ],
};
</code></pre>
<h3 id="常见的-plugin"><a class="header" href="#常见的-plugin">常见的 plugin</a></h3>
<p><code>commonsChunkPlugin</code>，<code>uglifyjsWebpackPlugin</code>，<code>PurifyCss</code>等优化文件体积的插件
<code>HtmlWebpackPlugin</code>，<code>HotModuleReplacementPlugin</code>等</p>
<h2 id="编译-es6"><a class="header" href="#编译-es6">编译 ES6</a></h2>
<p>需要安装的 <code>loader</code></p>
<pre><code class="language-js">npm install babel-loader @babel/core --save-dev
</code></pre>
<h3 id="babel-preset"><a class="header" href="#babel-preset">Babel-preset</a></h3>
<p><code>presets</code> 是存储 <code>JavaScript</code> 不同标准的插件，通过正确使用 <code>presets</code>，来告诉 <code>babel</code> 按照哪个规范编译。 常见规范：</p>
<ul>
<li>es2015</li>
<li>es2016</li>
<li>es2017</li>
<li>env（通常采用，包括上面的三个和浏览器规范）</li>
<li>babel-preset-stage</li>
</ul>
<pre><code class="language-js">npm install @babel/preset-env --save-dev
</code></pre>
<h3 id="编译-es6-的方法"><a class="header" href="#编译-es6-的方法">编译 ES6 的方法</a></h3>
<p><code>babel-polyfill</code> 在打包代码里注入一个全局对象里，对象里定义了 <code>ES6</code> 所有的方法的 <code>ES5</code> 实现。适用于项目开发。
可以在入口文件中直接<code>import 'babel-polifill'</code> 也可以在 <code>entry</code> 中新增 <code>babel-polyfill</code></p>
<p><code>babel-plugin-transform-runtime</code> 生成一个局部对象，只会生成使用过的方法的实现。一般适用于框架开发。严格控制大小。</p>
<pre><code class="language-js">npm install babel-polyfill --save-dev
npm install @babel/plugin-transform-runtime @babel/runtime --save
</code></pre>
<p>webpack 配置</p>
<pre><code class="language-js">module.exports = {
  entry: {
    app: &quot;./app.js&quot;,
  },
  output: {
    filename: &quot;[name].[hash:8].js&quot;,
  },
  module: {
    rules: [
      {
        test: /\.js$/,
        use: {
          loader: &quot;babel-loader&quot;,
          options: {
            presets: [
              [
                &quot;@babel/preset-env&quot;,
                {
                  targets: {
                    browsers: [&quot;&gt;1%&quot;],
                  },
                },
              ],
            ],
          },
        },
      },
    ],
  },
};
</code></pre>
<h2 id="编译-typescript"><a class="header" href="#编译-typescript">编译 Typescript</a></h2>
<ul>
<li>安装 Typescript 和 ts-loader</li>
<li>写入 webpack.config.js</li>
<li>配置 tsconfig.json</li>
</ul>
<h2 id="编译-css"><a class="header" href="#编译-css">编译 css</a></h2>
<ul>
<li><code>css-loader</code>，让 <code>css</code> 可以被 <code>js</code> 正确的引入</li>
<li><code>style-loader</code>，让 <code>css</code> 被引入后可以正确的以一个 <code>style</code> 标签插入页面</li>
<li>必须先过 <code>css-loader</code>，再过 <code>style-loader</code></li>
</ul>
<h3 id="style-loader-的一些配置项"><a class="header" href="#style-loader-的一些配置项">style-loader 的一些配置项</a></h3>
<ul>
<li><code>insertAt</code> : <code>style</code> 标签插入在哪一块区域</li>
<li><code>insertInto</code> : 插入指定的 <code>dom</code></li>
<li><code>singleton</code> : 是否合并为一个 <code>style</code> 标签</li>
<li><code>transform</code> : 在浏览器环境下，插入 <code>style</code> 到页面前，用 <code>js</code> 对 <code>css</code> 进行操作</li>
</ul>
<h3 id="css-loader-的一些核心配置"><a class="header" href="#css-loader-的一些核心配置">css-loader 的一些核心配置</a></h3>
<ul>
<li><code>minimize</code>: 是否压缩（<code>webpack4</code> 以上不支持这个，推荐使用 <code>uglifyjsWebpackPlugin</code>)</li>
<li><code>module</code>: 是否进行 <code>css</code> 模块化</li>
<li><code>alias</code>: <code>css</code> 中的全局别名（<code>webpack4</code> 以上不支持这个）</li>
</ul>
<h3 id="lesssass"><a class="header" href="#lesssass">less，sass</a></h3>
<p>是 <code>css</code> 的预处理语言</p>
<p>less: less，less-loader sass： sass-loader， node-sass</p>
<pre><code class="language-js">{
  rules: [
      {
        test: /\.less$/,
        use: [{
          loader: &quot;style-loader&quot;,
          options: {
            // insertInto: &quot;xxx&quot;,
            singleton: true,
            transform: &quot;./transform.js&quot;
          }
        },
        {
          loader: &quot;css-loader&quot;,
          options: {
            modules: {
              localIdentName: &quot;[path][name]_[local]_[hash:4]&quot;
            }
          }
        },
        {
          loader: &quot;less-loader&quot;
        }]
      },
    ],
}
</code></pre>
<h3 id="提取-css-代码"><a class="header" href="#提取-css-代码">提取 css 代码</a></h3>
<p><code>extract-text-webpack-plugin</code>把 <code>css</code> 提取为单独的文件</p>
<pre><code class="language-js">{
  rules: [
      {
        test: /\.less$/,
        use: extractTextCss.extract({
          fallback: {
            loader: &quot;style-loader&quot;,
            options: {
              // insertInto: &quot;xxx&quot;,
              singleton: true,
              transform: &quot;./transform.js&quot;
            }
          },
          use: [
            {
              loader: &quot;css-loader&quot;,
              options: {
                modules: {
                  localIdentName: &quot;[path][name]_[local]_[hash:4]&quot;
                }
              }
            },
            {
              loader: &quot;less-loader&quot;
            }
          ]
        })
      },
    ],

    //  ...
    plugins: [
      new extractTextCss({filename: '[name].min.css'})
    ]
}
</code></pre>
<h3 id="css-兼容性处理"><a class="header" href="#css-兼容性处理">css 兼容性处理</a></h3>
<p><code>post-css</code>，再配合 <code>browserlist</code></p>
<h2 id="html-的处理和打包"><a class="header" href="#html-的处理和打包">HTML 的处理和打包</a></h2>
<p><code>html-webpack-plugin</code></p>
<ul>
<li><code>filename</code> 指定打包生成的 <code>html</code> 的名字</li>
<li><code>template</code> 指定一个 <code>html</code> 文件为模板</li>
<li><code>minify</code> 压缩 <code>html</code></li>
<li><code>inject</code> 是否把 <code>js</code>，<code>css</code> 文件插入到 <code>html</code>，插入到哪里</li>
<li><code>chunks</code> 多入口时，指定引入 <code>chunks</code></li>
</ul>
<pre><code class="language-js">new htmlWebpackPlugin({
  filename: &quot;index.html&quot;,
  template: &quot;./index.html&quot;,
});
</code></pre>
<h2 id="环境变量"><a class="header" href="#环境变量">环境变量</a></h2>
<p><code>env</code> 参数可以根据不同的指定，产生不同的配置文件，用来适应生产、测试、开发环境的不同需求</p>
<h2 id="图片处理"><a class="header" href="#图片处理">图片处理</a></h2>
<p><code>url-loader</code>，<code>file-loader</code>，<code>img-loader</code></p>
<pre><code class="language-js">{
  test: /\.(png|jpg|jpeg|gif)$/,
  use: {
    loader: 'file-loader',
    options: {
      name:'[name].[hash].[ext]',
      outputPath: '',
      publicPath: ''
    }
  }
}
</code></pre>
<p><code>url-loader</code> 可以多一些参数配置</p>
<pre><code class="language-js">{
  test: /\.(png|jpg|jpeg|gif)$/,
  use: {
    loader: 'url-loader',
    options: {
      name:'[name].[hash].[ext]',
      outputPath: '',
      publicPath: '',
      limit: 5000 //可以将小的资源文件进行base64转码
    }
  }
}
</code></pre>
<p><code>img-loader</code> 可以进行图片压缩</p>
<pre><code class="language-js">{
  test: /\.(png|jpg|jpeg|gif)$/,
  use: [{
    loader: 'url-loader',
    options: {
      name:'[name].[hash].[ext]',
      outputPath: '',
      publicPath: '',
      limit: 5000 //可以将小的资源文件进行base64转码
    }
  }, {
    loader: 'img-loader',
    options: {
      plugins: [
        require('imagemin-pngquant')({
          speed: 5 // 1-11，越大，压缩率越小
        }),
        require('imagemin-mozjpeg')({
          quality: 80 // 1-100，质量，压缩率
        }),
        require('imagemin-gifsicle')({
          optimizationLevel: 1, // 1-3
        }),
      ]
    }
  }]
}
</code></pre>
<h2 id="代码分割"><a class="header" href="#代码分割">代码分割</a></h2>
<p>多入口要配置多个 <code>HTMLWebpackPlugin</code>，<code>filename</code> 和 <code>chunks</code> 也要指定好
多页面应用时需要提取公共依赖，打包成一个文件。（主业务代码+公共依赖+第三方包+<code>webpack</code> 运行代码）
单页面应用主要是把<code>需要异步加载</code>改成<code>异步加载</code>，把业务代码和第三方代码拆分，保持纯净。（主业务代码+异步模块+第三方包+<code>webpack</code> 运行代码）</p>
<ul>
<li>webpack3， commonChunksPlugin</li>
<li>webpack4， SplitChunksPlugin</li>
</ul>
<pre><code class="language-js">{
  optimization: {
    splitChunks: {
      // initial, all ,async
      chunks: &quot;initial&quot;,
      minSize: 0,
      // 自定义提取
      cacheGroups: {
        vendor: {
          test: /([\\/]node_modules[\\/])/,
          name: 'vendor',
          chunks: 'all'
        }
      }
    },
    // webpack运行时代码
    runtimeChunk: true,
  }
}
</code></pre>
<p>异步模块加载，命名</p>
<pre><code class="language-js">import(/* webpackChunkName:&quot;mA&quot; */ &quot;./moduleA.js&quot;);

require.ensure([], function () {
  require(&quot;./moduleA.js&quot;);
});
</code></pre>
<p>清除之前的 <code>dist</code>， <code>clean-webpack-plugin</code></p>
<pre><code class="language-js">{
  new CleanWebpackPlugin(),
}
</code></pre>
<h2 id="体积优化"><a class="header" href="#体积优化">体积优化</a></h2>
<ul>
<li>webpack3 optimize.UglifyJsPlugin()</li>
<li>webpack4 optimization.minimize</li>
</ul>
<h2 id="打包加速"><a class="header" href="#打包加速">打包加速</a></h2>
<p>项目本身</p>
<ul>
<li>减少依赖嵌套深度</li>
<li>使用尽可能少的处理</li>
</ul>
<p>webpack 层面</p>
<ul>
<li>dll 处理</li>
<li>通过 include 减少 loader 范围</li>
<li>HappyPack</li>
<li>Uglify 优化</li>
<li>减少 resolve，sourcemap，cache-loader，用新版本的 node 和 webpack</li>
</ul>
<pre><code class="language-js">// webpack.config.js
{
  new webpack.DllReferencePlugin({
    manifest.require('./src/dll/jquery.json')
  })
}

// webpack.dll.js
const webpack = require(&quot;webpack&quot;);
module.exports = {
  entry: {
    jquery: [&quot;jquery&quot;],
    loadsh: [&quot;loadsh&quot;],
  },
  output: {
    path: dirname + &quot;/src/dll&quot;,
    filename: &quot;./[name].js&quot;,
    //引用名
    library: &quot;[name]&quot;,
  },
  plugins: [
    new webpack.DllPlugin({
      path: __dirname + &quot;/src/dll/[name].json&quot;,
      name: &quot;[name]&quot;,
    }),
  ],
};
</code></pre>
<p>先运行 <code>webpack --config webpack.dll.js</code>，生成对应文件，之后就可以加速了。</p>
<h2 id="长缓存优化"><a class="header" href="#长缓存优化">长缓存优化</a></h2>
<ul>
<li><code>hash</code> -&gt; <code>chunkhash</code></li>
<li><code>NamedChunksPlugin</code> 和 <code>NamedModulesPlugin</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="webpack-dev-server"><a class="header" href="#webpack-dev-server">webpack-dev-server</a></h1>
<p>可以模拟线上环境进行项目调试的工具</p>
<p>主要常用的功能</p>
<ul>
<li>路径重定向</li>
<li>浏览器中显示编译错误</li>
<li>接口代理</li>
<li>热更新</li>
</ul>
<p>常用配置：</p>
<ul>
<li><code>inline</code>: 服务的开启模式</li>
<li><code>lazy</code>: 懒编译</li>
<li><code>prot</code>: 代理端口</li>
<li><code>overlay</code>: 错误遮罩</li>
<li><code>historyApiFallback</code>: 路径重定向</li>
<li><code>proxy</code>: 代理请求(主要用来解决跨域问题)</li>
<li><code>hot</code>: 热更新(<code>hot</code>，<code>hotOnly</code>)(会和 <code>extract-text-webpack-plugin</code> 产生冲突)</li>
</ul>
<pre><code class="language-js">{
  devServer: {
    proxy: {
      '/': {
        target: 'xxxx',
        changeOrigin: true,
        pathRewrite: {
          '^/comments': '/api/comments',
        },
        headers:  {

        }
      }
    }
  }
}
</code></pre>
<h2 id="source-map"><a class="header" href="#source-map">source-map</a></h2>
<p>可以将代码对应到源文件的位置</p>
<p>模式：</p>
<ul>
<li>eval</li>
<li>eval-source-map</li>
<li>cheap-eval-source-map</li>
<li>cheap-module-source-map</li>
<li>source-map</li>
<li>hidden-source-map</li>
<li>nosource-source-map</li>
</ul>
<p><img src="JavaScript/./images/source-map.png" alt="source-map" /></p>
<pre><code class="language-js">{
  devtool: &quot;eval-source-map&quot;;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="居中布局"><a class="header" href="#居中布局">居中布局</a></h1>
<h2 id="水平居中"><a class="header" href="#水平居中">水平居中</a></h2>
<h3 id="inline-block--text-align"><a class="header" href="#inline-block--text-align">inline-block + text-align</a></h3>
<pre><code class="language-css">.parent {
  text-align: center;
}

.children {
  display: inline-block;
}
</code></pre>
<p><code>text-align</code>会对<code>inline</code>级别的元素生效</p>
<h3 id="table--margin"><a class="header" href="#table--margin">table + margin</a></h3>
<pre><code class="language-css">.children {
  display: table;
  margin: 0 auto;
}
</code></pre>
<p>子元素 display: table， table 在没有设置宽度的时候，跟里面的内容的宽度是一样的。</p>
<p>table 还可以使用 margin: auto，因此可以实现水平居中。</p>
<h3 id="absolute--transform"><a class="header" href="#absolute--transform">absolute + transform</a></h3>
<pre><code class="language-css">.parent {
  position: relative;
}

.children {
  position: absolute;
  left: 50%;
  transform: translateX(-50%);
}
</code></pre>
<h3 id="flex--justify--content"><a class="header" href="#flex--justify--content">flex + justify + content</a></h3>
<pre><code class="language-css">.parent {
  display: flex;
  justify-content: center;
}
</code></pre>
<p>flex-item 的默认样式是 1</p>
<p>或</p>
<pre><code class="language-css">.parent {
  display: flex;
}

.children {
  margin: 0 auto;
}
</code></pre>
<h2 id="垂直居中"><a class="header" href="#垂直居中">垂直居中</a></h2>
<h3 id="tabel-cell--vertical-align"><a class="header" href="#tabel-cell--vertical-align">tabel-cell + vertical-align</a></h3>
<pre><code class="language-css">.parent {
  display: table-cell;
  vertical-align: middle;
}
</code></pre>
<p>tabel-cell 会把子元素放在垂直中间，</p>
<p>vertical-align: middle 再把内容居中</p>
<h3 id="absolute--transform-1"><a class="header" href="#absolute--transform-1">absolute + transform</a></h3>
<pre><code class="language-css">.parent {
  position: relative;
}

.children {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
}
</code></pre>
<h3 id="flex--align-items"><a class="header" href="#flex--align-items">flex + align-items</a></h3>
<pre><code class="language-css">.parent {
  display: flex;
  align-items: center;
}
</code></pre>
<h2 id="居中"><a class="header" href="#居中">居中</a></h2>
<h3 id="inline-block--text-align--tabel-cell--vertical-align"><a class="header" href="#inline-block--text-align--tabel-cell--vertical-align">inline-block + text-align + tabel-cell + vertical-align</a></h3>
<pre><code class="language-css">.parent {
  text-align: center;
  display: table-cell;
  vertical-align: middle;
}

.children {
  display: inline-block;
}
</code></pre>
<h3 id="absolute--transform-2"><a class="header" href="#absolute--transform-2">absolute + transform</a></h3>
<pre><code class="language-css">.parent {
  position: relative;
}

.children {
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
}
</code></pre>
<h3 id="flex--justify-content--align-items"><a class="header" href="#flex--justify-content--align-items">flex + justify-content + align-items</a></h3>
<pre><code class="language-css">.parent {
  display: flex;
  justify-content: center;
  align-items: center;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="高度崩塌和垂直外边距重叠的问题"><a class="header" href="#高度崩塌和垂直外边距重叠的问题">高度崩塌和垂直外边距重叠的问题</a></h1>
<h2 id="高度崩塌"><a class="header" href="#高度崩塌">高度崩塌</a></h2>
<p>高度崩塌是由于子元素浮动或定位导致脱离文档流之后不能撑开父元素导致的。</p>
<h3 id="解决方案"><a class="header" href="#解决方案">解决方案</a></h3>
<h4 id="1开启父元素-bfc"><a class="header" href="#1开启父元素-bfc">1、开启父元素 BFC</a></h4>
<p>BFC Block Formatting Context 块级格式化环境</p>
<p>默认关闭的，是一个隐含属性</p>
<p>可以通过一些特殊的样式来 开启 BFC</p>
<h5 id="开启-bfc-之后的元素具备以下特性"><a class="header" href="#开启-bfc-之后的元素具备以下特性">开启 BFC 之后的元素具备以下特性</a></h5>
<ul>
<li>父元素的垂直外边距不会与子元素重叠</li>
<li>开启 BFC 的元素不会被浮动元素所覆盖</li>
<li>开启 BFC 的元素可以包含浮动子元素</li>
</ul>
<h5 id="开启-bfc-的方式"><a class="header" href="#开启-bfc-的方式">开启 BFC 的方式</a></h5>
<ul>
<li>设置元素浮动</li>
<li>设置元素绝对定位</li>
<li>设置元素类型为 inline-block</li>
<li><strong>设置 overflow 为一个非默认值，一般为 overflow：hidden 开启。</strong></li>
</ul>
<h4 id="2清除浮动"><a class="header" href="#2清除浮动">2、清除浮动</a></h4>
<p>在塌陷的父元素的最后添加一个空白的 div，然后对该 div 进行清除浮动</p>
<pre><code class="language-html">&lt;div id=&quot;box1&quot;&gt;
  &lt;div id=&quot;box2&quot;&gt;&lt;/div&gt;
  &lt;div style=&quot;clear:both&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<blockquote>
<p>问题：页面中添加了多余的结构</p>
</blockquote>
<h5 id="关于清除浮动"><a class="header" href="#关于清除浮动">关于清除浮动</a></h5>
<p>清除其他浮动元素对当前元素的影响</p>
<p>可选值：</p>
<ul>
<li>none，默认值，不清除浮动</li>
<li>left，清除左浮动对当前元素的影响</li>
<li>right 和 both 类推。</li>
</ul>
<h4 id="3清除浮动的进阶版本"><a class="header" href="#3清除浮动的进阶版本">3、清除浮动的进阶版本</a></h4>
<p>使用伪元素来避免 dom 结构混乱</p>
<pre><code class="language-css">.clearfix:after {
  content: &quot;&quot;;
  display: block;
  clear: both;
}
</code></pre>
<h2 id="垂直外边距重叠的问题"><a class="header" href="#垂直外边距重叠的问题">垂直外边距重叠的问题</a></h2>
<p>子元素的垂直外边距会传递给父元素，导致全部撑开。</p>
<h3 id="解决方案-1"><a class="header" href="#解决方案-1">解决方案</a></h3>
<p>在子元素前面放一个空的 table 标签，table 会隔离这个传递。</p>
<p>也可以使用伪元素 before 来处理</p>
<pre><code class="language-css">.clearfix::before{
    content: &quot;&quot;,
    display: table;
    clear: both
}
</code></pre>
<h2 id="合并解决方案"><a class="header" href="#合并解决方案">合并解决方案</a></h2>
<pre><code class="language-css">.clearfix::after,
.clearfix::before{
    content: &quot;&quot;,
    display: table;
    clear: both
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="虚拟-dom"><a class="header" href="#虚拟-dom">虚拟 DOM</a></h1>
<h2 id="虚拟-dom-是什么"><a class="header" href="#虚拟-dom-是什么">虚拟 DOM 是什么</a></h2>
<p><a href="https://www.runoob.com/htmldom/htmldom-tutorial.html">首先了解一下 DOM 是什么</a>:</p>
<blockquote>
<p>DOM (Document Object Model) 译为文档对象模型，是 HTML 和 XML 文档的编程接口。<br />
HTML DOM 定义了访问和操作 HTML 文档的标准方法。<br />
DOM 以树结构表达 HTML 文档。</p>
</blockquote>
<p>然后我们来做一个小实验：</p>
<pre><code class="language-js">const div = document.createElement(&quot;div&quot;);
let str = &quot;&quot;;
for (let i in div) {
  str += `${i} `;
}
const attrs = str.split(&quot; &quot;);
console.log(attrs.splice(0, 5), attrs.length);
</code></pre>
<p>out</p>
<pre><code class="language-js">(5) [&quot;align&quot;, &quot;title&quot;, &quot;lang&quot;, &quot;translate&quot;, &quot;dir&quot;] 294
</code></pre>
<p>我们可以看到浏览器对 <code>DOM</code> 赋予了很多属性来实现页面的各种功能，整个 <code>DOM</code> 的设计是相当复杂的。</p>
<p>当我们使用 <code>document.body.appendChild(node)</code> 往 <code>body</code> 节点上添加一个元素，调用该 <code>API</code> 之后会引发一系列的连锁反应。<br />
首先渲染引擎会将 <code>node</code> 节点添加到 <code>body</code> 节点之上，然后触发样式计算、布局、绘制、栅格化、合成等任务，我们把这一过程称为重排。<br />
除了重排之外，还有可能引起重绘或者合成操作，形象地理解就是“牵一发而动全身”。<br />
另外，对于 <code>DOM</code> 的不当操作还有可能引发强制同步布局和布局抖动的问题，这些操作都会大大降低渲染效率。<br />
因此，对于 <code>DOM</code> 的操作我们时刻都需要非常小心谨慎。</p>
<p>当然，对于简单的页面来说，其 <code>DOM</code> 结构还是比较简单的，所以以上这些操作 <code>DOM</code> 的问题并不会对用户体验产生太多影响。<br />
但是对于一些复杂的页面或者目前使用非常多的单页应用来说，其 <code>DOM</code> 结构是非常复杂的，而且还需要不断地去修改 <code>DOM</code> 树，每次操作 <code>DOM</code> 渲染
引擎都需要进行重排、重绘或者合成等操作，因为 <code>DOM</code> 结构复杂，所生成的页面结构也会很复杂，对于这些复杂的页面，执行一次重排或者重绘操作 都是非常耗时的，这就给我们带来了真正的性能问题。</p>
<p>所以我们需要有一种方式来减少 JavaScript 对 <code>DOM</code> 的操作，这时候虚拟 <code>DOM</code> 就上场了。</p>
<p>简而言之，我们需要用一种方式去描述浏览器的 <code>DOM</code> 结构，并且在数据更新的过程中通过虚拟 <code>DOM</code> 的对比来做一层“缓冲”。避免频繁的直接操作 <code>DOM</code> 对象。</p>
<h2 id="什么是虚拟dom"><a class="header" href="#什么是虚拟dom">什么是虚拟<code>DOM</code></a></h2>
<p>在谈论什么是虚拟 <code>DOM</code> 之前，我们先来看看虚拟 <code>DOM</code> 到底要解决哪些事情。</p>
<ul>
<li>将页面改变的内容应用到虚拟 <code>DOM</code> 上，而不是直接应用到 <code>DOM</code> 上。</li>
<li>变化被应用到虚拟 <code>DOM</code> 上时，虚拟 <code>DOM</code> 并不急着去渲染页面，而仅仅是调整虚拟 <code>DOM</code> 的内部状态，这样操作虚拟 <code>DOM</code> 的代价就变得非常轻了。</li>
<li>在虚拟 <code>DOM</code> 收集到足够的改变时，再把这些变化一次性应用到真实的 <code>DOM</code> 上。</li>
</ul>
<p>基于以上三点，我们再来看看什么是虚拟 DOM。为了直观理解，你可以参考下图：</p>
<p><img src="React/./images/%E8%99%9A%E6%8B%9Fdom%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="虚拟dom示意图.png" /></p>
<p>该图结合 React 流程画的一张虚拟 <code>DOM</code> 执行流程图，下面我们就结合这张图来分析下虚拟 <code>DOM</code> 到底怎么运行的。</p>
<p>创建阶段。首先依据 JSX 和基础数据创建出来虚拟 DOM，它反映了真实的 <code>DOM</code> 树的结构。然后由虚拟 <code>DOM</code> 树创建出真实 <code>DOM</code> 树，真实的 <code>DOM</code> 树生成完后，
再触发渲染流水线往屏幕输出页面。</p>
<p>更新阶段。如果数据发生了改变，那么就需要根据新的数据创建一个新的虚拟 <code>DOM</code> 树；然后 React 比较两个树，找出变化的地方，并把变化的地方一次性更新到真实的 <code>DOM</code> 树上</p>
<p>最后渲染引擎更新渲染流水线，并生成新的页面。</p>
<p>通过上面的描述，我们知道，当我们使用一个 JS 对象来描述浏览器的 <code>DOM</code> 结构的时候，这个对象就叫做虚拟 <code>DOM</code>。（浏览器的 <code>DOM</code> 对象过于复杂）</p>
<p>下面这段话是我摘录的一段对于虚拟 <code>DOM</code>的描述。</p>
<blockquote>
<ol>
<li><code>Virtual DOM</code> 是一种编程概念。在这个概念里， <code>UI</code> 以一种理想化的，或者说“虚拟的”表现形式被保存于内存中，并通过如 <code>ReactDOM</code> 等类库使之与“真实的”
<code>DOM</code> 同步。这一过程叫做协调。</li>
<li>这种方式赋予了 <code>React</code> 声明式的 <code>API</code>：你告诉 <code>React</code> 希望让 <code>UI</code> 是什么状态，<code>React</code> 就确保 <code>DOM</code> 匹配该状态。这使您可以从属性操作、
事件处理和手动 <code>DOM</code> 更新这些在构建应用程序时必要的操作中解放出来。</li>
<li>与其将 <code>Virtual DOM</code> 视为一种技术，不如说它是一种模式，人们提到它时经常是要表达不同的东西。在 <code>React</code> 的世界里，术语 <code>Virtual DOM</code> 通常 与
<code>React</code> 元素关联在一起，因为它们都是代表了用户界面的对象。</li>
<li>而 <code>React</code> 也使用一个名为 <code>fibers</code> 的内部对象来存放组件树的附加信息。上述二者也被认为是 <code>React</code> 中 <code>Virtual DOM</code> 实现的一部分。</li>
</ol>
</blockquote>
<p>我们来总结一下上面的话中比较重要的两点：</p>
<ol>
<li>虚拟 <code>DOM</code> 和真实 <code>DOM</code> 的交互不由虚拟 <code>DOM</code> 直接完成，交由第三方库完成，虚拟 <code>DOM</code> 只描述 <code>UI</code>，<code>UI</code> 到具体的展现，由 <code>ReactDOM</code>
等类库实现真正的渲染。 因此，<code>ReactNative</code>，小程序等跨端开发才得以实现。</li>
<li><code>React</code> 之类的类库，替你摆脱了频繁书写 <code>DOM</code> 操作的指令的坑，你不必再去书写类似 <code>document.getElementById(xxx).appendChild(xxx)</code>
之类的代码。 他们来负责数据变动到视图变动的过程。</li>
</ol>
<p>在 <code>React</code> 或者 <code>Vue</code> 中，虚拟 <code>DOM</code> 的创建都是由模板或者 <code>JSX</code> 来完成的，但是这两者到虚拟 <code>DOM</code> 的转移都是工程化干的事情（<code>webpack</code> +
<code>loader</code>），因此我们也不需要去书写类似 <code>React.createElement(xxx)</code> 的代码，只需要书写 <code>JSX</code> 即可以通过工程化自动生成上面的代码。</p>
<p>因此虚拟 <code>DOM</code> 极大程度上帮我们减轻了开发的负担，易于维护，并且不依赖于某一特定的环境。</p>
<h2 id="vdom-的优点"><a class="header" href="#vdom-的优点">VDOM 的优点</a></h2>
<ul>
<li>
<p>抽象了原本的渲染过程，实现了跨平台的的能力，从而不局限于浏览器的 <code>DOM</code>，也可以是安卓和 <code>IOS</code> 的原生组件，也可以是小程序。</p>
</li>
<li>
<p>抽象了渲染过程之后，使得组件的抽象能力也得到了提升，并且可以适配 <code>DOM</code> 以外的渲染目标。</p>
</li>
<li>
<p><code>VDOM</code> 在牺牲了部分性能的前提下，增加了可维护性，这也是很多框架的通性。 实现了对 <code>DOM</code> 集中化操作，在数据改变的时候先对 <code>VDOM</code> 进行修改，再反映到真实的 DOM
中，用最小的代价来更新 <code>DOM</code> ，提升效率。</p>
</li>
<li>
<p>打开了函数式 <code>UI</code> 编程的大门</p>
</li>
<li>
<p>跨平台（ <code>ReactNative</code> ，<code>React VR</code> 等）</p>
</li>
<li>
<p>可以更好的实现 <code>SSR</code>，同构渲染等</p>
</li>
<li>
<p>组件的高度抽象化</p>
</li>
</ul>
<h2 id="vdom-的缺点"><a class="header" href="#vdom-的缺点">VDOM 的缺点</a></h2>
<ul>
<li>首次渲染大量 <code>DOM</code> 的时候，由于多了一层虚拟 <code>DOM</code> 的计算，所以会比 <code>innerHTML</code> 插入的慢。</li>
<li>需要在内存中维护一份 <code>VDOM</code></li>
<li>如果虚拟 <code>DOM</code> 有着大量的更改，使用虚拟 <code>DOM</code> 是很合适的，如果是单一的频繁的更新的话，虚拟 <code>DOM</code> 需要花时间去处理计算工作。<br />
因此如果你有一个 <code>DOM</code> 节点相对较少的页面，使用 <code>VDOM</code> 可能会变慢。<br />
但是对于大多数单页面应用，使用 <code>VDOM</code> 应该是更快的</li>
</ul>
<h2 id="react-中的-diff-算法"><a class="header" href="#react-中的-diff-算法">React 中的 diff 算法</a></h2>
<p><a href="https://blog.csdn.net/qq_36407875/article/details/84965311">React 的虚拟 DOM 与 diff 算法的理解</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/34363711">React 源码分析 - Diff 算法</a></p>
<h2 id="关于-react-中的虚拟-dom"><a class="header" href="#关于-react-中的虚拟-dom">关于 React 中的虚拟 DOM</a></h2>
<p><a href="https://zhuanlan.zhihu.com/p/50218605">React 中的虚拟 DOM</a></p>
<blockquote>
<p><code>Fiber</code> 架构之后的不同。可以自行搜索 <code>Fiber</code> 相关的内容。<br />
<code>Fiber</code> 之后，虚拟 <code>DOM</code> 从树形结构变为了可恢复的链表的结构。</p>
</blockquote>
<p><code>Fiber</code> 的出现主要是为了解决在大量 <code>dom diff</code> 的过程中，保证渲染流畅，（原来的 <code>stack reconciler</code> 会在 <code>diff</code>
过程中阻塞线程，导致页面卡顿，因为只有<code>diff</code> 完成之后才会渲染页面）<br />
其实协程的另外一个称呼就是 <code>Fiber</code>，所以在这里我们可以把 <code>Fiber</code> 和协程关联起来，那么所谓的 <code>Fiber reconciler</code> 相信你也很清楚了，就是在执行算法的过程中出让主线程</p>
<p>这样就解决了 <code>Stack reconciler</code> 函数占用时间过久的问题。<br />
实际上的思想类似于时间切片的概念。<br />
主要利用了浏览器 <code>requestIdleCallback</code> 这个 <code>API</code></p>
<h2 id="关于-vue-中的虚拟-dom"><a class="header" href="#关于-vue-中的虚拟-dom">关于 Vue 中的虚拟 DOM</a></h2>
<p>整体的实现思路大致类似上面的手动实现的方法。</p>
<p>以 <code>Vue2.x</code> 为例，可以在源码中找到<a href="https://github.com/vuejs/vue/blob/dev/src/core/vdom/patch.js">这个文件</a>来看一下。</p>
<p>在 <code>Vue3.x</code> 中并没有引进 <code>Fiber</code> 这一架构，具体原因可以在拓展阅读中查看。</p>
<h2 id="拓展阅读"><a class="header" href="#拓展阅读">拓展阅读</a></h2>
<ol>
<li><a href="https://blog.csdn.net/qq_29582173/article/details/103078900">如何实现一个简单的虚拟 dom</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/135214155">尤大 Vue3.0 直播虚拟 Dom 总结(和 React 对比)</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><p>手动实现一个简单的虚拟 <code>DOM</code> (类似 <code>Vue2.x</code> ， <code>React</code> 中的 <code>Fiber</code> 太过于复杂)</p>
<h1 id="创建"><a class="header" href="#创建">创建</a></h1>
<p>我们来尝试简单渲染一个 <code>DOM</code> 结构，</p>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
  &lt;p&gt;节点1&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<p>我们有一个最简陋的 <code>createElement</code> 函数来返回一个虚拟 <code>DOM</code></p>
<pre><code class="language-js">const vnodeType = {
  HTML: &quot;HTML&quot;,
  TEXT: &quot;TEXT&quot;,

  COMPONENT: &quot;COMPONENT&quot;,
  CLASS_COMPONENT: &quot;CLASS_COMPONENT&quot;,
};

const childType = {
  EMPTY: &quot;EMPTY&quot;,
  SINGLE: &quot;SINGLE&quot;,
  MULTIPLE: &quot;MULTIPLE&quot;,
};

// 新建虚拟DOM
// 名字，属性，子元素
function createElement(tag, data, children = null) {
  let flag;
  if (typeof tag === &quot;string&quot;) {
    // 普通html标签
    flag = vnodeType.HTML;
  } else if (typeof tag === &quot;function&quot;) {
    flag = vnodeType.COMPONENT;
  } else {
    flag = vnodeType.TEXT;
  }

  // 0， 1， n
  let childrenFlag;
  if (children == null) {
    childrenFlag = childType.EMPTY;
  } else if (Array.isArray(children)) {
    let length = children.length;
    if (length === 0) {
      childrenFlag = childType.EMPTY;
    } else {
      childrenFlag = childType.MULTIPLE;
    }
  } else {
    childrenFlag = childType.SINGLE;
    children = createTextVnode(children + &quot;&quot;);
  }

  // 返回vnode
  return {
    flag, //vnode类型
    tag, // 标签，div文本没有tag，组件就是函数
    data,
    children,
    childrenFlag,
  };
}

//渲染
function render() {}

// 创建文本类型 vnode
function createTextVnode(text) {
  return {
    flag: vnodeType.TEXT,
    tag: null,
    data: null,
    children: text,
    childrenFlag: childType.EMPTY,
  };
}
</code></pre>
<p>页面上</p>
<pre><code class="language-js">let div = createElement(&quot;div&quot;, { id: &quot;app&quot; }, [
  createElement(&quot;p&quot;, {}, &quot;节点1&quot;),
]);
console.log(JSON.stringify(div, null, 2));
</code></pre>
<p>out</p>
<pre><code class="language-json">{
  &quot;flag&quot;: &quot;HTML&quot;,
  &quot;tag&quot;: &quot;div&quot;,
  &quot;data&quot;: {
    &quot;id&quot;: &quot;app&quot;
  },
  &quot;children&quot;: [
    {
      &quot;flag&quot;: &quot;HTML&quot;,
      &quot;tag&quot;: &quot;p&quot;,
      &quot;data&quot;: {},
      &quot;children&quot;: {
        &quot;flag&quot;: &quot;TEXT&quot;,
        &quot;tag&quot;: null,
        &quot;data&quot;: null,
        &quot;children&quot;: &quot;节点1&quot;,
        &quot;childrenFlag&quot;: &quot;EMPTY&quot;
      },
      &quot;childrenFlag&quot;: &quot;SINGLE&quot;
    }
  ],
  &quot;childrenFlag&quot;: &quot;MULTIPLE&quot;
}
</code></pre>
<p>接下来我们将它渲染到页面上。</p>
<h1 id="渲染"><a class="header" href="#渲染">渲染</a></h1>
<p>我们搞多一些 <code>p</code> 元素在页面上，并且调用 <code>render</code> 函数来渲染。</p>
<pre><code class="language-html">&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
      .item-header {
        font-size: 30px;
        color: green;
      }
    &lt;/style&gt;
  &lt;/head&gt;

  &lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;
    &lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
      let vnode = createElement(&quot;div&quot;, { id: &quot;app&quot; }, [
        createElement(&quot;p&quot;, { key: &quot;a&quot;, style: { color: &quot;blue&quot; } }, &quot;节点1&quot;),
        createElement(&quot;p&quot;, { key: &quot;b&quot;, &quot;@click&quot;: () =&gt; alert(&quot;xxx&quot;) }, &quot;节点2&quot;),
        createElement(&quot;p&quot;, { key: &quot;c&quot;, class: &quot;item-header&quot; }, &quot;节点3&quot;),
        createElement(&quot;p&quot;, { key: &quot;d&quot; }, &quot;节点4&quot;),
      ]);
      render(vnode, document.getElementById(&quot;app&quot;));
      // console.log(JSON.stringify(div, null, 2))
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>还有一些额外的工作（简易版本），需要注意以下的一些问题。</p>
<ul>
<li>属性的处理。</li>
<li>首次渲染和 <code>diff</code></li>
<li><code>el</code> 属性</li>
<li>递归渲染子元素</li>
</ul>
<p>简易版的代码如下:</p>
<pre><code class="language-js">const vnodeType = {
  HTML: &quot;HTML&quot;,
  TEXT: &quot;TEXT&quot;,

  COMPONENT: &quot;COMPONENT&quot;,
  CLASS_COMPONENT: &quot;CLASS_COMPONENT&quot;,
};

const childType = {
  // 节点没有子元素或者是空数组
  EMPTY: &quot;EMPTY&quot;,
  // 节点是文本元素
  SINGLE: &quot;SINGLE&quot;,
  // 节点有1或多个子元素
  MULTIPLE: &quot;MULTIPLE&quot;,
};

// 新建虚拟DOM
// 名字，属性，子元素
function createElement(tag, data, children = null) {
  let flag;
  if (typeof tag === &quot;string&quot;) {
    // 普通html标签
    flag = vnodeType.HTML;
  } else if (typeof tag === &quot;function&quot;) {
    flag = vnodeType.COMPONENT;
  } else {
    flag = vnodeType.TEXT;
  }

  // 0， 1， n
  let childrenFlag;
  if (children == null) {
    childrenFlag = childType.EMPTY;
  } else if (Array.isArray(children)) {
    let length = children.length;
    if (length === 0) {
      childrenFlag = childType.EMPTY;
    } else {
      childrenFlag = childType.MULTIPLE;
    }
  } else {
    childrenFlag = childType.SINGLE;
    // 文本元素直接给textVnode节点
    children = createTextVnode(children + &quot;&quot;);
  }

  // 返回vnode
  return {
    flag, //vnode类型
    tag, // 标签，div文本没有tag，组件就是函数
    data,
    children,
    childrenFlag,
    el: null,
  };
}

//渲染
function render(vnode, container) {
  // 区分首次渲染和再次渲染
  // 首次渲染直接mount，再次渲染需要diff
  mount(vnode, container);
}

// 首次挂载元素
function mount(vnode, container) {
  let { flag } = vnode;
  // 区别对待HTML节点和Text节点
  if (flag === vnodeType.HTML) {
    mountElement(vnode, container);
  } else if (flag === vnodeType.TEXT) {
    mountText(vnode, container);
  }
}

function mountElement(vnode, container) {
  let dom = document.createElement(vnode.tag);
  // 存一下，以后都能拿到真实dom
  vnode.el = dom;
  let { data, children, childrenFlag } = vnode;

  // 挂载data属性
  if (data) {
    for (let key in data) {
      // 节点，名字，老值，新值
      patchData(dom, key, null, data[key]);
    }
  }

  // 根据子元素的不同类型来渲染子元素
  if (childrenFlag !== childType.EMPTY) {
    if (childrenFlag === childType.SINGLE) {
      mount(children, dom);
    } else if (childrenFlag == childType.MULTIPLE) {
      for (let i = 0; i &lt; children.length; i++) {
        mount(children[i], dom);
      }
    }
  }

  // 挂载
  container.appendChild(dom);
}
function mountText(vnode, container) {
  let dom = document.createTextNode(vnode.children);
  vnode.el = dom;

  // 挂载
  container.appendChild(dom);
}

function patchData(el, key, pre, next) {
  switch (key) {
    // 处理style属性
    case &quot;style&quot;:
      for (let k in next) {
        el.style[k] = next[k];
      }
      break;
    // 处理class属性
    case &quot;class&quot;:
      el.className = next;
      break;
    // 其他
    default:
      // 处理事件绑定函数，以vue的@为例
      if (key[0] === &quot;@&quot;) {
        if (next) {
          el.addEventListener(key.slice(1), next);
        }
      } else {
        el.setAttribute(key, next);
      }
      break;
  }
}

// 创建文本类型 vnode
function createTextVnode(text) {
  return {
    flag: vnodeType.TEXT,
    tag: null,
    data: null,
    children: text,
    childrenFlag: childType.EMPTY,
    el: null,
  };
}
</code></pre>
<p>至此，虚拟 <code>DOM</code> 已经首次渲染到页面上了。</p>
<p>然后我们再来看看如何简单实现 <code>DOM diff</code>。</p>
<h1 id="patch"><a class="header" href="#patch">patch</a></h1>
<p>假设我们要将</p>
<pre><code class="language-js">let vnode = createElement(&quot;div&quot;, { id: &quot;app&quot; }, [
  createElement(&quot;p&quot;, { key: &quot;a&quot;, style: { color: &quot;blue&quot; } }, &quot;节点1&quot;),
  createElement(&quot;p&quot;, { key: &quot;b&quot;, &quot;@click&quot;: () =&gt; alert(&quot;xxx&quot;) }, &quot;节点2&quot;),
  createElement(&quot;p&quot;, { key: &quot;c&quot;, class: &quot;item-header&quot; }, &quot;节点3&quot;),
  createElement(&quot;p&quot;, { key: &quot;d&quot; }, &quot;节点4&quot;),
]);
</code></pre>
<p>里渲染的 <code>DOM</code> ，变更为如下的 <code>DOM</code> 结构，然后在一秒后重新渲染：</p>
<pre><code class="language-js">let vnode1 = createElement(&quot;div&quot;, { id: &quot;app&quot; }, [
  createElement(&quot;p&quot;, { key: &quot;d&quot; }, &quot;节点4&quot;),
  createElement(&quot;p&quot;, { key: &quot;a&quot;, style: { color: &quot;blue&quot; } }, &quot;节点1&quot;),
  createElement(&quot;p&quot;, { key: &quot;b&quot; }, &quot;节点2&quot;),
  createElement(&quot;p&quot;, { key: &quot;e&quot; }, &quot;节点5&quot;),
  createElement(&quot;p&quot;, { key: &quot;f&quot;, style: { color: &quot;#eee&quot; } }, &quot;节点4&quot;),
]);

setTimeout(() =&gt; {
  render(vnode1, document.getElementById(&quot;app&quot;));
});
</code></pre>
<p>然后我们需要在 <code>render</code> 函数里区分首次渲染和再次渲染：</p>
<pre><code class="language-js">//渲染
function render(vnode, container) {
  // 区分首次渲染和再次渲染
  // 首次渲染直接mount，再次渲染需要diff
  if (container.vnode) {
    // 更新
    patch(container.vnode, vnode, container);
  } else {
    mount(vnode, container);
  }

  container.vnode = vnode;
}
</code></pre>
<p>然后我们看一下 <code>patch</code> 函数：</p>
<pre><code class="language-js">function patch(pre, next, container) {
  let nextFlag = next.flag;
  let preFlag = pre.flag;

  // 如果flag不同直接替换。
  if (nextFlag !== preFlag) {
    // 直接替换
    repaceVnode(pre, next, container);
  } else if (nextFlag == vnodeType.HTML) {
    patchElement(pre, next, container);
  } else if (nextFlag == vnodeType.TEXT) {
    // 文本节点只需要更新文字内容即可
    patchText(pre, next);
  }
}

// 替换节点，先移除再mount
function replaceVnode(pre, next) {
  container.removeChild(pre.el);
  mount(next, container);
}

// 文本节点直接替换文字即可
function patchText(pre, next) {
  let el = (next.el = pre.el);
  if (next.children !== pre.children) {
    el.nodeValue = next.children;
  }
}
</code></pre>
<p>以上两种最简单的对比都是比较好理解的。接下来来看一下 <code>flag</code> 不同的 <code>HTML</code> 节点的替换 <code>patchElement</code> 。</p>
<pre><code class="language-js">function patchElement(pre, next, container) {
  // 如果tag不同就直接替换掉
  if (pre.tag !== next.tag) {
    repaceVnode(pre, next, container);
    return;
  }

  // 更新一下 el， 然后更新data
  let el = (next.el = pre.el);
  let preData = pre.data;
  let nextData = next.data;
  // 如果有新值，则全部更新到el上
  if (nextData) {
    for (let key in nextData) {
      let preVal = preData[key];
      let nextVal = nextData[key];
      patchData(el, key, preVal, nextVal);
    }
  }
  // 对旧值进行处理，
  // 旧的有，新的没有，就要置为空
  // 旧的有，新的有的已经在上面一个循环里被覆盖掉了。
  if (preData) {
    for (let key in preData) {
      let preVal = preData[key];
      if (preVal &amp;&amp; !nextData.hasOwnProperty(key)) {
        patchData(el, key, preVal, null);
      }
    }
  }

  // data更新完毕 下面更新子元素
  patchChildren(
    pre.childrenFlag,
    next.childrenFlag,
    pre.children,
    next.children,
    el
  );
}

// 更新子元素的方法
function patchChildren(
  preChildFlag,
  nextChildFlag,
  preChildren,
  nextChildren,
  container
) {
  // 新老元素都有三种情况，用switch case做嵌套处理
  // 更新子元素
  // 老的是 1 ， 0， n
  // 新的是 1， 0 ， n
  switch (preChildFlag) {
    // 老的是一个
    case childType.SINGLE:
      switch (nextChildFlag) {
        // 新的也是一个，直接patch
        case childType.SINGLE:
          patch(preChildren, nextChildren, container);
          break;
        // 新的是空的，直接移除老的
        case childType.EMPTY:
          container.removeChild(preChildren.el);
          break;
        // 新的是多个的，先移除老的，再循环mount新的
        case childType.MULTIPLE:
          container.removeChild(preChildren.el);
          for (let i = 0; i &lt; nextChildren.length; i++) {
            mount(nextChildren[i], container);
          }
          break;
      }
      break;
    // 老的是空的
    case childType.EMPTY:
      switch (nextChildFlag) {
        // 新的是一个，直接mount
        case childType.SINGLE:
          mount(nextChildren, container);
          break;
        // 新的也是空的，不做处理
        case childType.EMPTY:
          break;
        // 新的是多个，直接循环mount新的
        case childType.MULTIPLE:
          for (let i = 0; i &lt; nextChildren.length; i++) {
            mount(nextChildren[i], container);
          }
          break;
      }
      break;
    // 老的是多个
    case childType.MULTIPLE:
      switch (nextChildFlag) {
        // 新的是一个，循环移除老的，再把新的mount上去
        case childType.SINGLE:
          for (let i = 0; i &lt; preChildren.length; i++) {
            container.removeChild(preChildren[i]);
          }
          mount(nextChildren, container);
          break;
        // 新的是空的，循环移除老的，接下来无操作
        case childType.EMPTY:
          for (let i = 0; i &lt; preChildren.length; i++) {
            container.removeChild(preChildren[i]);
          }
          break;
        // 新的是多个的情况，比较复杂，React和Vue的实现不同。这里简单实现一下。
        // 这个算法网上都有讲解，就不赘述了。
        default:
          let lastIndex = 0;
          for (let i = 0; i &lt; nextChildren.length; i++) {
            const nextVNode = nextChildren[i];
            let j = 0,
              find = false;
            for (j; j &lt; preChildren.length; j++) {
              const prevVNode = preChildren[j];
              if (nextVNode.key === prevVNode.key) {
                find = true;
                patch(prevVNode, nextVNode, container);
                if (j &lt; lastIndex) {
                  // 需要移动
                  const refNode = nextChildren[i - 1].el.nextSibling;
                  container.insertBefore(prevVNode.el, refNode);
                  break;
                } else {
                  // 更新 lastIndex
                  lastIndex = j;
                }
              }
            }
            if (!find) {
              // 挂载新节点
              const refNode =
                i - 1 &lt; 0
                  ? preChildren[0].el
                  : nextChildren[i - 1].el.nextSibling;

              mount(nextVNode, container, refNode);
            }
          }
          // 移除已经不存在的节点
          for (let i = 0; i &lt; preChildren.length; i++) {
            const prevVNode = preChildren[i];
            const has = nextChildren.find(
              (nextVNode) =&gt; nextVNode.key === prevVNode.key
            );
            if (!has) {
              // 移除
              container.removeChild(prevVNode.el);
            }
          }
          break;
      }
      break;
  }
}
</code></pre>
<p>至此，一次 <code>DOM</code> 更新就实现了。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="react-事件机制"><a class="header" href="#react-事件机制">React 事件机制</a></h1>
<h2 id="dom-事件"><a class="header" href="#dom-事件">DOM 事件</a></h2>
<p>冒泡和捕获</p>
<p><img src="React/./images/image-20210624173959717.png" alt="image-20210624173959717" /></p>
<p>先从父元素向下传递捕获，直到子元素处理掉，然后再逐个冒泡。</p>
<p>所以有了一个事件委托的机制。</p>
<h2 id="react-事件"><a class="header" href="#react-事件">React 事件</a></h2>
<p>React 会将所有事件都绑定在 document 上。</p>
<p>统一使用事件监听。都是在冒泡阶段处理。</p>
<p>所以一般在组件挂载的时候增加监听事件。</p>
<p>组件卸载的时候删除监听事件。</p>
<p>事件触发的时候，组件会生成一个合成事件。然后发送到 document 上。</p>
<p>document 会通过 dispatch event 回调函数依次执行 dispatch listener 中同类型事件的监听函数。</p>
<p>事件注册是在组件生成的时候，将 VDOM 中的所有的事件对应的原生事件都注册在 Document 中一个监听器中。所有的事件处理函数都存放在 listenerbank 中，并以 key
做为索引。（将可能要触发的事件分门别类）</p>
<ol>
<li>是合成事件，不是 DOM 原生事件</li>
<li>在 document 监听所有支持事件</li>
<li>使用统一的分发函数 dispatchEvent 来指定事件函数的执行</li>
</ol>
<p><a href="https://juejin.cn/post/6844903502729183239">拓展阅读 1</a></p>
<p><a href="http://zhenhua-lee.github.io/react/react-event.html">拓展阅读 2</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="react-合成事件"><a class="header" href="#react-合成事件">React 合成事件</a></h1>
<p><a href="https://zhuanlan.zhihu.com/p/25883536">原文</a></p>
<p><a href="https://react.html.cn/docs/events.html">其他参考</a></p>
<h2 id="1-react-合成事件特点"><a class="header" href="#1-react-合成事件特点">1 React 合成事件特点</a></h2>
<p>React 自己实现了一套高效的事件注册，存储，分发和重用逻辑，在 DOM 事件体系基础上做了很大改进，减少了内存消耗，简化了事件逻辑，并最大化的解决了 IE 等浏览器的不兼容问题。与 DOM
事件体系相比，它有如下特点</p>
<ol>
<li>React 组件上声明的事件最终绑定到了 document 这个 DOM 节点上，而不是 React 组件对应的 DOM 节点。故只有 document 这个节点上面才绑定了 DOM
原生事件，其他节点没有绑定事件。这样简化了 DOM 原生事件，减少了内存开销</li>
<li>React 以队列的方式，从触发事件的组件向父组件回溯，调用它们在 JSX 中声明的 callback。也就是 React 自身实现了一套事件冒泡机制。我们没办法用
event.stopPropagation()来停止事件传播，应该使用 event.preventDefault()</li>
<li>React 有一套自己的合成事件 SyntheticEvent，不同类型的事件会构造不同的 SyntheticEvent</li>
<li>React 使用对象池来管理合成事件对象的创建和销毁，这样减少了垃圾的生成和新对象内存的分配，大大提高了性能</li>
</ol>
<p>那么这些特性是如何实现的呢，下面和大家一起一探究竟。</p>
<h2 id="2-react-事件系统"><a class="header" href="#2-react-事件系统">2 React 事件系统</a></h2>
<p>先看 Facebook 给出的 React 事件系统框图</p>
<p>浏览器事件（如用户点击了某个 button）触发后，DOM 将 event 传给 ReactEventListener，它将事件分发到当前组件及以上的父组件。然后由 ReactEventEmitter
对每个组件进行事件的执行，先构造 React 合成事件，然后以 queue 的方式调用 JSX 中声明的 callback 进行事件回调。</p>
<p>涉及到的主要类如下</p>
<p>ReactEventListener：负责事件注册和事件分发。React 将 DOM 事件全都注册到 document 这个节点上，这个我们在事件注册小节详细讲。事件分发主要调用
dispatchEvent 进行，从事件触发组件开始，向父元素遍历。我们在事件执行小节详细讲。</p>
<p>ReactEventEmitter：负责每个组件上事件的执行。</p>
<p>EventPluginHub：负责事件的存储，合成事件以对象池的方式实现创建和销毁，大大提高了性能。</p>
<p>SimpleEventPlugin 等 plugin：根据不同的事件类型，构造不同的合成事件。如 focus 对应的 React 合成事件为 SyntheticFocusEvent</p>
<h2 id="2-事件注册"><a class="header" href="#2-事件注册">2 事件注册</a></h2>
<p>JSX 中声明一个 React 事件十分简单，比如</p>
<pre><code class="language-js">render() {
  return (
    &lt;div onClick = {
            (event) =&gt; {console.log(JSON.stringify(event))}
        }
    /&gt;
  );
}
</code></pre>
<p>那么它是如何被注册到 React 事件系统中的呢？</p>
<p>还是先得从组件创建和更新的入口方法 mountComponent 和 updateComponent 说起。在这两个方法中，都会调用到_updateDOMProperties 方法，对 JSX
中声明的组件属性进行处理。源码如下</p>
<pre><code class="language-js">_updateDOMProperties: function (lastProps, nextProps, transaction) {
    ... // 前面代码太长，省略一部分
    else if (registrationNameModules.hasOwnProperty(propKey)) {
        // 如果是props这个对象直接声明的属性，而不是从原型链中继承而来的，则处理它
        // nextProp表示要创建或者更新的属性，而lastProp则表示上一次的属性
        // 对于mountComponent，lastProp为null。updateComponent二者都不为null。unmountComponent则nextProp为null
        if (nextProp) {
          // mountComponent和updateComponent中，enqueuePutListener注册事件
          enqueuePutListener(this, propKey, nextProp, transaction);
        } else if (lastProp) {
          // unmountComponent中，删除注册的listener，防止内存泄漏
          deleteListener(this, propKey);
        }
    }
}
</code></pre>
<p>下面我们来看 enqueuePutListener，它负责注册 JSX 中声明的事件。源码如下</p>
<pre><code class="language-js">// inst: React Component对象
// registrationName: React合成事件名，如onClick
// listener: React事件回调方法，如onClick=callback中的callback
// transaction: mountComponent或updateComponent所处的事务流中，React都是基于事务流的
function enqueuePutListener(inst, registrationName, listener, transaction) {
  if (transaction instanceof ReactServerRenderingTransaction) {
    return;
  }
  var containerInfo = inst._hostContainerInfo;
  var isDocumentFragment =
    containerInfo._node &amp;&amp; containerInfo._node.nodeType === DOC_FRAGMENT_TYPE;
  // 找到document
  var doc = isDocumentFragment
    ? containerInfo._node
    : containerInfo._ownerDocument;
  // 注册事件，将事件注册到document上
  listenTo(registrationName, doc);
  // 存储事件,放入事务队列中
  transaction.getReactMountReady().enqueue(putListener, {
    inst: inst,
    registrationName: registrationName,
    listener: listener,
  });
}
</code></pre>
<p>enqueuePutListener 主要做两件事，一方面将事件注册到 document 这个原生 DOM 上（这就是为什么只有 document 这个节点有 DOM
事件的原因），另一方面采用事务队列的方式调用 putListener 将注册的事件存储起来，以供事件触发时回调。</p>
<p>注册事件的入口是 listenTo 方法, 它解决了不同浏览器间捕获和冒泡不兼容的问题。事件回调方法在 bubble 阶段被触发。如果我们想让它在 capture 阶段触发，则需要在事件名上加上
capture。比如 onClick 在 bubble 阶段触发，而 onCaptureClick 在 capture 阶段触发。listenTo 代码虽然比较长，但逻辑很简单，调用
trapCapturedEvent 和 trapBubbledEvent 来注册捕获和冒泡事件。trapCapturedEvent 大家可以自行分析，我们仅分析 trapBubbledEvent，如下</p>
<pre><code class="language-js">trapBubbledEvent: function (topLevelType, handlerBaseName, element) {
    if (!element) {
      return null;
    }
    return EventListener.listen(
      element,   // 绑定到的DOM目标,也就是document
      handlerBaseName,   // eventType
      ReactEventListener.dispatchEvent.bind(null, topLevelType));  // callback, document上的原生事件触发后回调
  },

  listen: function listen(target, eventType, callback) {
    if (target.addEventListener) {
      // 将原生事件添加到target这个dom上,也就是document上。
      // 这就是只有document这个DOM节点上有原生事件的原因
      target.addEventListener(eventType, callback, false);
      return {
        // 删除事件,这个由React自己回调,不需要调用者来销毁。但仅仅对于React合成事件才行
        remove: function remove() {
          target.removeEventListener(eventType, callback, false);
        }
      };
    } else if (target.attachEvent) {
      // attach和detach的方式
      target.attachEvent('on' + eventType, callback);
      return {
        remove: function remove() {
          target.detachEvent('on' + eventType, callback);
        }
      };
    }
  },
</code></pre>
<p>在 listen 方法中，我们终于发现了熟悉的 addEventListener 这个原生事件注册方法。只有 document 节点才会调用这个方法，故仅仅只有 document 节点上才有 DOM
事件。这大大简化了 DOM 事件逻辑，也节约了内存。</p>
<p>流程图如下</p>
<h2 id="3-事件存储"><a class="header" href="#3-事件存储">3 事件存储</a></h2>
<p>事件存储由 EventPluginHub 来负责，它的入口在我们上面讲到的 enqueuePutListener 中的 putListener 方法，如下</p>
<pre><code class="language-js">/**
   * EventPluginHub用来存储React事件, 将listener存储到`listenerBank[registrationName][key]`
   *
   * @param {object} inst: 事件源
   * @param {string} listener的名字,比如onClick
   * @param {function} listener的callback
   */
  //
  putListener: function (inst, registrationName, listener) {

    // 用来标识注册了事件,比如onClick的React对象。key的格式为'.nodeId', 只用知道它可以标示哪个React对象就可以了
    var key = getDictionaryKey(inst);
    var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});
    // 将listener事件回调方法存入listenerBank[registrationName][key]中,比如listenerBank['onclick'][nodeId]
    // 所有React组件对象定义的所有React事件都会存储在listenerBank中
    bankForRegistrationName[key] = listener;

    //onSelect和onClick注册了两个事件回调插件, 用于walkAround某些浏览器兼容bug,不用care
    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
    if (PluginModule &amp;&amp; PluginModule.didPutListener) {
      PluginModule.didPutListener(inst, registrationName, listener);
    }
  },

var getDictionaryKey = function (inst) {
  return '.' + inst._rootNodeID;
};
</code></pre>
<p>由上可见，事件存储在了 listenerBank 对象中，它按照事件名和 React 组件对象进行了二维划分，比如 nodeId 组件上注册的 onClick 事件最后存储在
listenerBank.onclick[nodeId]中。</p>
<h2 id="4-事件执行"><a class="header" href="#4-事件执行">4 事件执行</a></h2>
<h2 id="41-事件分发"><a class="header" href="#41-事件分发">4.1 事件分发</a></h2>
<p>当事件触发时，document 上 addEventListener 注册的 callback 会被回调。从前面事件注册部分发现，此时回调函数为
ReactEventListener.dispatchEvent，它是事件分发的入口方法。下面我们来详细分析</p>
<pre><code class="language-js">// topLevelType：带top的事件名，如topClick。不用纠结为什么带一个top字段，知道它是事件名就OK了
// nativeEvent: 用户触发click等事件时，浏览器传递的原生事件
dispatchEvent: function (topLevelType, nativeEvent) {
    // disable了则直接不回调相关方法
    if (!ReactEventListener._enabled) {
      return;
    }

    var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);
    try {
      // 放入批处理队列中,React事件流也是一个消息队列的方式
      ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);
    } finally {
      TopLevelCallbackBookKeeping.release(bookKeeping);
    }
}
</code></pre>
<p>可见我们仍然使用批处理的方式进行事件分发，handleTopLevelImpl 才是事件分发的真正执行者，它是事件分发的核心，体现了 React 事件分发的特点，如下</p>
<pre><code class="language-js">// document进行事件分发,这样具体的React组件才能得到响应。因为DOM事件是绑定到document上的
function handleTopLevelImpl(bookKeeping) {
  // 找到事件触发的DOM和React Component
  var nativeEventTarget = getEventTarget(bookKeeping.nativeEvent);
  var targetInst =
    ReactDOMComponentTree.getClosestInstanceFromNode(nativeEventTarget);

  // 执行事件回调前,先由当前组件向上遍历它的所有父组件。得到ancestors这个数组。
  // 因为事件回调中可能会改变Virtual DOM结构,所以要先遍历好组件层级
  var ancestor = targetInst;
  do {
    bookKeeping.ancestors.push(ancestor);
    ancestor = ancestor &amp;&amp; findParent(ancestor);
  } while (ancestor);

  // 从当前组件向父组件遍历,依次执行注册的回调方法. 我们遍历构造ancestors数组时,是从当前组件向父组件回溯的,故此处事件回调也是这个顺序
  // 这个顺序就是冒泡的顺序,并且我们发现不能通过stopPropagation来阻止'冒泡'。
  for (var i = 0; i &lt; bookKeeping.ancestors.length; i++) {
    targetInst = bookKeeping.ancestors[i];
    ReactEventListener._handleTopLevel(
      bookKeeping.topLevelType,
      targetInst,
      bookKeeping.nativeEvent,
      getEventTarget(bookKeeping.nativeEvent)
    );
  }
}
</code></pre>
<p>从上面的事件分发中可见，React 自身实现了一套冒泡机制。从触发事件的对象开始，向父元素回溯，依次调用它们注册的事件 callback。</p>
<h2 id="42-事件-callback-调用"><a class="header" href="#42-事件-callback-调用">4.2 事件 callback 调用</a></h2>
<p>事件处理由_handleTopLevel 完成。它其实是调用 ReactBrowserEventEmitter.handleTopLevel() ，如下</p>
<pre><code class="language-js">// React事件调用的入口。DOM事件绑定在了document原生对象上,每次事件触发,都会调用到handleTopLevel
  handleTopLevel: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    // 采用对象池的方式构造出合成事件。不同的eventType的合成事件可能不同
    var events = EventPluginHub.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
    // 批处理队列中的events
    runEventQueueInBatch(events);
  }
</code></pre>
<p>handleTopLevel 方法是事件 callback 调用的核心。它主要做两件事情，一方面利用浏览器回传的原生事件构造出 React 合成事件，另一方面采用队列的方式处理
events。先看如何构造合成事件。</p>
<h2 id="421-构造合成事件"><a class="header" href="#421-构造合成事件">4.2.1 构造合成事件</a></h2>
<pre><code class="language-js">// 构造合成事件
  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var events;
    // EventPluginHub可以存储React合成事件的callback,也存储了一些plugin,这些plugin在EventPluginHub初始化时就注册就来了
    var plugins = EventPluginRegistry.plugins;
    for (var i = 0; i &lt; plugins.length; i++) {
      var possiblePlugin = plugins[i];
      if (possiblePlugin) {
        // 根据eventType构造不同的合成事件SyntheticEvent
        var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
        if (extractedEvents) {
          // 将构造好的合成事件extractedEvents添加到events数组中,这样就保存了所有plugin构造的合成事件
          events = accumulateInto(events, extractedEvents);
        }
      }
    }
    return events;
  },
</code></pre>
<p>EventPluginRegistry.plugins 默认包含五种 plugin，他们是在 EventPluginHub 初始化阶段注入进去的，且看代码</p>
<pre><code class="language-js">// 将eventPlugin注册到EventPluginHub中
ReactInjection.EventPluginHub.injectEventPluginsByName({
  SimpleEventPlugin: SimpleEventPlugin,
  EnterLeaveEventPlugin: EnterLeaveEventPlugin,
  ChangeEventPlugin: ChangeEventPlugin,
  SelectEventPlugin: SelectEventPlugin,
  BeforeInputEventPlugin: BeforeInputEventPlugin,
});
</code></pre>
<p>不同的 plugin 针对不同的事件有特殊的处理，此处我们不展开讲了，下面仅分析 SimpleEventPlugin 中方法即可。</p>
<p>我们先看 SimpleEventPlugin 如何构造它所对应的 React 合成事件。</p>
<pre><code class="language-js">// 根据不同事件类型,比如click,focus构造不同的合成事件SyntheticEvent, 如SyntheticKeyboardEvent SyntheticFocusEvent
extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
    if (!dispatchConfig) {
      return null;
    }
    var EventConstructor;

   // 根据事件类型，采用不同的SyntheticEvent来构造不同的合成事件
    switch (topLevelType) {
      ... // 省略一些事件，我们仅以blur和focus为例
      case 'topBlur':
      case 'topFocus':
        EventConstructor = SyntheticFocusEvent;
        break;
      ... // 省略一些事件
    }

    // 从event对象池中取出合成事件对象,利用对象池思想,可以大大降低对象创建和销毁的时间,提高性能。这是React事件系统的一大亮点
    var event = EventConstructor.getPooled(dispatchConfig, targetInst, nativeEvent, nativeEventTarget);
    EventPropagators.accumulateTwoPhaseDispatches(event);
    return event;
},
</code></pre>
<p>这里我们看到了 event 对象池这个重大特性，采用合成事件对象池的方式，可以大大降低销毁和创建合成事件带来的性能开销。</p>
<p>对象创建好之后，我们还会将它添加到 events 这个队列中，因为事件回调的时候会用到这个队列。添加到 events 中使用的是 accumulateInto
方法。它思路比较简单，将新创建的合成对象的引用添加到之前创建好的 events 队列中即可，源码如下</p>
<pre><code class="language-js">function accumulateInto(current, next) {
  if (current == null) {
    return next;
  }

  // 将next添加到current中,返回一个包含他们两个的新数组
  // 如果next是数组,current不是数组,采用push方法,否则采用concat方法
  // 如果next不是数组,则返回一个current和next构成的新数组
  if (Array.isArray(current)) {
    if (Array.isArray(next)) {
      current.push.apply(current, next);
      return current;
    }
    current.push(next);
    return current;
  }

  if (Array.isArray(next)) {
    return [current].concat(next);
  }

  return [current, next];
}
</code></pre>
<h2 id="422-批处理合成事件"><a class="header" href="#422-批处理合成事件">4.2.2 批处理合成事件</a></h2>
<p>我们上面分析过了，React 以队列的形式处理合成事件。方法入口为 runEventQueueInBatch，如下</p>
<pre><code class="language-js">function runEventQueueInBatch(events) {
    // 先将events事件放入队列中
    EventPluginHub.enqueueEvents(events);
    // 再处理队列中的事件,包括之前未处理完的。先入先处理原则
    EventPluginHub.processEventQueue(false);
  }

  /**
   * syntheticEvent放入队列中,等到processEventQueue再获得执行
   */
  enqueueEvents: function (events) {
    if (events) {
      eventQueue = accumulateInto(eventQueue, events);
    }
  },

  /**
   * 分发执行队列中的React合成事件。React事件是采用消息队列方式批处理的
   *
   * simulated：为true表示React测试代码，我们一般都是false
   */
  processEventQueue: function (simulated) {
    // 先将eventQueue重置为空
    var processingEventQueue = eventQueue;
    eventQueue = null;
    if (simulated) {
      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);
    } else {
      // 遍历处理队列中的事件,
      // 如果只有一个元素,则直接executeDispatchesAndReleaseTopLevel(processingEventQueue)
      // 否则遍历队列中事件,调用executeDispatchesAndReleaseTopLevel处理每个元素
      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
    }
    // This would be a good time to rethrow if any of the event handlers threw.
    ReactErrorUtils.rethrowCaughtError();
  },
</code></pre>
<p>合成事件处理也分为两步，先将我们要处理的 events 队列放入 eventQueue 中，因为之前可能就存在还没处理完的合成事件。然后再执行 eventQueue
中的事件。可见，如果之前有事件未处理完，这里就又有得到执行的机会了。</p>
<p>事件执行的入口方法为 executeDispatchesAndReleaseTopLevel，如下</p>
<pre><code class="language-js">var executeDispatchesAndReleaseTopLevel = function (e) {
  return executeDispatchesAndRelease(e, false);
};

var executeDispatchesAndRelease = function (event, simulated) {
  if (event) {
    // 进行事件分发,
    EventPluginUtils.executeDispatchesInOrder(event, simulated);

    if (!event.isPersistent()) {
      // 处理完,则release掉event对象,采用对象池方式,减少GC
      // React帮我们处理了合成事件的回收机制，不需要我们关心。但要注意，如果使用了DOM原生事件，则要自己回收
      event.constructor.release(event);
    }
  }
};

// 事件处理的核心
function executeDispatchesInOrder(event, simulated) {
  var dispatchListeners = event._dispatchListeners;
  var dispatchInstances = event._dispatchInstances;

  if (Array.isArray(dispatchListeners)) {
    // 如果有多个listener,则遍历执行数组中event
    for (var i = 0; i &lt; dispatchListeners.length; i++) {
      // 如果isPropagationStopped设成true了,则停止事件传播,退出循环。
      if (event.isPropagationStopped()) {
        break;
      }
      // 执行event的分发,从当前触发事件元素向父元素遍历
      // event为浏览器上传的原生事件
      // dispatchListeners[i]为JSX中声明的事件callback
      // dispatchInstances[i]为对应的React Component
      executeDispatch(
        event,
        simulated,
        dispatchListeners[i],
        dispatchInstances[i]
      );
    }
  } else if (dispatchListeners) {
    // 如果只有一个listener,则直接执行事件分发
    executeDispatch(event, simulated, dispatchListeners, dispatchInstances);
  }
  // 处理完event,重置变量。因为使用的对象池,故必须重置,这样才能被别人复用
  event._dispatchListeners = null;
  event._dispatchInstances = null;
}
</code></pre>
<p>executeDispatchesInOrder 会先得到 event 对应的 listeners 队列，然后从当前元素向父元素遍历执行注册的 callback。且看 executeDispatch</p>
<pre><code class="language-js">function executeDispatch(event, simulated, listener, inst) {
  var type = event.type || &quot;unknown-event&quot;;
  event.currentTarget = EventPluginUtils.getNodeFromInstance(inst);
  if (simulated) {
    // test代码使用,支持try-catch,其他就没啥区别了
    ReactErrorUtils.invokeGuardedCallbackWithCatch(type, listener, event);
  } else {
    // 事件分发,listener为callback,event为参数,类似listener(event)这个方法调用
    // 这样就回调到了我们在JSX中注册的callback。比如onClick={(event) =&gt; {console.log(1)}}
    // 这样应该就明白了callback怎么被调用的,以及event参数怎么传入callback里面的了
    ReactErrorUtils.invokeGuardedCallback(type, listener, event);
  }
  event.currentTarget = null;
}

// 采用func(a)的方式进行调用，
// 故ReactErrorUtils.invokeGuardedCallback(type, listener, event)最终调用的是listener(event)
// event对象为浏览器传递的DOM原生事件对象，这也就解释了为什么React合成事件回调中能拿到原生event的原因
function invokeGuardedCallback(name, func, a) {
  try {
    func(a);
  } catch (x) {
    if (caughtError === null) {
      caughtError = x;
    }
  }
}
</code></pre>
<h2 id="5-总结"><a class="header" href="#5-总结">5 总结</a></h2>
<p>React 事件系统还是相当麻烦的，主要分为事件注册，事件存储和事件执行三大部分。了解了 React 事件系统源码，就能够轻松回答我们文章开头所列出的 React 事件几大特点了。</p>
<p>由于事件系统相当麻烦，文章中不正确的地方，请不吝赐教！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="react-hooks-详解-近-1w-字-项目实战"><a class="header" href="#react-hooks-详解-近-1w-字-项目实战">React Hooks 详解 【近 1W 字】+ 项目实战</a></h1>
<p><a href="https://juejin.cn/post/6844903985338400782">引用</a></p>
<h1 id="react-hooks"><a class="header" href="#react-hooks">React Hooks</a></h1>
<h2 id="一什么是-hooks"><a class="header" href="#一什么是-hooks">一、什么是 Hooks</a></h2>
<ul>
<li>React 一直都提倡使用_<strong>函数组件</strong> <em>，但是有时候需要使用 state 或者其他一些功能时，只能使用</em> <strong>类组件</strong>_，因为函数组件没有实例，没有生命周期函数，只有类组件才有</li>
<li>Hooks 是 React 16.8 新增的特性，它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性</li>
<li>如果你在编写函数组件并意识到需要向其添加一些 state，以前的做法是必须将其它转化为 class。现在你可以直接在现有的函数组件中使用 Hooks</li>
<li>凡是 use 开头的 React API 都是 Hooks</li>
</ul>
<h2 id="二hooks-解决的问题"><a class="header" href="#二hooks-解决的问题">二、Hooks 解决的问题</a></h2>
<h3 id="1-类组件的不足"><a class="header" href="#1-类组件的不足">1. 类组件的不足</a></h3>
<ul>
<li>
<p><strong>状态逻辑难复用：</strong> 在组件之间复用状态逻辑很难，可能要用到 <strong>render props</strong> （<strong>渲染属性</strong>）或者
<strong>HOC</strong>（<strong>高阶组件</strong>），但无论是渲染属性，还是高阶组件，都会在原先的组件外包裹一层父容器（一般都是 div 元素），<strong>导致层级冗余</strong></p>
</li>
<li>
<p>趋向复杂难以维护：</p>
<ul>
<li>在生命周期函数中混杂不相干的逻辑（如：在 <code>componentDidMount</code> 中注册事件以及其他的逻辑，在 <code>componentWillUnmount</code>
中卸载事件，这样分散不集中的写法，很容易写出 bug ）</li>
<li>类组件中到处都是对状态的访问和处理，导致组件难以拆分成更小的组件</li>
</ul>
</li>
<li>
<p>this 指向问题</p>
<ul>
<li>
<p>父组件给子组件传递函数时，必须绑定 this</p>
</li>
<li>
<p>react 中的组件四种绑定 this 方法的区别</p>
</li>
</ul>
</li>
</ul>
<pre><code class="language-javascript">class App extends React.Component&lt;any, any&gt; {
  handleClick2;

  constructor(props) {
    super(props);
    this.state = {
      num: 1,
      title: &quot; react study&quot;,
    };
    this.handleClick2 = this.handleClick1.bind(this);
  }

  handleClick1() {
    this.setState({
      num: this.state.num + 1,
    });
  }

  handleClick3 = () =&gt; {
    this.setState({
      num: this.state.num + 1,
    });
  };

  render() {
    return (
      &lt;div&gt;
        &lt;h2&gt;Ann, {this.state.num}&lt;/h2&gt;
        &lt;button onClick={this.handleClick2}&gt;btn1&lt;/button&gt;
        &lt;button onClick={this.handleClick1.bind(this)}&gt;btn2&lt;/button&gt;
        &lt;button onClick={() =&gt; this.handleClick1()}&gt;btn3&lt;/button&gt;
        &lt;button onClick={this.handleClick3}&gt;btn4&lt;/button&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre>
<p>前提：子组件内部做了性能优化，如（<strong>React.PureComponent</strong>）</p>
<ul>
<li>第一种是<strong>在构造函数中绑定 this</strong>：那么每次父组件刷新的时候，如果传递给子组件其他的 props 值不变，那么子组件就不会刷新；</li>
<li>第二种是<strong>在 render() 函数里面绑定 this</strong>：因为 <strong>bind 函数会返回一个新的函数</strong>，所以每次父组件刷新时，都会重新生成一个函数，即使父组件传递给子组件其他的 props
值不变，子组件每次都会刷新；</li>
<li>第三种是<strong>使用箭头函数</strong>：父组件刷新的时候，即使两个箭头函数的函数体是一样的，都会生成一个新的箭头函数，所以子组件每次都会刷新；</li>
<li>第四种是<strong>使用类的静态属性：原理和第一种方法差不多，比第一种更简洁</strong></li>
</ul>
<p>综上所述，如果不注意的话，很容易写成第三种写法，导致性能上有所损耗。</p>
<h3 id="2-hooks-优势"><a class="header" href="#2-hooks-优势">2. Hooks 优势</a></h3>
<ul>
<li>能优化类组件的三大问题</li>
<li>能在无需修改组件结构的情况下复用状态逻辑（自定义 Hooks ）</li>
<li>能将组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据）</li>
<li><strong>副作用的关注点分离</strong>：<strong>副作用指那些没有发生在数据向视图转换过程中的逻辑，如 <code>ajax</code> 请求、访问原生<code>dom</code>
元素、本地持久化缓存、绑定/解绑事件、添加订阅、设置定时器、记录日志等</strong>。以往这些副作用都是写在类组件生命周期函数中的。而 <code>useEffect</code>
在全部渲染完毕后才会执行，<code>useLayoutEffect</code> 会在浏览器 <code>layout</code> 之后，<code>painting</code> 之前执行。</li>
</ul>
<h2 id="三注意事项"><a class="header" href="#三注意事项">三、注意事项</a></h2>
<ul>
<li><strong>只能在函数内部的最外层调用 Hook，不要在循环、条件判断或者子函数中调用</strong></li>
<li><strong>只能在 React 的函数组件中调用 Hook，不要在其他 JavaScript 函数中调用</strong></li>
<li><a href="https://reactjs.org/warnings/invalid-hook-call-warning.html"><strong>https://reactjs.org/warnings/invalid-hook-call-warning.html</strong></a></li>
</ul>
<h2 id="四usestate--usememo--usecallback"><a class="header" href="#四usestate--usememo--usecallback">四、useState &amp; useMemo &amp; useCallback</a></h2>
<ul>
<li>
<p><strong>React 假设当你多次调用 useState 的时候，你能保证每次渲染时它们的调用顺序是不变的。</strong></p>
</li>
<li>
<p>通过在函数组件里调用它来给组件添加一些内部 state，React 会 <strong>在重复渲染时保留这个 state</strong></p>
</li>
<li>
<p>useState 唯一的参数就是初始 state</p>
</li>
<li>
<p>useState 会返回一个数组</p>
<ul>
<li>
<p>一个 state，一个更新 state 的函数</p>
</li>
<li>
<p>在初始化渲染期间，返回的状态 (state) 与传入的第一个参数 (initialState) 值相同</p>
</li>
</ul>
</li>
<li>
<p>你可以在事件处理函数中或其他一些地方调用这个函数。它类似 class 组件的 this.setState，但是它<strong>不会把新的 state 和旧的 state 进行合并，而是直接替换</strong></p>
</li>
</ul>
<pre><code class="language-javascript">// 这里可以任意命名，因为返回的是数组，数组解构
const [state, setState] = useState(initialState);
</code></pre>
<h3 id="41-使用例子"><a class="header" href="#41-使用例子">4.1 使用例子</a></h3>
<pre><code class="language-javascript">import React, { useState } from &quot;react&quot;;
import ReactDOM from &quot;react-dom&quot;;

function Child1(porps) {
  console.log(porps);
  const { num, handleClick } = porps;
  return (
    &lt;div
      onClick={() =&gt; {
        handleClick(num + 1);
      }}
    &gt;
      child
    &lt;/div&gt;
  );
}

function Child2(porps) {
  // console.log(porps);
  const { text, handleClick } = porps;
  return (
    &lt;div&gt;
      child2
      &lt;Grandson text={text} handleClick={handleClick} /&gt;
    &lt;/div&gt;
  );
}

function Grandson(porps) {
  console.log(porps);
  const { text, handleClick } = porps;
  return (
    &lt;div
      onClick={() =&gt; {
        handleClick(text + 1);
      }}
    &gt;
      grandson
    &lt;/div&gt;
  );
}

function Parent() {
  let [num, setNum] = useState(0);
  let [text, setText] = useState(1);

  return (
    &lt;div&gt;
      &lt;Child1 num={num} handleClick={setNum} /&gt;
      &lt;Child2 text={text} handleClick={setText} /&gt;
    &lt;/div&gt;
  );
}

const rootElement = document.getElementById(&quot;root&quot;);
ReactDOM.render(&lt;Parent /&gt;, rootElement);
</code></pre>
<h3 id="42-每次渲染都是独立的闭包"><a class="header" href="#42-每次渲染都是独立的闭包">4.2 每次渲染都是独立的闭包</a></h3>
<ul>
<li>每一次渲染都有它自己的 Props 和 State</li>
<li>每一次渲染都有它自己的事件处理函数</li>
<li>当点击更新状态的时候，函数组件都会重新被调用，那么每次渲染都是独立的，取到的值不会受后面操作的影响</li>
</ul>
<pre><code class="language-javascript">function Counter2() {
  let [number, setNumber] = useState(0);
  function alertNumber() {
    setTimeout(() =&gt; {
      // alert 只能获取到点击按钮时的那个状态
      alert(number);
    }, 3000);
  }
  return (
    &lt;&gt;
      &lt;p&gt;{number}&lt;/p&gt;
      &lt;button onClick={() =&gt; setNumber(number + 1)}&gt;+&lt;/button&gt;
      &lt;button onClick={alertNumber}&gt;alertNumber&lt;/button&gt;
    &lt;/&gt;
  );
}
</code></pre>
<h3 id="43-函数式更新"><a class="header" href="#43-函数式更新">4.3 函数式更新</a></h3>
<ul>
<li><strong>如果新的 state 需要通过使用先前的 state 计算得出，那么可以将回调函数当做参数传递给 setState。该回调函数将接收先前的 state，并返回一个更新后的值。</strong></li>
</ul>
<pre><code class="language-javascript">function Counter() {
  let [number, setNumber] = useState(0);
  function lazy() {
    setTimeout(() =&gt; {
      // setNumber(number+1);
      // 这样每次执行时都会去获取一遍 state，而不是使用点击触发时的那个 state
      setNumber((number) =&gt; number + 1);
    }, 3000);
  }
  return (
    &lt;&gt;
      &lt;p&gt;{number}&lt;/p&gt;
      &lt;button onClick={() =&gt; setNumber(number + 1)}&gt;+&lt;/button&gt;
      &lt;button onClick={lazy}&gt;lazy&lt;/button&gt;
    &lt;/&gt;
  );
}
</code></pre>
<h3 id="44-惰性初始化-state"><a class="header" href="#44-惰性初始化-state">4.4 惰性初始化 state</a></h3>
<ul>
<li><strong>initialState 参数只会在组件的初始化渲染中起作用，后续渲染时会被忽略</strong></li>
<li><strong>如果初始 state 需要通过复杂计算获得，则可以传入一个函数，在函数中计算并返回初始的 state，此函数只在初始渲染时被调用</strong></li>
</ul>
<pre><code class="language-javascript">function Counter5(props) {
  console.log(&quot;Counter5 render&quot;);
  // 这个函数只在初始渲染时执行一次，后续更新状态重新渲染组件时，该函数就不会再被调用
  function getInitState() {
    return { number: props.number };
  }
  let [counter, setCounter] = useState(getInitState);
  return (
    &lt;&gt;
      &lt;p&gt;{counter.number}&lt;/p&gt;
      &lt;button onClick={() =&gt; setCounter({ number: counter.number + 1 })}&gt;
        +
      &lt;/button&gt;
      &lt;button onClick={() =&gt; setCounter(counter)}&gt;setCounter&lt;/button&gt;
    &lt;/&gt;
  );
}
</code></pre>
<h3 id="45-性能优化"><a class="header" href="#45-性能优化">4.5 性能优化</a></h3>
<h4 id="451-objectis-浅比较"><a class="header" href="#451-objectis-浅比较">4.5.1 Object.is （浅比较）</a></h4>
<ul>
<li>Hook 内部使用 Object.is 来比较新/旧 state 是否相等</li>
<li><strong>与 class 组件中的 setState 方法不同，如果你修改状态的时候，传的状态值没有变化，则不重新渲染</strong></li>
<li><strong>与 class 组件中的 setState 方法不同，useState 不会自动合并更新对象。你可以用函数式的 setState 结合展开运算符来达到合并更新对象的效果</strong></li>
</ul>
<pre><code class="language-javascript">function Counter() {
  const [counter, setCounter] = useState({ name: &quot;计数器&quot;, number: 0 });
  console.log(&quot;render Counter&quot;);
  // 如果你修改状态的时候，传的状态值没有变化，则不重新渲染
  return (
    &lt;&gt;
      &lt;p&gt;
        {counter.name}:{counter.number}
      &lt;/p&gt;
      &lt;button
        onClick={() =&gt; setCounter({ ...counter, number: counter.number + 1 })}
      &gt;
        +
      &lt;/button&gt;
      &lt;button onClick={() =&gt; setCounter(counter)}&gt;++&lt;/button&gt;
    &lt;/&gt;
  );
}
</code></pre>
<h4 id="452-减少渲染次数"><a class="header" href="#452-减少渲染次数">4.5.2 减少渲染次数</a></h4>
<ul>
<li><strong>默认情况，只要父组件状态变了（不管子组件依不依赖该状态），子组件也会重新渲染</strong></li>
<li>一般的优化：
<ol>
<li><strong>类组件</strong>：可以使用 <code>pureComponent</code> ；</li>
<li><strong>函数组件</strong>：使用 <code>React.memo</code> ，将函数组件传递给 <code>memo</code> 之后，就会返回一个新的组件，新组件的功能：<strong>如果接受到的属性不变，则不重新渲染函数</strong>；</li>
</ol>
</li>
<li><strong>但是怎么保证属性不会变尼？这里使用 useState ，每次更新都是独立的</strong>，<code>const [number,setNumber] = useState(0)</code>
<strong>也就是说每次都会生成一个新的值（哪怕这个值没有变化），即使使用了 <code>React.memo</code> ，也还是会重新渲染</strong></li>
</ul>
<pre><code class="language-javascript">import React, { useState, memo, useMemo, useCallback } from &quot;react&quot;;

function SubCounter({ onClick, data }) {
  console.log(&quot;SubCounter render&quot;);
  return &lt;button onClick={onClick}&gt;{data.number}&lt;/button&gt;;
}
SubCounter = memo(SubCounter);
export default function Counter6() {
  console.log(&quot;Counter render&quot;);
  const [name, setName] = useState(&quot;计数器&quot;);
  const [number, setNumber] = useState(0);
  const data = { number };
  const addClick = () =&gt; {
    setNumber(number + 1);
  };
  return (
    &lt;&gt;
      &lt;input
        type=&quot;text&quot;
        value={name}
        onChange={(e) =&gt; setName(e.target.value)}
      /&gt;
      &lt;SubCounter data={data} onClick={addClick} /&gt;
    &lt;/&gt;
  );
}
</code></pre>
<ul>
<li>更深入的优化：
<ol>
<li><strong>useCallback</strong>：接收一个内联回调函数参数和一个依赖项数组（子组件依赖父组件的状态，即子组件会使用到父组件的值） ，useCallback 会返回该回调函数的 memoized
版本，该回调函数仅在某个依赖项改变时才会更新</li>
<li><strong>useMemo</strong>：把创建函数和依赖项数组作为参数传入 <code>useMemo</code>，它仅会在某个依赖项改变时才重新计算 memoized 值。这种优化有助于避免在每次渲染时都进行高开销的计算</li>
</ol>
</li>
</ul>
<pre><code class="language-javascript">import React, { useState, memo, useMemo, useCallback } from &quot;react&quot;;

function SubCounter({ onClick, data }) {
  console.log(&quot;SubCounter render&quot;);
  return &lt;button onClick={onClick}&gt;{data.number}&lt;/button&gt;;
}
SubCounter = memo(SubCounter);

let oldData, oldAddClick;
export default function Counter2() {
  console.log(&quot;Counter render&quot;);
  const [name, setName] = useState(&quot;计数器&quot;);
  const [number, setNumber] = useState(0);
  // 父组件更新时，这里的变量和函数每次都会重新创建，那么子组件接受到的属性每次都会认为是新的
  // 所以子组件也会随之更新，这时候可以用到 useMemo
  // 有没有后面的依赖项数组很重要，否则还是会重新渲染
  // 如果后面的依赖项数组没有值的话，即使父组件的 number 值改变了，子组件也不会去更新
  //const data = useMemo(()=&gt;({number}),[]);
  const data = useMemo(() =&gt; ({ number }), [number]);
  console.log(&quot;data===oldData &quot;, data === oldData);
  oldData = data;

  // 有没有后面的依赖项数组很重要，否则还是会重新渲染
  const addClick = useCallback(() =&gt; {
    setNumber(number + 1);
  }, [number]);
  console.log(&quot;addClick===oldAddClick &quot;, addClick === oldAddClick);
  oldAddClick = addClick;
  return (
    &lt;&gt;
      &lt;input
        type=&quot;text&quot;
        value={name}
        onChange={(e) =&gt; setName(e.target.value)}
      /&gt;
      &lt;SubCounter data={data} onClick={addClick} /&gt;
    &lt;/&gt;
  );
}
</code></pre>
<h3 id="46-usestate-源码中的链表实现"><a class="header" href="#46-usestate-源码中的链表实现">4.6 useState 源码中的链表实现</a></h3>
<pre><code class="language-javascript">import React from &quot;react&quot;;
import ReactDOM from &quot;react-dom&quot;;

let firstWorkInProgressHook = { memoizedState: null, next: null };
let workInProgressHook;

function useState(initState) {
  let currentHook = workInProgressHook.next
    ? workInProgressHook.next
    : { memoizedState: initState, next: null };

  function setState(newState) {
    currentHook.memoizedState = newState;
    render();
  }
  // 这就是为什么 useState 书写顺序很重要的原因
  // 假如某个 useState 没有执行，会导致指针移动出错，数据存取出错
  if (workInProgressHook.next) {
    // 这里只有组件刷新的时候，才会进入
    // 根据书写顺序来取对应的值
    // console.log(workInProgressHook);
    workInProgressHook = workInProgressHook.next;
  } else {
    // 只有在组件初始化加载时，才会进入
    // 根据书写顺序，存储对应的数据
    // 将 firstWorkInProgressHook 变成一个链表结构
    workInProgressHook.next = currentHook;
    // 将 workInProgressHook 指向 {memoizedState: initState, next: null}
    workInProgressHook = currentHook;
    // console.log(firstWorkInProgressHook);
  }
  return [currentHook.memoizedState, setState];
}

function Counter() {
  // 每次组件重新渲染的时候，这里的 useState 都会重新执行
  const [name, setName] = useState(&quot;计数器&quot;);
  const [number, setNumber] = useState(0);
  return (
    &lt;&gt;
      &lt;p&gt;
        {name}:{number}
      &lt;/p&gt;
      &lt;button onClick={() =&gt; setName(&quot;新计数器&quot; + Date.now())}&gt;新计数器&lt;/button&gt;
      &lt;button onClick={() =&gt; setNumber(number + 1)}&gt;+&lt;/button&gt;
    &lt;/&gt;
  );
}

function render() {
  // 每次重新渲染的时候，都将 workInProgressHook 指向 firstWorkInProgressHook
  workInProgressHook = firstWorkInProgressHook;
  ReactDOM.render(&lt;Counter /&gt;, document.getElementById(&quot;root&quot;));
}

render();
</code></pre>
<h2 id="五usereducer"><a class="header" href="#五usereducer">五、useReducer</a></h2>
<ul>
<li>useReducer 和 redux 中 reducer 很像</li>
<li>useState 内部就是靠 useReducer 来实现的</li>
<li>useState 的替代方案，它接收一个形如 (state, action) =&gt; newState 的 reducer，并返回当前的 state 以及与其配套的 dispatch 方法</li>
<li>在某些场景下，useReducer 会比 useState 更适用，例如 state 逻辑较复杂且包含多个子值，或者下一个 state 依赖于之前的 state 等</li>
</ul>
<pre><code class="language-javascript">let initialState = 0;
// 如果你希望初始状态是一个{number:0}
// 可以在第三个参数中传递一个这样的函数 ()=&gt;({number:initialState})
// 这个函数是一个惰性初始化函数，可以用来进行复杂的计算，然后返回最终的 initialState
const [state, dispatch] = useReducer(reducer, initialState, init);

const initialState = 0;
function reducer(state, action) {
  switch (action.type) {
    case &quot;increment&quot;:
      return { number: state.number + 1 };
    case &quot;decrement&quot;:
      return { number: state.number - 1 };
    default:
      throw new Error();
  }
}
function init(initialState) {
  return { number: initialState };
}
function Counter() {
  const [state, dispatch] = useReducer(reducer, initialState, init);
  return (
    &lt;&gt;
      Count: {state.number}
      &lt;button onClick={() =&gt; dispatch({ type: &quot;increment&quot; })}&gt;+&lt;/button&gt;
      &lt;button onClick={() =&gt; dispatch({ type: &quot;decrement&quot; })}&gt;-&lt;/button&gt;
    &lt;/&gt;
  );
}
</code></pre>
<h2 id="六usecontext"><a class="header" href="#六usecontext">六、useContext</a></h2>
<ul>
<li>接收一个 context 对象（React.createContext 的返回值）并返回该 context 的当前值</li>
<li>当前的 context 值由上层组件中距离当前组件最近的 &lt;MyContext.Provider&gt; 的 value prop 决定</li>
<li>当组件上层最近的 &lt;MyContext.Provider&gt; 更新时，该 Hook 会触发重渲染，并使用最新传递给 MyContext provider 的 context value 值</li>
<li><strong>useContext(MyContext) 相当于 class 组件中的</strong> <code>static contextType = MyContext</code> 或者
<code>&lt;MyContext.Consumer&gt;</code></li>
<li><strong>useContext(MyContext) 只是让你能够读取 context 的值以及订阅 context 的变化。你仍然需要在上层组件树中使用 来为下层组件提供 context</strong></li>
</ul>
<pre><code class="language-javascript">import React, {
  useState,
  memo,
  useMemo,
  useCallback,
  useReducer,
  createContext,
  useContext,
} from &quot;react&quot;;
import ReactDOM from &quot;react-dom&quot;;

const initialState = 0;
function reducer(state = initialState, action) {
  switch (action.type) {
    case &quot;ADD&quot;:
      return { number: state.number + 1 };
    default:
      break;
  }
}

const CounterContext = createContext();
// 第一种获取 CounterContext 方法：不使用 hook
function SubCounter_one() {
  return (
    &lt;CounterContext.Consumer&gt;
      {(value) =&gt; (
        &lt;&gt;
          &lt;p&gt;{value.state.number}&lt;/p&gt;
          &lt;button onClick={() =&gt; value.dispatch({ type: &quot;ADD&quot; })}&gt;+&lt;/button&gt;
        &lt;/&gt;
      )}
    &lt;/CounterContext.Consumer&gt;
  );
}
// 第二种获取 CounterContext 方法：使用 hook ，更简洁
function SubCounter() {
  const { state, dispatch } = useContext(CounterContext);
  return (
    &lt;&gt;
      &lt;p&gt;{state.number}&lt;/p&gt;
      &lt;button onClick={() =&gt; dispatch({ type: &quot;ADD&quot; })}&gt;+&lt;/button&gt;
    &lt;/&gt;
  );
}
/* class SubCounter extends React.Component{
    static contextTypes = CounterContext
    this.context =  {state, dispatch}
} */

function Counter() {
  const [state, dispatch] = useReducer(reducer, initialState, () =&gt; ({
    number: initialState,
  }));
  return (
    &lt;CounterContext.Provider value={{ state, dispatch }}&gt;
      &lt;SubCounter /&gt;
    &lt;/CounterContext.Provider&gt;
  );
}
ReactDOM.render(&lt;Counter /&gt;, document.getElementById(&quot;root&quot;));
</code></pre>
<h2 id="七useeffect"><a class="header" href="#七useeffect">七、useEffect</a></h2>
<ul>
<li><strong>effect（副作用）：指那些没有发生在数据向视图转换过程中的逻辑，如 <code>ajax</code> 请求、访问原生<code>dom</code> 元素、本地持久化缓存、绑定/解绑事件、添加订阅、设置定时器、记录日志等。</strong></li>
<li><strong>副作用操作可以分两类：需要清除的和不需要清除的。</strong></li>
<li>原先在函数组件内（这里指在 React 渲染阶段）改变 dom 、发送 ajax 请求以及执行其他包含副作用的操作都是不被允许的，因为这可能会产生莫名其妙的 bug 并破坏 UI 的一致性</li>
<li>useEffect 就是一个 Effect Hook，给函数组件增加了操作副作用的能力。它跟 class 组件中的 <code>componentDidMount</code>、<code>componentDidUpdate</code>
和 <code>componentWillUnmount</code> 具有相同的用途，只不过被合并成了一个 API</li>
<li><strong>useEffect 接收一个函数，该函数会在组件渲染到屏幕之后才执行，该函数有要求：要么返回一个能清除副作用的函数，要么就不返回任何内容</strong></li>
<li>与 <code>componentDidMount</code> 或 <code>componentDidUpdate</code> 不同，使用 useEffect 调度的 effect
不会阻塞浏览器更新屏幕，这让你的应用看起来响应更快。大多数情况下，effect 不需要同步地执行。在个别情况下（例如测量布局），有单独的 useLayoutEffect Hook 供你使用，其
API 与 useEffect 相同。</li>
</ul>
<h3 id="71-使用-class-组件实现修改标题"><a class="header" href="#71-使用-class-组件实现修改标题">7.1 使用 class 组件实现修改标题</a></h3>
<ul>
<li>在这个 class 中，我们需要在两个生命周期函数中编写重复的代码，这是因为很多情况下，我们希望在组件加载和更新时执行同样的操作。我们希望它在每次渲染之后执行，但 React 的 class
组件没有提供这样的方法。即使我们提取出一个方法，我们还是要在两个地方调用它。而 <strong>useEffect 会在第一次渲染之后和每次更新之后都会执行</strong></li>
</ul>
<pre><code class="language-javascript">class Counter extends React.Component {
  state = { number: 0 };
  add = () =&gt; {
    this.setState({ number: this.state.number + 1 });
  };
  componentDidMount() {
    this.changeTitle();
  }
  componentDidUpdate() {
    this.changeTitle();
  }
  changeTitle = () =&gt; {
    document.title = `你已经点击了${this.state.number}次`;
  };
  render() {
    return (
      &lt;&gt;
        &lt;p&gt;{this.state.number}&lt;/p&gt;
        &lt;button onClick={this.add}&gt;+&lt;/button&gt;
      &lt;/&gt;
    );
  }
}
</code></pre>
<h3 id="72-使用-useeffect-来实现修改标题"><a class="header" href="#72-使用-useeffect-来实现修改标题">7.2 使用 useEffect 来实现修改标题</a></h3>
<ul>
<li>每次我们重新渲染，都会生成新的 effect，替换掉之前的。某种意义上讲，effect 更像是渲染结果的一部分 —— 每个 effect 属于一次特定的渲染。</li>
</ul>
<pre><code class="language-javascript">import React, { Component, useState, useEffect } from &quot;react&quot;;
import ReactDOM from &quot;react-dom&quot;;
function Counter() {
  const [number, setNumber] = useState(0);
  // useEffect里面的这个函数会在第一次渲染之后和更新完成后执行
  // 相当于 componentDidMount 和 componentDidUpdate:
  useEffect(() =&gt; {
    document.title = `你点击了${number}次`;
  });
  return (
    &lt;&gt;
      &lt;p&gt;{number}&lt;/p&gt;
      &lt;button onClick={() =&gt; setNumber(number + 1)}&gt;+&lt;/button&gt;
    &lt;/&gt;
  );
}
ReactDOM.render(&lt;Counter /&gt;, document.getElementById(&quot;root&quot;));
</code></pre>
<h3 id="73-清除副作用"><a class="header" href="#73-清除副作用">7.3 清除副作用</a></h3>
<ul>
<li><strong>副作用函数还可以通过返回一个函数来指定如何清除副作用，为防止内存泄漏，清除函数会在组件卸载前执行。如果组件多次渲染，则在执行下一个 effect 之前，上一个 effect 就已被清除。</strong></li>
</ul>
<pre><code class="language-javascript">function Counter() {
  let [number, setNumber] = useState(0);
  let [text, setText] = useState(&quot;&quot;);
  // 相当于componentDidMount 和 componentDidUpdate
  useEffect(() =&gt; {
    console.log(&quot;开启一个新的定时器&quot;);
    let $timer = setInterval(() =&gt; {
      setNumber((number) =&gt; number + 1);
    }, 1000);
    // useEffect 如果返回一个函数的话，该函数会在组件卸载和更新时调用
    // useEffect 在执行副作用函数之前，会先调用上一次返回的函数
    // 如果要清除副作用，要么返回一个清除副作用的函数
    /*  return ()=&gt;{
            console.log('destroy effect');
            clearInterval($timer);
        } */
  });
  // },[]);//要么在这里传入一个空的依赖项数组，这样就不会去重复执行
  return (
    &lt;&gt;
      &lt;input value={text} onChange={(event) =&gt; setText(event.target.value)} /&gt;
      &lt;p&gt;{number}&lt;/p&gt;
      &lt;button&gt;+&lt;/button&gt;
    &lt;/&gt;
  );
}
</code></pre>
<h3 id="74-跳过-effect-进行性能优化"><a class="header" href="#74-跳过-effect-进行性能优化">7.4 跳过 effect 进行性能优化</a></h3>
<ul>
<li>依赖项数组控制着 useEffect 的执行</li>
<li>如果某些特定值在两次重渲染之间没有发生变化，你可以通知 React 跳过对 effect 的调用，只要传递数组作为 useEffect 的第二个可选参数即可</li>
<li>如果想执行只运行一次的 effect（仅在组件挂载和卸载时执行），可以传递一个空数组（[]）作为第二个参数。这就告诉 React 你的 effect 不依赖于 props 或 state
中的任何值，所以它永远都不需要重复执行</li>
<li>推荐启用
<a href="https://www.npmjs.com/package/eslint-plugin-react-hooks#installation">eslint-plugin-react-hooks</a>
中的 <a href="https://github.com/facebook/react/issues/14920">exhaustive-deps</a> 规则。此规则会在添加错误依赖时发出警告并给出修复建议。</li>
</ul>
<pre><code class="language-javascript">function Counter() {
  let [number, setNumber] = useState(0);
  let [text, setText] = useState(&quot;&quot;);
  // 相当于componentDidMount 和 componentDidUpdate
  useEffect(() =&gt; {
    console.log(&quot;useEffect&quot;);
    let $timer = setInterval(() =&gt; {
      setNumber((number) =&gt; number + 1);
    }, 1000);
  }, [text]); // 数组表示 effect 依赖的变量，只有当这个变量发生改变之后才会重新执行 efffect 函数
  return (
    &lt;&gt;
      &lt;input value={text} onChange={(event) =&gt; setText(event.target.value)} /&gt;
      &lt;p&gt;{number}&lt;/p&gt;
      &lt;button&gt;+&lt;/button&gt;
    &lt;/&gt;
  );
}
</code></pre>
<h3 id="75-使用多个-effect-实现关注点分离"><a class="header" href="#75-使用多个-effect-实现关注点分离">7.5 使用多个 Effect 实现关注点分离</a></h3>
<ul>
<li>使用 Hook 其中一个目的就是要解决 class 中生命周期函数经常包含不相关的逻辑，但又把相关逻辑分离到了几个不同方法中的问题。</li>
</ul>
<pre><code class="language-javascript">// 类组件版
class FriendStatusWithCounter extends React.Component {
  constructor(props) {
    super(props);
    this.state = { count: 0, isOnline: null };
    this.handleStatusChange = this.handleStatusChange.bind(this);
  }

  componentDidMount() {
    document.title = `You clicked ${this.state.count} times`;
    ChatAPI.subscribeToFriendStatus(
      this.props.friend.id,
      this.handleStatusChange
    );
  }

  componentDidUpdate() {
    document.title = `You clicked ${this.state.count} times`;
  }

  componentWillUnmount() {
    ChatAPI.unsubscribeFromFriendStatus(
      this.props.friend.id,
      this.handleStatusChange
    );
  }

  handleStatusChange(status) {
    this.setState({
      isOnline: status.isOnline
    });
  }
  // ...
</code></pre>
<ul>
<li>可以发现设置 <code>document.title</code> 的逻辑是如何被分割到 <code>componentDidMount</code> 和 <code>componentDidUpdate</code> 中的，订阅逻辑又是如何被分割到
<code>componentDidMount</code> 和 <code>componentWillUnmount</code> 中的。而且 <code>componentDidMount</code>
中同时包含了两个不同功能的代码。这样会使得生命周期函数很混乱。</li>
<li><strong>Hook 允许我们按照代码的用途分离他们，</strong> 而不是像生命周期函数那样。React 将按照 effect 声明的顺序依次调用组件中的 每一个 effect。</li>
</ul>
<pre><code class="language-javascript">// Hooks 版
function FriendStatusWithCounter(props) {
  const [count, setCount] = useState(0);
  useEffect(() =&gt; {
    document.title = `You clicked ${count} times`;
  });

  const [isOnline, setIsOnline] = useState(null);
  useEffect(() =&gt; {
    function handleStatusChange(status) {
      setIsOnline(status.isOnline);
    }

    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
    return () =&gt; {
      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
    };
  });
  // ...
}
</code></pre>
<h2 id="八uselayouteffect"><a class="header" href="#八uselayouteffect">八、useLayoutEffect</a></h2>
<p><img src="React/./images/useLayoutEffect.png" alt="img" /></p>
<ul>
<li><strong>useEffect 在全部渲染完毕后才会执行</strong></li>
<li><strong>useLayoutEffect 会在 浏览器 layout 之后，painting 之前执行</strong></li>
<li>其函数签名与 useEffect 相同，但它会在所有的 DOM 变更之后<strong>同步</strong>调用 effect</li>
<li><strong>可以使用它来读取 DOM 布局并同步触发重渲染</strong></li>
<li>在浏览器执行绘制之前 useLayoutEffect 内部的更新计划将被<strong>同步</strong>刷新</li>
<li><strong>尽可能使用标准的 useEffect 以避免阻塞视图更新</strong></li>
</ul>
<pre><code class="language-javascript">function LayoutEffect() {
  const [color, setColor] = useState(&quot;red&quot;);
  useLayoutEffect(() =&gt; {
    alert(color);
  });
  useEffect(() =&gt; {
    console.log(&quot;color&quot;, color);
  });
  return (
    &lt;&gt;
      &lt;div id=&quot;myDiv&quot; style={{ background: color }}&gt;
        颜色
      &lt;/div&gt;
      &lt;button onClick={() =&gt; setColor(&quot;red&quot;)}&gt;红&lt;/button&gt;
      &lt;button onClick={() =&gt; setColor(&quot;yellow&quot;)}&gt;黄&lt;/button&gt;
      &lt;button onClick={() =&gt; setColor(&quot;blue&quot;)}&gt;蓝&lt;/button&gt;
    &lt;/&gt;
  );
}
</code></pre>
<h2 id="九useref--useimperativehandle"><a class="header" href="#九useref--useimperativehandle">九、useRef &amp; useImperativeHandle</a></h2>
<h3 id="81-useref"><a class="header" href="#81-useref">8.1 useRef</a></h3>
<ul>
<li>类组件、React 元素用 React.createRef，函数组件使用 useRef</li>
<li>useRef 返回一个可变的 ref 对象，其 <code>current</code> 属性被初始化为传入的参数（initialValue）</li>
</ul>
<pre><code class="language-javascript">const refContainer = useRef(initialValue);
</code></pre>
<ul>
<li><strong>useRef 返回的 ref 对象在组件的整个生命周期内保持不变，也就是说每次重新渲染函数组件时，返回的 ref 对象都是同一个（使用 React.createRef
，每次重新渲染组件都会重新创建 ref）</strong></li>
</ul>
<pre><code class="language-javascript">import React, { useState, useEffect, useRef } from &quot;react&quot;;
import ReactDOM from &quot;react-dom&quot;;
function Parent() {
  let [number, setNumber] = useState(0);
  return (
    &lt;&gt;
      &lt;Child /&gt;
      &lt;button onClick={() =&gt; setNumber({ number: number + 1 })}&gt;+&lt;/button&gt;
    &lt;/&gt;
  );
}
let input;
function Child() {
  const inputRef = useRef();
  console.log(&quot;input===inputRef&quot;, input === inputRef);
  input = inputRef;
  function getFocus() {
    inputRef.current.focus();
  }
  return (
    &lt;&gt;
      &lt;input type=&quot;text&quot; ref={inputRef} /&gt;
      &lt;button onClick={getFocus}&gt;获得焦点&lt;/button&gt;
    &lt;/&gt;
  );
}
ReactDOM.render(&lt;Parent /&gt;, document.getElementById(&quot;root&quot;));
</code></pre>
<h3 id="82-forwardref"><a class="header" href="#82-forwardref">8.2 forwardRef</a></h3>
<ul>
<li><strong>因为函数组件没有实例，所以函数组件无法像类组件一样可以接收 ref 属性</strong></li>
</ul>
<pre><code class="language-javascript">function Parent() {
  return (
    &lt;&gt;
      // &lt;Child ref={xxx} /&gt; 这样是不行的
      &lt;Child /&gt;
      &lt;button&gt;+&lt;/button&gt;
    &lt;/&gt;
  );
}
</code></pre>
<ul>
<li><strong>forwardRef 可以在父组件中操作子组件的 ref 对象</strong></li>
<li><strong>forwardRef 可以将父组件中的 ref 对象转发到子组件中的 dom 元素上</strong></li>
<li><strong>子组件接受 props 和 ref 作为参数</strong></li>
</ul>
<pre><code class="language-javascript">function Child(props, ref) {
  return &lt;input type=&quot;text&quot; ref={ref} /&gt;;
}
Child = React.forwardRef(Child);
function Parent() {
  let [number, setNumber] = useState(0);
  // 在使用类组件的时候，创建 ref 返回一个对象，该对象的 current 属性值为空
  // 只有当它被赋给某个元素的 ref 属性时，才会有值
  // 所以父组件（类组件）创建一个 ref 对象，然后传递给子组件（类组件），子组件内部有元素使用了
  // 那么父组件就可以操作子组件中的某个元素
  // 但是函数组件无法接收 ref 属性 &lt;Child ref={xxx} /&gt; 这样是不行的
  // 所以就需要用到 forwardRef 进行转发
  const inputRef = useRef(); //{current:''}
  function getFocus() {
    inputRef.current.value = &quot;focus&quot;;
    inputRef.current.focus();
  }
  return (
    &lt;&gt;
      &lt;Child ref={inputRef} /&gt;
      &lt;button onClick={() =&gt; setNumber({ number: number + 1 })}&gt;+&lt;/button&gt;
      &lt;button onClick={getFocus}&gt;获得焦点&lt;/button&gt;
    &lt;/&gt;
  );
}
</code></pre>
<h3 id="83-useimperativehandle"><a class="header" href="#83-useimperativehandle">8.3 useImperativeHandle</a></h3>
<ul>
<li><code>useImperativeHandle</code>可以让你在使用 ref 时，自定义暴露给父组件的实例值，不能让父组件想干嘛就干嘛</li>
<li><strong>在大多数情况下，应当避免使用 ref 这样的命令式代码。useImperativeHandle 应当与 forwardRef 一起使用</strong></li>
<li><strong>父组件可以使用操作子组件中的多个 ref</strong></li>
</ul>
<pre><code class="language-javascript">import React,{useState,useEffect,createRef,useRef,forwardRef,useImperativeHandle} from 'react';

function Child(props,parentRef){
    // 子组件内部自己创建 ref
    let focusRef = useRef();
    let inputRef = useRef();
    useImperativeHandle(parentRef,()=&gt;(
      // 这个函数会返回一个对象
      // 该对象会作为父组件 current 属性的值
      // 通过这种方式，父组件可以使用操作子组件中的多个 ref
        return {
            focusRef,
            inputRef,
            name:'计数器',
            focus(){
                focusRef.current.focus();
            },
            changeText(text){
                inputRef.current.value = text;
            }
        }
    });
    return (
        &lt;&gt;
            &lt;input ref={focusRef}/&gt;
            &lt;input ref={inputRef}/&gt;
        &lt;/&gt;
    )

}
Child = forwardRef(Child);
function Parent(){
  const parentRef = useRef();//{current:''}
  function getFocus(){
    parentRef.current.focus();
    // 因为子组件中没有定义这个属性，实现了保护，所以这里的代码无效
    parentRef.current.addNumber(666);
    parentRef.current.changeText('&lt;script&gt;alert(1)&lt;/script&gt;');
    console.log(parentRef.current.name);
  }
  return (
      &lt;&gt;
        &lt;ForwardChild ref={parentRef}/&gt;
        &lt;button onClick={getFocus}&gt;获得焦点&lt;/button&gt;
      &lt;/&gt;
  )
}
</code></pre>
<h2 id="十自定义-hook"><a class="header" href="#十自定义-hook">十、自定义 Hook</a></h2>
<ul>
<li>自定义 Hook 更像是一种约定，而不是一种功能。如果函数的名字以 use 开头，并且调用了其他的 Hook，则就称其为一个自定义 Hook</li>
<li>有时候我们会想要在组件之间重用一些状态逻辑，之前要么用 render props ，要么用高阶组件，要么使用 redux</li>
<li>自定义 Hook 可以让你在不增加组件的情况下达到同样的目的</li>
<li><strong>Hook 是一种复用状态逻辑的方式，它不复用 state 本身</strong></li>
<li><strong>事实上 Hook 的每次调用都有一个完全独立的 state</strong></li>
</ul>
<pre><code class="language-javascript">import React, { useLayoutEffect, useEffect, useState } from &quot;react&quot;;
import ReactDOM from &quot;react-dom&quot;;

function useNumber() {
  let [number, setNumber] = useState(0);
  useEffect(() =&gt; {
    setInterval(() =&gt; {
      setNumber((number) =&gt; number + 1);
    }, 1000);
  }, []);
  return [number, setNumber];
}
// 每个组件调用同一个 hook，只是复用 hook 的状态逻辑，并不会共用一个状态
function Counter1() {
  let [number, setNumber] = useNumber();
  return (
    &lt;div&gt;
      &lt;button
        onClick={() =&gt; {
          setNumber(number + 1);
        }}
      &gt;
        {number}
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
function Counter2() {
  let [number, setNumber] = useNumber();
  return (
    &lt;div&gt;
      &lt;button
        onClick={() =&gt; {
          setNumber(number + 1);
        }}
      &gt;
        {number}
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
ReactDOM.render(
  &lt;&gt;
    &lt;Counter1 /&gt;
    &lt;Counter2 /&gt;
  &lt;/&gt;,
  document.getElementById(&quot;root&quot;)
);
</code></pre>
<h2 id="十一常见问题"><a class="header" href="#十一常见问题">十一、常见问题</a></h2>
<h3 id="1-使用-a-hrefhttpswwwnpmjscompackageeslint-plugin-react-hookseslint-plugin-react-hooksa-来检查代码错误给出提示"><a class="header" href="#1-使用-a-hrefhttpswwwnpmjscompackageeslint-plugin-react-hookseslint-plugin-react-hooksa-来检查代码错误给出提示">1. 使用 <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks">eslint-plugin-react-hooks</a> 来检查代码错误，给出提示</a></h3>
<pre><code class="language-json">{
  &quot;plugins&quot;: [&quot;react-hooks&quot;],
  // ...
  &quot;rules&quot;: {
    &quot;react-hooks/rules-of-hooks&quot;: &quot;error&quot;, // 检查 Hook 的规则
    &quot;react-hooks/exhaustive-deps&quot;: &quot;warn&quot; // 检查 effect 的依赖
  }
}
</code></pre>
<h3 id="2为什么每次更新的时候都要运行-effect"><a class="header" href="#2为什么每次更新的时候都要运行-effect">2.为什么每次更新的时候都要运行 Effect</a></h3>
<p><a href="https://react.docschina.org/docs/hooks-effect.html#explanation-why-effects-run-on-each-update">react.docschina.org/docs/hooks-…</a></p>
<h3 id="3为什么必须在组件的顶层使用-hook--在单个组件中使用多个-state-hook-或-effect-hook那么-react-怎么知道哪个-state-对应哪个-usestate"><a class="header" href="#3为什么必须在组件的顶层使用-hook--在单个组件中使用多个-state-hook-或-effect-hook那么-react-怎么知道哪个-state-对应哪个-usestate">3.为什么必须在组件的顶层使用 Hook &amp; 在单个组件中使用多个 State Hook 或 Effect Hook，那么 React 怎么知道哪个 state 对应哪个 useState？</a></h3>
<ul>
<li><strong>React 依赖于 Hook 的调用顺序</strong>，如果能确保 Hook 在每一次渲染中都按照同样的顺序被调用。那么 React 能够在多次的 <code>useState</code> 和 <code>useEffect</code>
调用之间保持 hook 状态的正确性</li>
</ul>
<pre><code class="language-javascript">function Form() {
  // 1. Use the name state variable
  const [name, setName] = useState(&quot;Mary&quot;);

  // 2. Use an effect for persisting the form
  useEffect(function persistForm() {
    localStorage.setItem(&quot;formData&quot;, name);
  });

  // 3. Use the surname state variable
  const [surname, setSurname] = useState(&quot;Poppins&quot;);

  // 4. Use an effect for updating the title
  useEffect(function updateTitle() {
    document.title = name + &quot; &quot; + surname;
  });

  // ...
}

// ------------
// 首次渲染
// ------------
useState(&quot;Mary&quot;); // 1. 使用 'Mary' 初始化变量名为 name 的 state
useEffect(persistForm); // 2. 添加 effect 以保存 form 操作
useState(&quot;Poppins&quot;); // 3. 使用 'Poppins' 初始化变量名为 surname 的 state
useEffect(updateTitle); // 4. 添加 effect 以更新标题
// -------------
// 二次渲染
// -------------
useState(&quot;Mary&quot;); // 1. 读取变量名为 name 的 state（参数被忽略）
useEffect(persistForm); // 2. 替换保存 form 的 effect
useState(&quot;Poppins&quot;); // 3. 读取变量名为 surname 的 state（参数被忽略）
useEffect(updateTitle); // 4. 替换更新标题的 effect
// ...
</code></pre>
<p><strong>只要 Hook 的调用顺序在多次渲染之间保持一致，React 就能正确地将内部 state 和对应的 Hook 进行关联</strong>。但如果我们将一个 Hook (例如 <code>persistForm</code>
effect) 调用放到一个条件语句中会发生什么呢？</p>
<pre><code>// 🔴 在条件语句中使用 Hook 违反第一条规则
  if (name !== '') {
    useEffect(function persistForm() {
      localStorage.setItem('formData', name);
    });
  }
</code></pre>
<p>在第一次渲染中 <code>name !== ''</code> 这个条件值为 <code>true</code>，所以我们会执行这个 Hook。但是下一次渲染时我们可能清空了表单，表达式值变为 <code>false</code>。此时的渲染会跳过该
Hook，Hook 的调用顺序发生了改变：</p>
<pre><code class="language-javascript">useState(&quot;Mary&quot;); // 1. 读取变量名为 name 的 state（参数被忽略）
// useEffect(persistForm)  // 🔴 此 Hook 被忽略！
useState(&quot;Poppins&quot;); // 🔴 2 （之前为 3）。读取变量名为 surname 的 state 失败
useEffect(updateTitle); // 🔴 3 （之前为 4）。替换更新标题的 effect 失败
</code></pre>
<p>React 不知道第二个 <code>useState</code> 的 Hook 应该返回什么。React 会以为在该组件中第二个 Hook 的调用像上次的渲染一样，对应得是 <code>persistForm</code> 的
effect，但并非如此。从这里开始，后面的 Hook 调用都被提前执行，导致 bug 的产生。</p>
<p>如果我们想要有条件地执行一个 effect，可以将判断放到 Hook 的_内部_：</p>
<pre><code class="language-javascript">useEffect(function persistForm() {
  // 👍 将条件判断放置在 effect 中
  if (name !== &quot;&quot;) {
    localStorage.setItem(&quot;formData&quot;, name);
  }
});
</code></pre>
<h3 id="4-自定义-hook-必须以-use-开头吗"><a class="header" href="#4-自定义-hook-必须以-use-开头吗">4. <strong>自定义 Hook 必须以 <code>use</code> 开头吗？</strong></a></h3>
<p>必须如此。这个约定非常重要。不遵循的话，由于无法判断某个函数是否包含对其内部 Hook 的调用，React 将无法自动检查你的 Hook 是否违反了
<a href="https://react.docschina.org/docs/hooks-rules.html">Hook 的规则</a>。</p>
<h3 id="5-在两个组件中使用相同的-hook-会共享-state-吗"><a class="header" href="#5-在两个组件中使用相同的-hook-会共享-state-吗">5. <strong>在两个组件中使用相同的 Hook 会共享 state 吗？</strong></a></h3>
<p>不会。自定义 Hook 是一种重用_状态逻辑_的机制(例如设置为订阅并存储当前值)，所以每次使用自定义 Hook 时，其中的所有 state 和副作用都是完全隔离的。</p>
<h3 id="6-在一个组件中多次调用-usestate-或者-useeffect每次调用-hook它都会获取独立的-state是完全独立的"><a class="header" href="#6-在一个组件中多次调用-usestate-或者-useeffect每次调用-hook它都会获取独立的-state是完全独立的">6. 在一个组件中多次调用 <code>useState</code> 或者 <code>useEffect</code>，每次调用 Hook，它都会获取独立的 state，是完全独立的</a></h3>
<h3 id="7-当组件拥有多个-state-时应该把多个-state-合并成一个-state-还是把-state-切分成多个-state-变量"><a class="header" href="#7-当组件拥有多个-state-时应该把多个-state-合并成一个-state-还是把-state-切分成多个-state-变量">7. 当组件拥有多个 state 时，应该把多个 state 合并成一个 state ，还是把 state 切分成多个 state 变量？</a></h3>
<p><a href="https://react.docschina.org/docs/hooks-faq.html#should-i-use-one-or-many-state-variables">react.docschina.org/docs/hooks-…</a></p>
<ul>
<li>要么把所有 state 都放在同一个 <code>useState</code> 调用中，要么每一个字段都对应一个 <code>useState</code> 调用，这两方式都能跑通。</li>
<li>当你在这<strong>两个极端</strong>之间找到平衡，然后把<strong>相关 state</strong> <strong>组合到几个独立的 state 变量</strong>时，组件就会更加的可读。如果 state 的逻辑开始变得复杂，我们推荐用
<code>useReducer</code> 来管理它，或使用自定义 Hook。</li>
</ul>
<h3 id="8-可以只在更新时运行-effect-吗"><a class="header" href="#8-可以只在更新时运行-effect-吗">8. 可以只在更新时运行 effect 吗？</a></h3>
<p>这是个比较罕见的使用场景。如果你需要的话，你可以
<a href="https://react.docschina.org/docs/hooks-faq.html#is-there-something-like-instance-variables">使用一个可变的 ref</a>
手动存储一个布尔值来表示是首次渲染还是后续渲染，然后在你的 effect 中检查这个标识。（如果你发现自己经常在这么做，你可以为之创建一个自定义 Hook。）</p>
<h3 id="9-在-useeffect-中调用用函数时要把该函数在-useeffect-中申明不能放到外部申明然后再在-useeffect-中调用"><a class="header" href="#9-在-useeffect-中调用用函数时要把该函数在-useeffect-中申明不能放到外部申明然后再在-useeffect-中调用">9. 在 useEffect 中调用用函数时，要把该函数在 useEffect 中申明，不能放到外部申明，然后再在 useEffect 中调用</a></h3>
<p><a href="https://react.docschina.org/docs/hooks-faq.html#is-it-safe-to-omit-functions-from-the-list-of-dependencies">react.docschina.org/docs/hooks-…</a></p>
<pre><code class="language-javascript">function Example({ someProp }) {
  function doSomething() {
    console.log(someProp);
  }

  useEffect(() =&gt; {
    doSomething();
  }, []); // 🔴 这样不安全（它调用的 `doSomething` 函数使用了 `someProp`）
}
</code></pre>
<p>要记住 effect 外部的函数使用了哪些 props 和 state 很难。这也是为什么 <strong>通常你会想要在 effect 内部 去声明它所需要的函数。</strong> 这样就能容易的看出那个 effect
依赖了组件作用域中的哪些值：</p>
<pre><code class="language-javascript">function Example({ someProp }) {
  useEffect(() =&gt; {
    function doSomething() {
      console.log(someProp);
    }

    doSomething();
  }, [someProp]); // ✅ 安全（我们的 effect 仅用到了 `someProp`）
}
</code></pre>
<p><strong>只有</strong> 当函数（以及它所调用的函数）不引用 props、state 以及由它们衍生而来的值时，你才能放心地把它们从依赖列表中省略。下面这个案例有一个 Bug：</p>
<pre><code class="language-javascript">function ProductPage({ productId }) {
  const [product, setProduct] = useState(null);
  async function fetchProduct() {
    const response = await fetch(&quot;http://myapi/product&quot; + productId); // 使用了 productId prop
    const json = await response.json();
    setProduct(json);
  }
  useEffect(() =&gt; {
    fetchProduct();
  }, []); // 🔴 这样是无效的，因为 `fetchProduct` 使用了 `productId`
  // ...
}
</code></pre>
<p><strong>推荐的修复方案是把那个函数移动到你的 effect 内部</strong>。这样就能很容易的看出来你的 effect 使用了哪些 props 和 state，并确保它们都被声明了：</p>
<pre><code class="language-javascript">function ProductPage({ productId }) {
  const [product, setProduct] = useState(null);
  useEffect(() =&gt; {
    // 把这个函数移动到 effect 内部后，我们可以清楚地看到它用到的值。
    async function fetchProduct() {
      const response = await fetch(&quot;http://myapi/product&quot; + productId);
      const json = await response.json();
      setProduct(json);
    }
    fetchProduct();
  }, [productId]); // ✅ 有效，因为我们的 effect 只用到了 productId
  // ...
}
</code></pre>
<h3 id="10-如何在-hooks-中优雅的-fetch-data"><a class="header" href="#10-如何在-hooks-中优雅的-fetch-data">10. 如何在 Hooks 中优雅的 Fetch Data</a></h3>
<p><a href="https://www.robinwieruch.de/react-hooks-fetch-data/">www.robinwieruch.de/react-hooks…</a></p>
<p><a href="https://codesandbox.io/s/jvvkoo8pq3">codesandbox.io/s/jvvkoo8pq…</a></p>
<pre><code class="language-javascript">import React, { useState, useEffect } from 'react';
import axios from 'axios';
function App() {
  const [data, setData] = useState({ hits: [] });
  // 注意 async 的位置
  // 这种写法，虽然可以运行，但是会发出警告
  // 每个带有 async 修饰的函数都返回一个隐含的 promise
  // 但是 useEffect 函数有要求：要么返回清除副作用函数，要么就不返回任何内容
  useEffect(async () =&gt; {
    const result = await axios(
      'https://hn.algolia.com/api/v1/search?query=redux',
    );
    setData(result.data);
  }, []);
  return (
    &lt;ul&gt;
      {data.hits.map(item =&gt; (
        &lt;li key={item.objectID}&gt;
          &lt;a href={item.url}&gt;{item.title}&lt;/a&gt;
        &lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}
export default App;

import React, { useState, useEffect } from 'react';
import axios from 'axios';
function App() {
  const [data, setData] = useState({ hits: [] });
  useEffect(() =&gt; {
    // 更优雅的方式
    const fetchData = async () =&gt; {
      const result = await axios(
        'https://hn.algolia.com/api/v1/search?query=redux',
      );
      setData(result.data);
    };
    fetchData();
  }, []);
  return (
    &lt;ul&gt;
      {data.hits.map(item =&gt; (
        &lt;li key={item.objectID}&gt;
          &lt;a href={item.url}&gt;{item.title}&lt;/a&gt;
        &lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}
export default App;
</code></pre>
<h3 id="11-不要过度依赖-usememo"><a class="header" href="#11-不要过度依赖-usememo">11. 不要过度依赖 useMemo</a></h3>
<ul>
<li>
<p><code>useMemo</code> 本身也有开销。<code>useMemo</code> 会「记住」一些值，同时在后续 render
时，将依赖数组中的值取出来和上一次记录的值进行比较，如果不相等才会重新执行回调函数，否则直接返回「记住」的值。这个过程本身就会消耗一定的内存和计算资源。因此，过度使用 <code>useMemo</code>
可能会影响程序的性能。</p>
</li>
<li>
<p>在使用<code>useMemo</code> 前，应该先思考三个问题：</p>
<ul>
<li><strong>传递给 <code>useMemo</code> 的函数开销大不大？</strong> 有些计算开销很大，我们就需要「记住」它的返回值，避免每次 render
都去重新计算。如果你执行的操作开销不大，那么就不需要记住返回值。否则，使用 <code>useMemo</code> 本身的开销就可能超过重新计算这个值的开销。因此，对于一些简单的 JS 运算来说，我们不需要使用
<code>useMemo</code> 来「记住」它的返回值。</li>
<li><strong>返回的值是原始值吗？</strong> 如果计算出来的是<strong>基本类型</strong>的值（<code>string</code>、 <code>boolean</code> 、<code>null</code>、<code>undefined</code>
、<code>number</code>、<code>symbol</code>），那么每次比较都是相等的，下游组件就不会重新渲染；如果计算出来的是<strong>复杂类型</strong>的值（<code>object</code>、<code>array</code>），哪怕值不变，但是地址会发生变化，导致下游组件重新渲染。所以我们也需要「记住」这个值。</li>
<li><strong>在编写自定义 Hook 时，返回值一定要保持引用的一致性。</strong> 因为你无法确定外部要如何使用它的返回值。如果返回值被用做其他 Hook 的依赖，并且每次 re-render
时引用不一致（当值相等的情况），就可能会产生 bug。所以如果自定义 Hook 中暴露出来的值是 object、array、函数等，都应该使用 <code>useMemo</code>
。以确保当值相同时，引用不发生变化。</li>
</ul>
</li>
</ul>
<h3 id="12-useeffect-不能接收-async-作为回调函数"><a class="header" href="#12-useeffect-不能接收-async-作为回调函数">12. useEffect 不能接收 async 作为回调函数</a></h3>
<p>useEffect 接收的函数，要么返回一个能清除副作用的函数，要么就不返回任何内容。而 async 返回的是 promise。</p>
<p><a href="https://www.robinwieruch.de/react-hooks-fetch-data">www.robinwieruch.de/react-hooks…</a></p>
<p><img src="React/./images/useEffect_async.png" alt="image.png" /></p>
<h2 id="十二项目实战"><a class="header" href="#十二项目实战">十二、项目实战</a></h2>
<p><a href="https://github.com/yjdjiayou/react-hooks-qunar-demo"><strong>React Hooks 项目</strong></a></p>
<h2 id="十三参考"><a class="header" href="#十三参考">十三、参考</a></h2>
<p><strong><a href="https://react.docschina.org/docs/hooks-faq.html">官方提供的问题列表</a></strong></p>
<p><strong><a href="https://reactjs.org/docs/hooks-rules.html#explanation">React 使用规则</a></strong></p>
<p><strong><a href="https://juejin.im/post/6844903958968795149">React Hooks 你真的用对了吗？</a></strong></p>
<p><strong><a href="https://github.com/streamich/react-use">大量自定义 hooks 的</a>
<a href="https://github.com/streamich/react-use">仓库</a></strong></p>
<p><strong><a href="https://juejin.im/post/6844903861434449933">从 Preact 中了解 React 组件和 hooks 基本原理表</a></strong></p>
<p><strong><a href="https://juejin.im/post/6844903918577664007">2019 年了，整理了 N 个实用案例帮你快速迁移到 React Hooks</a></strong></p>
<h2 id="十四推荐阅读"><a class="header" href="#十四推荐阅读">十四、推荐阅读</a></h2>
<p><a href="https://juejin.im/post/6844904021233238024"><strong>你真的了解 React 生命周期吗</strong></a></p>
<p><strong><a href="https://juejin.im/post/6844904017487724557">React SSR 详解【近 1W 字】+ 2 个项目实战</a></strong></p>
<p><strong><a href="https://juejin.im/post/6844903966849892359">从 0 到 1 实现一款简易版 Webpack</a></strong></p>
<p><strong><a href="https://juejin.im/post/6844904023791796237">Webpack 设置环境变量的误区</a></strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vue2x-响应式原理"><a class="header" href="#vue2x-响应式原理">Vue2.x 响应式原理</a></h1>
<p>众所周知，Vue2.x 是基于 Object.defineProperty()来实现响应式的。</p>
<p>那么，defineProperty 是啥呢。</p>
<p>先附上 MDN
的连接<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">Object.defineProperty()</a></p>
<h2 id="objectdefineproperty"><a class="header" href="#objectdefineproperty">Object.defineProperty</a></h2>
<p>引用 MDN 的原话：</p>
<blockquote>
<p><code>Object.defineProperty()</code>方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。</p>
</blockquote>
<p>那么重点有两个：</p>
<ol>
<li>对象</li>
<li>定义新属性或修改现有属性</li>
</ol>
<p>那么什么叫<code>定义新属性或修改现有属性</code>呢？</p>
<p>我们来看看另外一个概念<code>属性描述符</code></p>
<h2 id="属性描述符"><a class="header" href="#属性描述符">属性描述符</a></h2>
<h3 id="描述符的介绍"><a class="header" href="#描述符的介绍">描述符的介绍</a></h3>
<p>对象里目前存在的属性描述符有两种主要形式：</p>
<ul>
<li>数据描述符：具有值的属性，该值可以是可写的，也可以是不可写的。</li>
<li>存取描述符：由 getter 和 setter 函数描述的属性。</li>
</ul>
<p>一个描述符只可能是二者之一，不可能同时是两者。即二选一。</p>
<p>上述两种描述符都是对象，共享以下可选键值。（默认值是指在使用 <code>Object.defineProperty()</code> 定义属性时的默认值）</p>
<table><thead><tr><th>键值</th><th>描述</th><th>默认值</th></tr></thead><tbody>
<tr><td>configurable</td><td>当且仅当该属性的 <code>configurable</code> 键值为 <code>true</code> 时，该属性的描述符才能够被改变，同时该属性也能从对应的对象上被删除。</td><td>false</td></tr>
<tr><td>enumerable</td><td>当且仅当该属性的 <code>enumerable</code> 键值为 <code>true</code> 时，该属性才会出现在对象的枚举属性中。</td><td>false</td></tr>
<tr><td>value</td><td>该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。</td><td>undefined</td></tr>
<tr><td>writable</td><td>当且仅当该属性的 <code>writable</code> 键值为 <code>true</code> 时，属性的值，也就是上面的 <code>value</code>，才能被赋值。</td><td>false</td></tr>
</tbody></table>
<blockquote>
<p>因为<code>enumerable</code>属性默认是 false，所以通过<code>Object.defineProperty()</code>定义的属性都是不会被<code>for...in</code>和<code>Object.keys</code>访问到。</p>
</blockquote>
<p>以下是存取描述符独有的：</p>
<table><thead><tr><th>键值</th><th>描述</th><th>默认值</th></tr></thead><tbody>
<tr><td>get</td><td>属性的 getter 函数，如果没有 getter，则为 <code>undefined</code>。当访问该属性时，会调用此函数。执行时不传入任何参数，但是会传入 <code>this</code> 对象（由于继承关系，这里的<code>this</code>并不一定是定义该属性的对象）。该函数的返回值会被用作属性的值。</td><td>undefined</td></tr>
<tr><td>get</td><td>属性的 setter 函数，如果没有 setter，则为 <code>undefined</code>。当属性值被修改时，会调用此函数。该方法接受一个参数（也就是被赋予的新值），会传入赋值时的 <code>this</code> 对象。</td><td>undefined</td></tr>
</tbody></table>
<p>可以看到，跟值相关的，默认值都是 undefined。跟<code>able</code>相关的，默认值都是 false。</p>
<h3 id="怎么区分描述符呢"><a class="header" href="#怎么区分描述符呢">怎么区分描述符呢？</a></h3>
<table><thead><tr><th align="center"></th><th align="center">configurable</th><th align="center">enumerable</th><th align="center">value</th><th align="center">writable</th><th align="center">get</th><th align="center">set</th></tr></thead><tbody>
<tr><td align="center">数据描述符</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">×</td><td align="center">×</td></tr>
<tr><td align="center">存取描述符</td><td align="center">√</td><td align="center">√</td><td align="center">×</td><td align="center">×</td><td align="center">√</td><td align="center">√</td></tr>
</tbody></table>
<p>如果一个描述符不具有 <code>value</code>、<code>writable</code>、<code>get</code> 和 <code>set</code> 中的任意一个键，那么它将被认为是一个数据描述符。如果一个描述符同时拥有 <code>value</code> 或 <code>writable</code>
和 <code>get</code> 或 <code>set</code> 键，则会产生一个异常。</p>
<p>了解到这里已经够我们去理解 Vue2.x 的响应式原理了。</p>
<p>我们再填一下上面的坑：</p>
<p>如果对象中不存在指定的属性，<code>Object.defineProperty()</code> 会创建这个属性。当描述符中省略某些字段时，这些字段将使用它们的默认值。 搬一下 MDN 的代码：</p>
<pre><code class="language-javascript">var o = {}; // 创建一个新对象

// 在对象中添加一个属性与数据描述符的示例
Object.defineProperty(o, &quot;a&quot;, {
  value: 37,
  writable: true,
  enumerable: true,
  configurable: true,
});

// 对象 o 拥有了属性 a，值为 37

// 在对象中添加一个设置了存取描述符属性的示例
var bValue = 38;
Object.defineProperty(o, &quot;b&quot;, {
  // 使用了方法名称缩写（ES2015 特性）
  // 下面两个缩写等价于：
  // get : function() { return bValue; },
  // set : function(newValue) { bValue = newValue; },
  get() {
    return bValue;
  },
  set(newValue) {
    bValue = newValue;
  },
  enumerable: true,
  configurable: true,
});

o.b; // 38
// 对象 o 拥有了属性 b，值为 38
// 现在，除非重新定义 o.b，o.b 的值总是与 bValue 相同

// 数据描述符和存取描述符不能混合使用
Object.defineProperty(o, &quot;conflict&quot;, {
  value: 0x9f91102,
  get() {
    return 0xdeadbeef;
  },
});
// 抛出错误 TypeError: value appears only in data descriptors, get appears only in accessor descriptors
</code></pre>
<h2 id="响应式原理"><a class="header" href="#响应式原理">响应式原理</a></h2>
<p>所谓响应式，即，一个值变化的时候要根据这个变化，产生相应的行为。</p>
<p>在浏览器上，dom 渲染完成之后，那么如果你不主动通过 dom 修改操作来重新渲染，那么这个 dom 就永远不变了。 那如果 dom 上渲染的是 X 的值，X 变了怎么办呢。难不成你每次给 X
赋值的时候，都手动 document.balabala 吗？</p>
<p>看过上面的 set 属性之后你可能就想明白了，重点再复习一下：</p>
<p><strong>当属性值被修改时，会调用此函数。</strong></p>
<p>锵锵锵，简单来说就是用<code>get</code>和<code>set</code>来实现的啦。</p>
<h3 id="简单实现"><a class="header" href="#简单实现">简单实现</a></h3>
<p>话不多说，直接上代码 。</p>
<pre><code class="language-javascript">let x;

let f = function (v) {
  return v * 100;
};

// 变化之后的处理函数
let active;

const onXChange = (cb) =&gt; {
  active = cb;
  // 初始化的时候就需要执行一次
  active();
};

// 工厂
const ref = (value) =&gt; {
  let initValue = value;
  return Object.defineProperty({}, &quot;value&quot;, {
    get() {
      return initValue;
    },
    set(newVal) {
      initValue = newVal;
      active();
    },
  });
};

// 初始化
x = ref(1);

// 添加回调
onXChange(() =&gt; {
  console.log(f(x.value));
});

x.value = 2;
x.value = 3;
</code></pre>
<p>上述的写法有点问题。如果，不光是一个 callback，有多个 callback 如何处理？</p>
<p>一个 active 不够用。所以我们需要一个地方进行依赖收集。（即，多个组件依赖这个数据，每个组件都需要进行变化。）</p>
<h3 id="带依赖收集"><a class="header" href="#带依赖收集">带依赖收集</a></h3>
<p>变化后的代码如下：</p>
<pre><code class="language-javascript">/* eslint-disable no-debugger */
let x;

let f = function (v) {
  return v * 100;
};

let active;

const onXChange = (cb) =&gt; {
  active = cb;
  active();
  active = null;
};
class Dep {
  deps = new Set();
  depend() {
    if (active) {
      this.deps.add(active);
    }
  }
  notify() {
    this.deps.forEach((dep) =&gt; dep());
  }
}

const ref = (value) =&gt; {
  let initValue = value;
  let deps = new Dep();

  return Object.defineProperty({}, &quot;value&quot;, {
    get() {
      deps.depend();
      return initValue;
    },
    set(newVal) {
      initValue = newVal;
      deps.notify();
    },
  });
};

x = ref(1);

onXChange(() =&gt; {
  console.log(f(x.value));
});

onXChange(() =&gt; {
  console.log(x.value + 1);
});

x.value = 2;
x.value = 3;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="异步更新队列"><a class="header" href="#异步更新队列">异步更新队列</a></h1>
<p>在上面 Vue2.x 响应式原理的代码里还是有点问题的。</p>
<p>先捞一遍代码：</p>
<pre><code class="language-javascript">let x;

let f = function (v) {
  return v * 100;
};

let active;

const onXChange = (cb) =&gt; {
  active = cb;
  active();
  active = null;
};
class Dep {
  deps = new Set();
  depend() {
    if (active) {
      this.deps.add(active);
    }
  }
  notify() {
    this.deps.forEach((dep) =&gt; dep());
  }
}

const ref = (value) =&gt; {
  let initValue = value;
  let deps = new Dep();

  return Object.defineProperty({}, &quot;value&quot;, {
    get() {
      deps.depend();
      return initValue;
    },
    set(newVal) {
      initValue = newVal;
      deps.notify();
    },
  });
};

x = ref(1);

onXChange(() =&gt; {
  console.log(f(x.value));
});

x.value = 2;
x.value = 3;
</code></pre>
<h2 id="依赖多个变量的情况下的性能问题"><a class="header" href="#依赖多个变量的情况下的性能问题">依赖多个变量的情况下的性能问题</a></h2>
<p>简单删减一波，然后让模板依赖于三个变量：</p>
<pre><code class="language-javascript">let active;

const watch = (cb) =&gt; {
  active = cb;
  active();
  active = null;
};
class Dep {
  deps = new Set();
  depend() {
    if (active) {
      this.deps.add(active);
    }
  }
  notify() {
    this.deps.forEach((dep) =&gt; dep());
  }
}

const ref = (value) =&gt; {
  let initValue = value;
  let deps = new Dep();

  return Object.defineProperty({}, &quot;value&quot;, {
    get() {
      deps.depend();
      return initValue;
    },
    set(newVal) {
      initValue = newVal;
      deps.notify();
    },
  });
};

let x = ref(1);
let y = ref(2);
let z = ref(3);

watch(() =&gt; {
  let str = `${x.value} --- ${y.value} --- ${z.value}`;
  document.write(str);
  console.log(str);
});

x.value = 2;
y.value = 3;
z.value = 3;
</code></pre>
<p>打开控制台你会发现，每一次值变化的时候，都会触发一次<code>onXChange</code>。</p>
<p>那么问题来了。如果在一个函数中，修改了多个变量，那岂不是页面就要进行多次渲染吗？那么性能肯定下降了。</p>
<p>那么这怎么办呢。</p>
<h2 id="异步更新队列-1"><a class="header" href="#异步更新队列-1">异步更新队列</a></h2>
<p>那么就得用到异步更新队列了。</p>
<p>我们知道 JavaScript 有宏任务和微任务。所有的微任务都是在宏任务执行完成之后再执行的。</p>
<p>那么我们可以定义一个<code>nextTick</code>函数，用来在宏任务执行完成之后执行微任务。 即，在所有的赋值完成之后，再执行<code>onChange</code>方法。</p>
<pre><code class="language-javascript">const netxtTick = (cb) =&gt; Promise.resolve().then(cb);
</code></pre>
<p>我们还需要一个队列用来保证先进来的<code>onChange</code>先执行：</p>
<pre><code class="language-javascript">let queue = [];
// 增加任务的方法
let queueJob = (job) =&gt; {
  // 如果任务已经被添加过，则不添加了
  if (!queue.includes(job)) {
    queue.push(job);
    // 在微任务中执行所有回调
    nextTick(flushJobs);
  }
};
// 执行任务的方法
let flushJobs = () =&gt; {
  let job;
  // 如果队列中第一个始终有任务，则取出来执行
  while ((job = queue.shift()) !== undefined) {
    job();
  }
};
</code></pre>
<p>整体代码如下：</p>
<pre><code class="language-javascript">let active;

const watch = (cb) =&gt; {
  active = cb;
  active();
  active = null;
};

let nextTick = (cb) =&gt; Promise.resolve().then(cb);

let queue = [];
let queueJob = (job) =&gt; {
  if (!queue.includes(job)) {
    queue.push(job);
    nextTick(flushJobs);
  }
};
let flushJobs = () =&gt; {
  let job;
  while ((job = queue.shift()) !== undefined) {
    job();
  }
};
class Dep {
  deps = new Set();
  depend() {
    if (active) {
      this.deps.add(active);
    }
  }
  notify() {
    // 注意notify内部变更了
    this.deps.forEach((dep) =&gt; queueJob(dep));
  }
}

const ref = (value) =&gt; {
  let initValue = value;
  let deps = new Dep();

  return Object.defineProperty({}, &quot;value&quot;, {
    get() {
      deps.depend();
      return initValue;
    },
    set(newVal) {
      initValue = newVal;
      deps.notify();
    },
  });
};

let x = ref(1);
let y = ref(2);
let z = ref(3);

watch(() =&gt; {
  let str = `${x.value} --- ${y.value} --- ${z.value}`;
  document.write(str);
  console.log(str);
});

x.value = 2;
y.value = 3;
z.value = 3;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="computedwatchwatcheffect"><a class="header" href="#computedwatchwatcheffect">computed,watch,watchEffect</a></h1>
<p>今天来实现一下 vue 里的 computed，watch 和 watchEffect 函数。</p>
<p>先把前面的代码简单捞出来，做一些修改。</p>
<p>使得页面上有个按钮，点击按钮，count 增加。（万物始于计数器）</p>
<pre><code class="language-javascript">let active;

const watchEffect = (cb) =&gt; {
  active = cb;
  active();
  active = null;
};

let nextTick = (cb) =&gt; Promise.resolve().then(cb);

let queue = [];
let queueJob = (job) =&gt; {
  if (!queue.includes(job)) {
    queue.push(job);
    nextTick(flushJobs);
  }
};
let flushJobs = () =&gt; {
  let job;
  while ((job = queue.shift()) !== undefined) {
    job();
  }
};
class Dep {
  deps = new Set();
  depend() {
    if (active) {
      this.deps.add(active);
    }
  }
  notify() {
    this.deps.forEach((dep) =&gt; queueJob(dep));
  }
}

const ref = (value) =&gt; {
  let initValue = value;
  let deps = new Dep();

  return Object.defineProperty({}, &quot;value&quot;, {
    get() {
      deps.depend();
      return initValue;
    },
    set(newVal) {
      initValue = newVal;
      deps.notify();
    },
  });
};

let count = ref(0);

document.getElementById(&quot;add&quot;).addEventListener(&quot;click&quot;, () =&gt; {
  count.value++;
});

watchEffect(() =&gt; {
  let str = `count is: ${count.value}`;
  document.getElementById(&quot;app&quot;).innerText = str;
});
</code></pre>
<h2 id="watcheffect"><a class="header" href="#watcheffect">watchEffect</a></h2>
<p>watchEffect 是一个函数，接受一个函数。函数内部依赖的值变了，函数就会立即执行。就跟我们之前的 watch 一模一样。所以，直接给他改个名就行了。</p>
<p>但是还要返回一个 stop，用来停止监听，这个最后再说。</p>
<h2 id="computed"><a class="header" href="#computed">computed</a></h2>
<p>computed 接受一个函数，内部依赖某个值，并返回一个新的值。内部还有一个缓存。当依赖的值变化的时候才会重新求值。</p>
<h3 id="简单实现-1"><a class="header" href="#简单实现-1">简单实现</a></h3>
<p>简单实现一个 computed 函数：</p>
<pre><code class="language-javascript">let computed = (fn) =&gt; {
  // 使用闭包来保存一个value
  let value;

  return {
    get value() {
      // 在get中响应式监听，直接在get中执行一次fn即可获取到计算后的值。
      value = fn();
      return value;
    },
  };
};
</code></pre>
<p>上述代码已经可以简单的实现一个计算属性。</p>
<h3 id="缓存功能"><a class="header" href="#缓存功能">缓存功能</a></h3>
<p>但是我们的 computed 是有缓存的，而且如果多处调用计算属性，那么将会进行多次计算。为了减少计算。我们也要使用缓存。</p>
<p>通过下面的代码可以发现问题：</p>
<pre><code class="language-javascript">let active;

const watchEffect = (cb) =&gt; {
  active = cb;
  active();
  active = null;
};

let nextTick = (cb) =&gt; Promise.resolve().then(cb);

let queue = [];
let queueJob = (job) =&gt; {
  if (!queue.includes(job)) {
    queue.push(job);
    nextTick(flushJobs);
  }
};
let flushJobs = () =&gt; {
  let job;
  while ((job = queue.shift()) !== undefined) {
    job();
  }
};
class Dep {
  deps = new Set();
  depend() {
    if (active) {
      this.deps.add(active);
    }
  }
  notify() {
    this.deps.forEach((dep) =&gt; queueJob(dep));
  }
}

const ref = (value) =&gt; {
  let initValue = value;
  let deps = new Dep();

  return Object.defineProperty({}, &quot;value&quot;, {
    get() {
      deps.depend();
      return initValue;
    },
    set(newVal) {
      initValue = newVal;
      deps.notify();
    },
  });
};

let computedCount = 0;
let computed = (fn) =&gt; {
  // 使用闭包来保存一个value
  let value;

  return {
    get value() {
      // 在get中响应式监听，直接在get中执行一次fn即可。
      value = fn();
      computedCount += 1;
      return value;
    },
  };
};

let count = ref(0);

let computeCount = computed(() =&gt; count.value + 1);

document.getElementById(&quot;add&quot;).addEventListener(&quot;click&quot;, () =&gt; {
  count.value++;
});

watchEffect(() =&gt; {
  let str = `count is: ${count.value} \n computeCount is: ${computeCount.value} \n computedCount: ${computedCount}`;
  document.getElementById(&quot;app1&quot;).innerText = str;
});

watchEffect(() =&gt; {
  document.getElementById(
    &quot;app2&quot;
  ).innerText = `computeCount 2 is : ${computeCount.value} \n computedCount: ${computedCount}`;
});
</code></pre>
<p>我们在 computed 中增加一个 flag 来控制是否进行计算。</p>
<pre><code class="language-javascript">let computed = (fn) =&gt; {
  // 使用闭包来保存一个value
  let value;
  let dirty = true;

  return {
    get value() {
      // 如果值没有发生变化，返回缓存中的值。
      // 也可以保证多处依赖的时候不会重复计算。
      if (dirty) {
        // 在get中响应式监听，直接在get中执行一次fn即可。
        value = fn();
        computedCount += 1;
        // 置为false
        dirty = false;
      }
      return value;
    },
  };
};
</code></pre>
<p>那么问题来了，既然置为了 false，那么何时何地再置为 true 呢。</p>
<p>显然，在我们触发了 set 操作。在赋值过后的广播行为里，将所有 computed 属性里的 flag 都置为 true。</p>
<p>对此需要进行一些改造。</p>
<blockquote>
<p>此刻之前的代码，ref 中，<code>initialValue</code>和<code>value</code>的定义不符合语义化，已更改。</p>
</blockquote>
<pre><code class="language-javascript">let active;

let effect = (fn, options = {}) =&gt; {
  // 定义一个effectInner来对active进行赋值和执行的操作。
  let effectInner = (...args) =&gt; {
    try {
      // 常规执行，将自身赋值给active，以在收集依赖的时候调用。
      active = effectInner;
      // 直接执行fn，防止递归调用。然后返回。
      // return active(...args);
      return fn(...args);
    } finally {
      // 为了能最终将active值为空。使用try catch finally的特性。
      active = null;
    }
  };
  // 给effectInner上绑定一个options对象。以在广播的时候调用。
  effectInner.options = options;

  return effectInner;
};

const watchEffect = (cb) =&gt; {
  // 替换为effect
  let runner = effect(cb);
  runner();
};

let nextTick = (cb) =&gt; Promise.resolve().then(cb);

let queue = [];
let queueJob = (job) =&gt; {
  if (!queue.includes(job)) {
    queue.push(job);
    nextTick(flushJobs);
  }
};
let flushJobs = () =&gt; {
  let job;
  while ((job = queue.shift()) !== undefined) {
    job();
  }
};
class Dep {
  deps = new Set();
  depend() {
    if (active) {
      this.deps.add(active);
    }
  }
  notify() {
    this.deps.forEach((dep) =&gt; {
      queueJob(dep);
      dep.options &amp;&amp; dep.options.schedular &amp;&amp; dep.options.schedular();
    });
    // 放上面好像也没啥事情，丢里面也能跑。不知道为啥课上写外面，也没说为啥。
    // this.deps.forEach(dep =&gt; {
    //   dep.options &amp;&amp; dep.options.schedular &amp;&amp; dep.options.schedular();
    // })
  }
}

const ref = (initValue) =&gt; {
  let value = initValue;
  let deps = new Dep();

  return Object.defineProperty({}, &quot;value&quot;, {
    get() {
      deps.depend();
      return value;
    },
    set(newVal) {
      value = newVal;
      deps.notify();
    },
  });
};

let computedCount = 0;
let computed = (fn) =&gt; {
  // 使用闭包来保存一个value
  let value;
  let dirty = true;
  // 使用effect包裹fn，增加option，以保证在执行完之后。能在广播中调用options里的schedular。
  let runner = effect(fn, {
    //
    schedular: () =&gt; {
      // 执行这步的时候说明所依赖的值已经更新过了。所以需要置为true保证下面能计算。
      !dirty &amp;&amp; (dirty = true);
    },
  });

  return {
    get value() {
      // 如果值没有发生变化，返回缓存中的值。
      // 也可以保证多处依赖的时候不会重复计算。
      if (dirty) {
        // 在get中响应式监听，直接在get中执行一次fn即可。
        value = runner();
        computedCount += 1;
        dirty = false;
      }
      return value;
    },
  };
};

let count = ref(0);

let computeCount = computed(() =&gt; count.value + 1);

document.getElementById(&quot;add&quot;).addEventListener(&quot;click&quot;, () =&gt; {
  count.value++;
});

watchEffect(() =&gt; {
  let str = `count is: ${count.value} \n computeCount is: ${computeCount.value} \n computedCount: ${computedCount}`;
  document.getElementById(&quot;app1&quot;).innerText = str;
});

watchEffect(() =&gt; {
  document.getElementById(
    &quot;app2&quot;
  ).innerText = `computeCount 2 is : ${computeCount.value} \n computedCount: ${computedCount}`;
});
</code></pre>
<p>细心的小伙伴发现了。点击 add 的时候下面的<code>id=app2</code>的<code>dom</code>不刷新了。这是为啥呢。</p>
<p>我们知道<code>watchEffect</code>会立即执行一遍。所以一开始的时候。我们的值是<code>computeCount.value</code>是 1，没毛病。并且在设置缓存之后，<code>computedCount</code>也是 1
了。并没有重复计算。因为在执行<code>app2</code>的<code>dom</code>的渲染的时候，<code>count</code>的值并没有刷新，所以直接从缓存中取的值。所以上述代码的缓存功能是实现了。</p>
<p>至于为啥不更新。因为<code>app2</code>并不依赖于 count
的值，所以在依赖收集的时候，并没有被增加到<code>deps</code>里去。在页面渲染完毕之后，<code>deps</code>里只有两个<code>dep</code>，都是<code>app1</code>在渲染的时候产生的。一个是直接调用<code>get cout.value</code>的时候产生的依赖，还有一个是调用<code>computed</code>里的<code>count.value + 1</code>的时候使用的<code>get</code>产生的依赖。所以<code>count</code>更新的时候只会执行这两个。并不会触发<code>app2</code>的更新。</p>
<p>没搞懂的。理清一下逻辑。在<code>notify</code>的时候打个断点。在<code>depend</code>的时候打一个断点。就跑懂啦。</p>
<h2 id="watch"><a class="header" href="#watch">watch</a></h2>
<p>监听变化，并在监听回调函数中返回数据变更前后的两个值，常用于在数据变化之后执行的异步操作或者开销交大的操作。</p>
<p>那么，<code>app2</code>的不渲染问题也可以在这里解决。（不直接依赖<code>count</code>，但是需要根据<code>count</code>的变化而变化）</p>
<p>那么，核心思想就是，触发<code>count</code>的<code>get</code>方法把执行的回调函数增加到<code>deps</code>里。</p>
<p>我们这里 watch 的第一个参数只给到<code>function</code>，其他类型的不讨论。</p>
<p>所以有一个 getter：</p>
<pre><code class="language-javascript">// source是一个函数，里面有所依赖（要监听）的值
let getter = () =&gt; {
  return source();
};
</code></pre>
<p>然后我们需要一个增加依赖的地方，所以用到了 effect，然后还需要给回调函数准备<code>newVal</code>和<code>oldVal</code>：</p>
<pre><code class="language-js">let oldVal;
const runner = effect(getter, {
  schedular: () =&gt; {
    // 重复触发依赖收集
    let newVal = runner();
    // 只有当newVal不等于oldVal的时候才触发，即有变化之后才触发
    if (newVal !== oldVal) {
      cb(newVal, oldVal);
      // 重新赋值oldVal
      oldVal = newVal;
    }
  },
});
// 初始化赋值oldVal
oldVal = runner();
</code></pre>
<p>然后我们去使用 watch，并且在 callback 里不直接使用<code>cout.value</code>，完整代码如下：</p>
<pre><code class="language-js">let active;

let effect = (fn, options = {}) =&gt; {
  let effectInner = (...args) =&gt; {
    try {
      active = effectInner;
      return fn(...args);
    } finally {
      active = null;
    }
  };
  effectInner.options = options;

  return effectInner;
};

const watchEffect = (cb) =&gt; {
  let runner = effect(cb);
  runner();
};

let nextTick = (cb) =&gt; Promise.resolve().then(cb);

let queue = [];
let queueJob = (job) =&gt; {
  if (!queue.includes(job)) {
    queue.push(job);
    nextTick(flushJobs);
  }
};
let flushJobs = () =&gt; {
  let job;
  while ((job = queue.shift()) !== undefined) {
    job();
  }
};
class Dep {
  deps = new Set();
  depend() {
    if (active) {
      this.deps.add(active);
    }
  }
  notify() {
    this.deps.forEach((dep) =&gt; {
      queueJob(dep);
      dep.options &amp;&amp; dep.options.schedular &amp;&amp; dep.options.schedular();
    });
    // this.deps.forEach(dep =&gt; {
    //   dep.options &amp;&amp; dep.options.schedular &amp;&amp; dep.options.schedular();
    // })
  }
}

const ref = (initValue) =&gt; {
  let value = initValue;
  let deps = new Dep();

  return Object.defineProperty({}, &quot;value&quot;, {
    get() {
      deps.depend();
      return value;
    },
    set(newVal) {
      value = newVal;
      deps.notify();
    },
  });
};

let computed = (fn) =&gt; {
  // 使用闭包来保存一个value
  let value;
  let dirty = true;
  let runner = effect(fn, {
    schedular: () =&gt; {
      !dirty &amp;&amp; (dirty = true);
    },
  });

  return {
    get value() {
      // 如果值没有发生变化，返回缓存中的值。
      // 也可以保证多处依赖的时候不会重复计算。
      if (dirty) {
        // 在get中响应式监听，直接在get中执行一次fn即可。
        value = runner();
        dirty = false;
      }
      return value;
    },
  };
};

let watch = (source, cb) =&gt; {
  let getter = () =&gt; {
    return source();
  };
  let oldVal;
  const runner = effect(getter, {
    schedular: () =&gt; {
      // 重复触发依赖收集
      let newVal = runner();
      if (newVal !== oldVal) {
        cb(newVal, oldVal);
        oldVal = newVal;
      }
    },
  });

  oldVal = runner();
};

let count = ref(0);

let computeCount = computed(() =&gt; count.value + 1);

watch(
  () =&gt; count.value,
  (newVal, preVal) =&gt; {
    console.log(newVal, preVal);
    document.getElementById(&quot;app2&quot;).innerText = `watchCount is : ${newVal}`;
  }
);

document.getElementById(&quot;add&quot;).addEventListener(&quot;click&quot;, () =&gt; {
  count.value++;
});

watchEffect(() =&gt; {
  let str = `count is: ${count.value} \n computeCount is: ${computeCount.value}`;
  document.getElementById(&quot;app1&quot;).innerText = str;
});

// watchEffect(() =&gt; {
//   document.getElementById('app2').innerText = `computeCount 2 is : ${computeCount.value}`
// })
</code></pre>
<p>可以看到<code>app2</code>已经被更新了。</p>
<p>但是首次渲染的时候没有显示。当然咯。首次渲染的时候<code>count.value</code>又没变化咯。</p>
<p>要是我就是要初始化的时候也渲染呢？</p>
<p>那么就到了 watch 的 options 里，有个叫 immediate 的参数。用来判断是否需要立即执行一次。</p>
<p>对 watch 进行一下小修改：</p>
<pre><code class="language-js">let watch = (source, cb, options = { immediate: false }) =&gt; {
  const { immediate } = options;
  let getter = () =&gt; {
    return source();
  };
  let oldVal;

  const applyCb = () =&gt; {
    // 重复触发依赖收集
    let newVal = runner();
    if (newVal !== oldVal) {
      cb(newVal, oldVal);
      oldVal = newVal;
    }
  };
  const runner = effect(getter, {
    // schedular: () =&gt; applyCb()
    schedular: applyCb,
  });

  if (immediate) {
    applyCb();
  } else {
    oldVal = runner();
  }
};
</code></pre>
<p>这样的话第一次进来就可以看到啦。</p>
<div style="break-before: page; page-break-before: always;"></div><p>先把之前写过的 vue 的响应式原理里的代码略加修改搬过来</p>
<pre><code class="language-javascript">/* eslint-disable no-unused-vars */
// let x;
// let y;
// let f = n =&gt; n * 100 + 100;

let active;

let watch = function (cb) {
  active = cb;
  active();
  active = null;
};

let queue = [];
let nextTick = (cb) =&gt; Promise.resolve().then(cb);
let queueJob = (job) =&gt; {
  if (!queue.includes(job)) {
    queue.push(job);
    nextTick(flushJobs);
  }
};
let flushJobs = () =&gt; {
  let job;
  while ((job = queue.shift()) !== undefined) {
    job();
  }
};

class Dep {
  constructor() {
    this.deps = new Set();
  }
  depend() {
    if (active) {
      this.deps.add(active);
    }
  }
  notify() {
    this.deps.forEach((dep) =&gt; queueJob(dep));
  }
}

let ref = (initValue) =&gt; {
  let value = initValue;
  let dep = new Dep();

  return Object.defineProperty({}, &quot;value&quot;, {
    get() {
      dep.depend();
      return value;
    },
    set(newValue) {
      value = newValue;
      dep.notify();
    },
  });
};

let createReactive = (target, prop, value) =&gt; {
  let dep = new Dep();

  // return new Proxy(target, {
  //   get(target, prop) {
  //     dep.depend();
  //     return Reflect.get(target, prop);
  //   },
  //   set(target, prop, value) {
  //     Reflect.set(target, prop, value);
  //     dep.notify();
  //   },
  // });

  return Object.defineProperty(target, prop, {
    get() {
      dep.depend();
      return value;
    },
    set(newValue) {
      value = newValue;
      dep.notify();
    },
  });
};

export let reactive = (obj) =&gt; {
  let dep = new Dep();

  Object.keys(obj).forEach((key) =&gt; {
    let value = obj[key];
    createReactive(obj, key, value);
  });

  return obj;
};

// let data = reacitve({
//   count: 0
// });

import { Store } from &quot;./vuex&quot;;

let store = new Store({
  state: {
    count: 0,
  },
  mutations: {
    addCount(state, payload) {
      state.count += payload || 1;
    },
  },
  plugins: [
    (store) =&gt;
      store.subscribe((mutation, state) =&gt; {
        console.log(mutation);
      }),
  ],
});

document.getElementById(&quot;add&quot;).addEventListener(&quot;click&quot;, function () {
  // data.count++;
  store.commit(&quot;addCount&quot;, 1);
});
let str;
watch(() =&gt; {
  str = `hello ${store.state.count}`;
  document.getElementById(&quot;app&quot;).innerText = str;
});
</code></pre>
<p>vuex 其实也就是在构造过程中调用了 vue 的 reactive 来包裹自己的 state 来使得 state 变为响应式的。</p>
<pre><code class="language-javascript">import { reactive } from &quot;./myVue&quot;;

export class Store {
  constructor(options = {}) {
    let { state, mutations, plugins } = options;
    this._vm = reactive(state);
    this._mutations = mutations;

    this._subscribe = [];
    plugins.forEach((plugin) =&gt; plugin(this));
  }

  get state() {
    return this._vm;
  }

  commit(type, payload) {
    const entry = this._mutations[type];
    if (!entry) {
      return;
    }
    entry(this.state, payload);
    this._subscribe.forEach((fn) =&gt; fn({ type, payload }, this.state));
  }

  subscribe(fn) {
    if (!this._subscribe.includes(fn)) {
      this._subscribe.push(fn);
    }
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="加密"><a class="header" href="#加密">加密</a></h1>
<p>HTTP 有以下安全性问题：</p>
<ul>
<li>使用明文进行通信，内容可能会被窃听；</li>
<li>不验证通信方的身份，通信方的身份有可能遭遇伪装；</li>
<li>无法证明报文的完整性，报文有可能遭篡改。</li>
</ul>
<p>HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。</p>
<p>通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。</p>
<p><img src="Network/./images/ssl-offloading.jpg" alt="img" /></p>
<h2 id="对称加密"><a class="header" href="#对称加密">对称加密</a></h2>
<p>加密的密钥和解密的密钥是同一个</p>
<h2 id="非对称加密"><a class="header" href="#非对称加密">非对称加密</a></h2>
<p>加密的密钥和解密的密钥不是同一个（公钥，私钥）</p>
<ul>
<li>创建者必须创建一个密钥对（公钥和私钥）</li>
<li>公钥加密必须私钥解密</li>
<li>私钥加密必须公钥解密</li>
<li>创建者保留私钥，公钥向外界公开</li>
</ul>
<h3 id="使用非对称加密的场景"><a class="header" href="#使用非对称加密的场景">使用非对称加密的场景</a></h3>
<p>不放心对方保管密钥的情况</p>
<h3 id="非对称加密的例子"><a class="header" href="#非对称加密的例子">非对称加密的例子</a></h3>
<p><img src="Network/./images/image-20210820174422038.png" alt="image-20210820174422038" /></p>
<h2 id="对比"><a class="header" href="#对比">对比</a></h2>
<ul>
<li>非对称加密安全性更好</li>
<li>对称加密计算速度更快</li>
<li>一般都是混合使用（使用非对称加密协商密钥，然后进行对称加密）</li>
</ul>
<h2 id="https"><a class="header" href="#https">HTTPs</a></h2>
<p>https 的工作过程</p>
<p><img src="Network/./images/image-20210820174718847.png" alt="image-20210820174718847" /></p>
<ul>
<li>SYN</li>
<li>SYN-ACK</li>
<li>ACK 三次握手完成（至此都是不加密的，因为是三次握手）</li>
<li>然后服务端回传证书（不加密）</li>
<li>客户端密钥（协商）（非对称加密）</li>
<li>完成（非对称加密）</li>
<li>然后才进行数据传输（对称加密）</li>
</ul>
<h3 id="认证"><a class="header" href="#认证">认证</a></h3>
<p>通过使用 <strong>证书</strong> 来对通信方进行认证。</p>
<p>数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。</p>
<p>服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。</p>
<p>进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。</p>
<p><img src="Network/./images/2017-06-11-ca-163143670261317.png" alt="img" /></p>
<h3 id="完整性保护"><a class="header" href="#完整性保护">完整性保护</a></h3>
<p>SSL 提供报文摘要功能来进行完整性保护。</p>
<p>HTTP 也提供了 MD5 报文摘要功能，但不是安全的。例如报文内容被篡改之后，同时重新计算 MD5 的值，通信接收方是无法意识到发生了篡改。</p>
<p>HTTPS 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作。试想一下，加密之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文。</p>
<h3 id="https-的缺点"><a class="header" href="#https-的缺点">HTTPS 的缺点</a></h3>
<ul>
<li>因为需要进行加密解密等过程，因此速度会更慢；</li>
<li>需要支付证书授权的高额费用。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="tcp-三次握手"><a class="header" href="#tcp-三次握手">TCP 三次握手</a></h2>
<p><img src="Network/./images/image-20210912161027193.png" alt="image-20210912161027193" /></p>
<ul>
<li>客户端调用<code>connect</code>方法，然后客户端进入<code>SYN_SEND</code></li>
<li>客户端接收到之后，会进入<code>SYN_RECEIVED</code>状态，然后发送一个<code>ACK</code>，表示已经确认收到请求</li>
<li>然后客户端收到之后会进入<code>ESTABLISHED</code>状态，然后客户端还会发送一个<code>ACK</code>，告诉服务端已经收到了</li>
<li>然后服务端收到之后，会进入<code>ESTABLISHED</code></li>
</ul>
<p><img src="Network/./images/e92d0ebc-7d46-413b-aec1-34a39602f787.png" alt="img" /></p>
<p>假设 A 为客户端，B 为服务器端。</p>
<ul>
<li>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。</li>
<li>A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。</li>
<li>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。</li>
<li>A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。</li>
<li>B 收到 A 的确认后，连接建立。</li>
</ul>
<p><strong>三次握手的原因</strong></p>
<p>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。</p>
<p>客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。</p>
<h2 id="关于数据同步"><a class="header" href="#关于数据同步">关于数据同步</a></h2>
<p><img src="Network/./images/image-20210912161357017.png" alt="image-20210912161357017" /></p>
<ol>
<li>发多个，返回多个</li>
<li>发多个，到达顺序不一致</li>
<li>收到的也不一定能保证顺序</li>
</ol>
<p>所以我们需要给消息加上编号。也要保证编号的唯一性、顺序性等（时差等）。</p>
<ol>
<li>使用发送接收时间
<ul>
<li>要解决服务器时差</li>
</ul>
</li>
<li>使用自增序号
<ul>
<li>A-B-A-B 类型会话可以解决？</li>
<li>A-（AB）-B 类型会话如何解决？</li>
</ul>
</li>
</ol>
<h3 id="tcpip-协议的处理方法"><a class="header" href="#tcpip-协议的处理方法">TCP/IP 协议的处理方法</a></h3>
<p>消息的绝对顺序使用 SEQ 和 ACK 这一对元组描述</p>
<ul>
<li>SEQ（Sequence）：这个消息发送之前一共发送了多少字节</li>
<li>ACK（Acknowledge）：这个消息发送钱一共收到了多少字节</li>
</ul>
<p><img src="Network/./images/image-20210912162542509.png" alt="image-20210912162542509" /></p>
<p><img src="Network/./images/image-20210912162555067.png" alt="image-20210912162555067" /></p>
<p><img src="Network/./images/image-20210912162611468.png" alt="image-20210912162611468" /></p>
<h2 id="tcp-滑动窗口"><a class="header" href="#tcp-滑动窗口">TCP 滑动窗口</a></h2>
<p>窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。</p>
<p>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。</p>
<p>接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31
进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。</p>
<p><img src="Network/./images/a3253deb-8d21-40a1-aae4-7d178e4aa319.jpg" alt="img" /></p>
<h2 id="tcp-四次挥手"><a class="header" href="#tcp-四次挥手">TCP 四次挥手</a></h2>
<p><img src="Network/./images/image-20210912162910642.png" alt="image-20210912162910642" /></p>
<p>不可以在客户端发起关闭请求的时候立即关闭连接。以防止还有消息未发送或未到达。</p>
<p>所以 TCP/IP 中是这么做的：</p>
<p><img src="Network/./images/image-20210912163052419.png" alt="image-20210912163052419" /></p>
<ul>
<li>关闭连接的发起者启用<code>close</code>方法，自身进入<code>FIN_WAIT1</code>状态，发送 FIN 报文给接收端</li>
<li>接收端接受到<code>FIN</code>报文之后，会进入<code>CLOSE_WAIT</code>状态。</li>
<li>然后等待发送完所有未发送的请求之后，自身会进入<code>LAST_ACK</code>状态，发送<code>FIN</code>报问给发起者</li>
<li>发起者接受到之后会进入<code>TIME_WAIT</code>状态，然后给接受者一个响应<code>ACK</code>，接受者会进入<code>CLOSED</code>状态</li>
<li>然后在一段时间内等待，以防止网络拥堵导致包还未到达。时间结束之后，发起者会直接进入<code>CLOSED</code>状态</li>
</ul>
<p><img src="Network/./images/f87afe72-c2df-4c12-ac03-9b8d581a8af8.jpg" alt="img" /></p>
<p>以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。</p>
<ul>
<li>A 发送连接释放报文，FIN=1。</li>
<li>B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。</li>
<li>当 B 不再需要连接时，发送连接释放报文，FIN=1。</li>
<li>A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。</li>
<li>B 收到 A 的确认后释放连接。</li>
</ul>
<p><strong>四次挥手的原因</strong></p>
<p>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。</p>
<p><strong>TIME_WAIT</strong></p>
<p>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：</p>
<ul>
<li>确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。</li>
<li>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</li>
</ul>
<h2 id="拓展阅读-1"><a class="header" href="#拓展阅读-1">拓展阅读</a></h2>
<ul>
<li><a href="https://mp.weixin.qq.com/s/W2CNPkHKvnHjEUFYFVNl2g">手动发包只握手两次，我发现了 TCP 的秘密···</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="缓存"><a class="header" href="#缓存">缓存</a></h1>
<p><img src="Network/./images/image-20210912172736469.png" alt="image-20210912172736469" /></p>
<blockquote>
<p>有些缓存为了更高的效率，会牺牲命中率，比如<a href="https://zhuanlan.zhihu.com/p/43263751">布隆过滤器</a></p>
</blockquote>
<p>缓存算法主要有 <code>FIFO</code>，<code>LRU</code> 等。</p>
<h2 id="http-缓存"><a class="header" href="#http-缓存">HTTP 缓存</a></h2>
<p>由 <code>Cache-Control</code> 来控制</p>
<p><img src="Network/./images/image-20210912175612677.png" alt="image-20210912175612677" /></p>
<h3 id="强制缓存"><a class="header" href="#强制缓存">强制缓存</a></h3>
<p>使用强制缓存，不去服务器对比；缓存生效不再发送请求。</p>
<pre><code>Cache-Control: max-age=600
Expires: &lt;最后期限&gt;
</code></pre>
<h3 id="协商缓存"><a class="header" href="#协商缓存">协商缓存</a></h3>
<h4 id="last-modified"><a class="header" href="#last-modified">Last-Modified</a></h4>
<p>协商使用缓存，每次需要向服务器请求对比，缓存生效不传回 body</p>
<pre><code>返回：
Last-Modified:&lt;昨天&gt;

请求：
If-Midified-Since:&lt;昨天&gt;
</code></pre>
<h4 id="e-tag"><a class="header" href="#e-tag">E-Tag</a></h4>
<pre><code>返回：
E-Tag: 1234567

请求：
If-None-Match: 1234567
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="http20"><a class="header" href="#http20">HTTP2.0</a></h2>
<ul>
<li>
<p>多路复用</p>
</li>
<li>
<p>防止队头阻塞</p>
</li>
<li>
<p>压缩 HTTP 头部</p>
</li>
<li>
<p>服务端推送</p>
</li>
<li>
<p>二进制分帧</p>
</li>
</ul>
<h2 id="前言-1"><a class="header" href="#前言-1">前言</a></h2>
<p>HTTP2.0 大幅度的提高了 web 性能，在 HTTP1.1
完全语义兼容的基础上，进一步减少了网络的延迟。实现低延迟高吞吐量。对于前端开发者而言，减少了优化工作。本文将重点围绕以下几点新特性的作用、工作过程以及如何更出色的完成了优化工作来介绍 HTTP2.0</p>
<ul>
<li>二进制分帧</li>
<li>首部压缩</li>
<li>多路复用</li>
<li>请求优先级</li>
<li>服务器推送</li>
</ul>
<h2 id="一-介绍"><a class="header" href="#一-介绍">一. 介绍</a></h2>
<p>HTTP/2 是 HTTP 协议自 1999 年 HTTP1.1 发布后的首个更新，主要基于 SPDY 协议。</p>
<h4 id="11-什么是-spdy-协议"><a class="header" href="#11-什么是-spdy-协议">1.1 什么是 SPDY 协议</a></h4>
<p>SPDY 是 Speedy 的昵音，意为“更快”。它是 Google 开发的基于 TCP 协议的应用层协议。目标是优化 HTTP
协议的性能，通过压缩、多路复用和优先级等技术，缩短网页的加载时间并提高安全性。SPDY 协议的核心思想是尽量减少 TCP 连接数。SPDY 并不是一种用于替代 HTTP 的协议，而是对 HTTP
协议的增强。</p>
<h4 id="12-http1x-的缺点"><a class="header" href="#12-http1x-的缺点">1.2 HTTP1.X 的缺点</a></h4>
<p>任何事物的更新都是为了弥补或修复上个版本的某些问题，那么我们来看看 HTTP1.x 都有哪些缺点以至于我们要使用 HTTP2.0。</p>
<p>HTTP1.x 有以下几个主要缺点：</p>
<ol>
<li>HTTP/1.0 一次只允许在一个 TCP 连接上发起一个请求，HTTP/1.1
使用的流水线技术也只能部分处理请求并发，仍然会存在队列头阻塞问题，因此客户端在需要发起多次请求时，通常会采用建立多连接来减少延迟。</li>
<li>单向请求，只能由客户端发起。</li>
<li>请求报文与响应报文首部信息冗余量大。</li>
<li>数据未压缩，导致数据的传输量大</li>
</ol>
<p>我们可以通过一个链接来对比一下 HTTP2.0 到底比 HTTP1.x 快了多少。<a href="https://http2.akamai.com/demo">链接地址</a></p>
<h2 id="二-二进制分帧"><a class="header" href="#二-二进制分帧">二. 二进制分帧</a></h2>
<p>在不改变 HTTP1.x 的语义、方法、状态码、URL 以及首部字段的情况下，HTTP2.0 是怎样突破 HTTP1.1
的性能限制，改进传输性能，实现低延迟高吞吐量的呢？关键之一就是在应用层（HTTP）和传输层（TCP）之间增加一个二进制分帧层。</p>
<p>在整理二进制分帧及其作用的时候我们先来铺垫一点关于帧的知识：</p>
<ul>
<li>帧：HTTP2.0 通信的最小单位，所有帧都共享一个 8 字节的首部，其中包含帧的长度、类型、标志、还有一个保留位，并且至少有标识出当前帧所属的流的标识符，帧承载着特定类型的数据，如 HTTP
首部、负荷、等等。</li>
<li>消息：比帧大的通讯单位，是指逻辑上的 HTTP 消息，比如请求、响应等。由一个或多个帧组成</li>
<li>流：比消息大的通讯单位。是 TCP 连接中的一个虚拟通道，可以承载双向的消息。每个流都有一个唯一的整数标识符</li>
</ul>
<p>HTTP2.0 中所有加强性能的核心是二进制传输，在 HTTP1.x
中，我们是通过文本的方式传输数据。基于文本的方式传输数据存在很多缺陷，文本的表现形式有多样性，因此要做到健壮性考虑的场景必然有很多，但是二进制则不同，只有 0 和 1
的组合，因此选择了二进制传输，实现方便且健壮。 在 HTTP2.0 中引入了新的编码机制，所有传输的数据都会被分割，并采用二进制格式编码。
<img src="Network/./images/20190802162333949.png" alt="在这里插入图片描述" /></p>
<p>为了保证 HTTP 不受影响，那就需要在应用层（HTTP2.0）和传输层（TCP or
UDP）之间增加一个二进制分帧层。<code>在二进制分帧层上，HTTP2.0会将所有传输的信息分为更小的消息和帧，并采用二进制格式编码，其中HTTP1.x的首部信息会被封装到Headers帧，而Request Body则封装到Data帧。</code></p>
<h2 id="三-首部压缩"><a class="header" href="#三-首部压缩">三. 首部压缩</a></h2>
<p>HTTP1.1 并不支持 HTTP 首部压缩，为此 SPDY 和 HTTP2.0 出现了。SPDY 是用的是 DEFLATE 算法，而 HTTP2.0 则使用了专门为首部压缩设计的 HPACK 算法。</p>
<p>HTTP 每次通讯（请求或响应）都会携带首部信息用于描述资源属性。</p>
<p>在 HTTP1.0 中，我们使用文本的形式传输 header，在 header 中携带 cookie 的话，每次都需要重复传输几百到几千的字节，这着实是一笔不小的开销。</p>
<p>在 HTTP2.0 中，我们使用了 HPACK（HTTP2 头部压缩算法）压缩格式对传输的 header 进行编码，减少了 header 的大小。并在两端维护了索引表，用于记录出现过的
header，后面在传输过程中就可以传输已经记录过的 header 的键名，对端收到数据后就可以通过键名找到对应的值。</p>
<h2 id="四-多路复用"><a class="header" href="#四-多路复用">四. 多路复用</a></h2>
<p>在 HTTP1.x 中，我们经常会使用到雪碧图、使用多个域名等方式来进行优化，都是因为浏览器限制了同一个域名下的请求数量，当页面需要请求很多资源的时候，队头阻塞（Head of line
blocking）会导致在达到最大请求时，资源需要等待其他资源请求完成后才能继续发送。</p>
<p>HTTP2.0 中,基于二进制分帧层，HTTP2.0 可以在共享 TCP 连接的基础上同时发送请求和响应。HTTP
消息被分解为独立的帧，而不破坏消息本身的语义，交错发出去，在另一端根据流标识符和首部将他们重新组装起来。 通过该技术，可以避免 HTTP 旧版本的队头阻塞问题，极大提高传输性能。</p>
<h2 id="五-请求优先级"><a class="header" href="#五-请求优先级">五. 请求优先级</a></h2>
<p>把 HTTP 消息分为很多独立帧之后，就可以通过优化这些帧的交错和传输顺序进一步优化性能。</p>
<h2 id="六-服务器推送"><a class="header" href="#六-服务器推送">六. 服务器推送</a></h2>
<p>HTTP2.0 新增的一个强大的新功能，就是服务器可以对一个客户端请求发送多个响应。服务器向客户端推送资源无需客户端明确的请求。</p>
<p>服务端根据客户端的请求，提前返回多个响应，推送额外的资源给客户端。如下图，客户端请求 stream 1(/page.html)。服务端在返回 stream 1 的消息的同时推送了 stream
2(/script.js)和 stream 4(/style.css) <img src="Network/./images/20190802165438943.jpg" alt="在这里插入图片描述" />
服务端推送是一种在客户端请求之前发送数据的机制。在 HTTP2.0 中，服务器可以对一个客户端的请求发送多个响应。如果一个请求是由你的主页发送的，服务器可能会响应主页内容、logo
以及样式表，因为他知道客户端会用到这些东西。这样不但减轻了数据传送冗余步骤，也加快了页面响应的速度，提高了用户体验。</p>
<p>推送的缺点：所有推送的资源都必须遵守同源策略。换句话说，服务器不能随便将第三方资源推送给客户端，而必须是经过双方的确认才行。</p>
<p><a href="https://blog.csdn.net/yexudengzhidao/article/details/98207149">摘自</a></p>
<h2 id="http30"><a class="header" href="#http30">HTTP3.0</a></h2>
<p>把 TCP 层拆成 QUIC + UDP</p>
<p><img src="Network/./images/image-20210624165958643.png" alt="image-20210624165958643" /></p>
<h3 id="http20-1"><a class="header" href="#http20-1">HTTP2.0</a></h3>
<h4 id="11-http20-和-tcp-的爱恨纠葛"><a class="header" href="#11-http20-和-tcp-的爱恨纠葛">1.1 HTTP2.0 和 TCP 的爱恨纠葛</a></h4>
<p>HTTP2.0 是 2015 年推出的，还是比较年轻的，其重要的二进制分帧协议、多路复用、头部压缩、服务端推送等重要优化使 HTTP 协议真正上了一个新台阶。</p>
<p><img src="Network/./images/7acb0a46f21fbe0969e83c0c59894b348644ad60.png" alt="" /></p>
<p>像谷歌这种重要的公司并没有满足于此，而且想继续提升 HTTP 的性能，花最少的时间和资源获取极致体验。</p>
<p>那么肯定要问 HTTP2.0 虽然性能已经不错了，还有什么不足吗？</p>
<p>建立连接时间长(本质上是 TCP 的问题) 队头阻塞问题 移动互联网领域表现不佳(弱网环境) ......</p>
<p>熟悉 HTTP2.0 协议的同学应该知道，这些缺点基本都是由于 TCP 协议引起的，水能载舟亦能覆舟，其实 TCP 也很无辜呀！</p>
<p><img src="Network/./images/1e30e924b899a901cda64a7e2c7c4d7c0008f5d3.png" alt="" /></p>
<p>在我们眼里，TCP 是面向连接、可靠的传输层协议，当前几乎所有重要的协议和应用都是基于 TCP 来实现的。</p>
<p>网络环境的改变速度很快，但是 TCP 协议相对缓慢，正是这种矛盾促使谷歌做出了一个看似出乎意料的决定-基于 UDP 来开发新一代 HTTP 协议。</p>
<h4 id="12-谷歌为什么选择-udp"><a class="header" href="#12-谷歌为什么选择-udp">1.2 谷歌为什么选择 UDP</a></h4>
<p>上文提到，谷歌选择 UDP 是看似出乎意料的，仔细想一想其实很有道理。</p>
<p>我们单纯地看看 TCP 协议的不足和 UDP 的一些优点：</p>
<p>基于 TCP 开发的设备和协议非常多，兼容困难 TCP 协议栈是 Linux 内部的重要部分，修改和升级成本很大 UDP 本身是无连接的、没有建链和拆链成本 UDP 的数据包无队头阻塞问题 UDP
改造成本小</p>
<p>从上面的对比可以知道，谷歌要想从 TCP 上进行改造升级绝非易事，但是 UDP 虽然没有 TCP 为了保证可靠连接而引发的问题，但是 UDP 本身不可靠，又不能直接用。</p>
<p><img src="Network/./images/42166d224f4a20a4d6863d33bfbbdf25700ed09e.jpeg" alt="" /></p>
<p>综合而知，谷歌决定在 UDP 基础上改造一个具备 TCP 协议优点的新协议也就顺理成章了，这个新协议就是 QUIC 协议。</p>
<h4 id="13-quic-协议和-http30"><a class="header" href="#13-quic-协议和-http30">1.3 QUIC 协议和 HTTP3.0</a></h4>
<p>QUIC 其实是 Quick UDP Internet Connections 的缩写，直译为快速 UDP 互联网连接。</p>
<p><img src="Network/./images/b7003af33a87e950295f0a4f3fd11444faf2b4bd.jpeg" alt="" /></p>
<p>我们来看看维基百科对于 QUIC 协议的一些介绍：</p>
<p>QUIC 协议最初由 Google 的 Jim Roskind 设计，实施并于 2012 年部署，在 2013 年随着实验的扩大而公开宣布，并向 IETF 进行了描述。</p>
<p>QUIC 提高了当前正在使用 TCP 的面向连接的 Web 应用程序的性能。它在两个端点之间使用用户数据报协议（UDP）建立多个复用连接来实现此目的。</p>
<p>QUIC 的次要目标包括减少连接和传输延迟，在每个方向进行带宽估计以避免拥塞。它还将拥塞控制算法移动到用户空间，而不是内核空间，此外使用前向纠错（FEC）进行扩展，以在出现错误时进一步提高性能。</p>
<p>HTTP3.0 又称为 HTTP Over QUIC，其弃用 TCP 协议，改为使用基于 UDP 协议的 QUIC 协议来实现。</p>
<p><img src="Network/./images/6a63f6246b600c334d9de0c037a51608dbf9a1c6.jpeg" alt="" /></p>
<h3 id="quic-协议详解"><a class="header" href="#quic-协议详解">QUIC 协议详解</a></h3>
<p>择其善者而从之，其不善者而改之。</p>
<p>HTTP3.0 既然选择了 QUIC 协议，也就意味着 HTTP3.0 基本继承了 HTTP2.0 的强大功能，并且进一步解决了 HTTP2.0 存在的一些问题，同时必然引入了新的问题。</p>
<p><img src="Network/./images/1e30e924b899a901cda64a7e2c7c4d7c0008f5d3-1.png" alt="" /></p>
<p>QUIC 协议必须要实现 HTTP2.0 在 TCP 协议上的重要功能，同时解决遗留问题，我们来看看 QUIC 是如何实现的。</p>
<h4 id="21-队头阻塞问题"><a class="header" href="#21-队头阻塞问题">2.1 队头阻塞问题</a></h4>
<p>队头阻塞 Head-of-line blocking（缩写为 HOL blocking）是计算机网络中是一种性能受限的现象，通俗来说就是：一个数据包影响了一堆数据包，它不来大家都走不了。</p>
<p>队头阻塞问题可能存在于 HTTP 层和 TCP 层，在 HTTP1.x 时两个层次都存在该问题。</p>
<p><img src="Network/./images/03087bf40ad162d938cfbf693d36eeeb8b13cd97.png" alt="" /></p>
<p>HTTP2.0 协议的多路复用机制解决了 HTTP 层的队头阻塞问题，但是在 TCP 层仍然存在队头阻塞问题。</p>
<p>TCP 协议在收到数据包之后，这部分数据可能是乱序到达的，但是 TCP 必须将所有数据收集排序整合后给上层使用，如果其中某个包丢失了，就必须等待重传，从而出现某个丢包数据阻塞整个连接的数据使用。</p>
<p>QUIC 协议是基于 UDP 协议实现的，在一条链接上可以有多个流，流与流之间是互不影响的，当一个流出现丢包影响范围非常小，从而解决队头阻塞问题。</p>
<h4 id="22-0rtt-建链"><a class="header" href="#22-0rtt-建链">2.2 0RTT 建链</a></h4>
<p>衡量网络建链的常用指标是 RTT Round-Trip Time，也就是数据包一来一回的时间消耗。</p>
<p><img src="Network/./images/4bed2e738bd4b31c9c05217bb73f60789f2ff821.jpeg" alt="" /></p>
<p>RTT 包括三部分：往返传播时延、网络设备内排队时延、应用程序数据处理时延。</p>
<p><img src="Network/./images/faf2b2119313b07e2a6f75f9233ed62495dd8c65.jpeg" alt="" /></p>
<p>一般来说 HTTPS 协议要建立完整链接包括:TCP 握手和 TLS 握手，总计需要至少 2-3 个 RTT，普通的 HTTP 协议也需要至少 1 个 RTT 才可以完成握手。</p>
<p>然而，QUIC 协议可以实现在第一个包就可以包含有效的应用数据，从而实现 0RTT，但这也是有条件的。</p>
<p><img src="Network/./images/95f5c7e411d0b7f96d182abe284be551.gif" alt="" /></p>
<p>简单来说，基于 TCP 协议和 TLS 协议的 HTTP2.0 在真正发送数据包之前需要花费一些时间来完成握手和加密协商，完成之后才可以真正传输业务数据。</p>
<p>但是 QUIC 则第一个数据包就可以发业务数据，从而在连接延时有很大优势，可以节约数百毫秒的时间。</p>
<p><img src="Network/./images/9345d688d43f87946df4ec30fdf249f31ad53a91.png" alt="" /></p>
<p>QUIC 的 0RTT 也是需要条件的，对于第一次交互的客户端和服务端 0RTT 也是做不到的，毕竟双方完全陌生。</p>
<p>因此，QUIC 协议可以分为首次连接和非首次连接，两种情况进行讨论。</p>
<h4 id="23-首次连接和非首次连接"><a class="header" href="#23-首次连接和非首次连接">2.3 首次连接和非首次连接</a></h4>
<p>使用 QUIC 协议的客户端和服务端要使用 1RTT 进行密钥交换，使用的交换算法是 DH(Diffie-Hellman)迪菲-赫尔曼算法。</p>
<p>DH 算法开辟了密钥交换的新思路，在之前的文章中提到的 RSA 算法也是基于这种思想实现的，但是 DH 算法和 RSA 的密钥交换不完全一样，感兴趣的读者可以看看 DH 算法的数学原理。</p>
<p>DH 算法开辟了密钥交换的新思路，在之前的文章中提到的 RSA 算法也是基于这种思想实现的，但是 DH 算法和 RSA 的密钥交换不完全一样，感兴趣的读者可以看看 DH 算法的数学原理。</p>
<h5 id="231-首次连接"><a class="header" href="#231-首次连接">2.3.1 首次连接</a></h5>
<p>简单来说一下，首次连接时客户端和服务端的密钥协商和数据传输过程，其中涉及了 DH 算法的基本过程：</p>
<ol>
<li>客户端对于首次连接的服务端先发送 client hello 请求。</li>
<li>服务端生成一个素数 p 和一个整数 g，同时生成一个随机数 (笔误-此处应该是 Ks_pri)为私钥，然后计算出公钥 = mod p，服务端将，p，g 三个元素打包称为
config，后续发送给客户端。</li>
<li>客户端随机生成一个自己的私钥，再从 config 中读取 g 和 p，计算客户端公钥 = mod p。</li>
<li>客户端使用自己的私钥和服务端发来的 config 中读取的服务端公钥，生成后续数据加密用的密钥 K = mod p。</li>
<li>客户端使用密钥 K 加密业务数据，并追加自己的公钥，都传递给服务端。</li>
<li>服务端根据自己的私钥和客户端公钥生成客户端加密用的密钥 K = mod p。</li>
<li>为了保证数据安全，上述生成的密钥 K 只会生成使用 1 次，后续服务端会按照相同的规则生成一套全新的公钥和私钥，并使用这组公私钥生成新的密钥 M。</li>
<li>服务端将新公钥和新密钥 M 加密的数据发给客户端，客户端根据新的服务端公钥和自己原来的私钥计算出本次的密钥 M，进行解密。</li>
<li>之后的客户端和服务端数据交互都使用密钥 M 来完成，密钥 K 只使用 1 次。</li>
</ol>
<p><img src="Network/./images/58ee3d6d55fbb2fb89e29f597ca367a34423dca5.png" alt="" /></p>
<h5 id="232-非首次连接"><a class="header" href="#232-非首次连接">2.3.2 非首次连接</a></h5>
<p>前面提到客户端和服务端首次连接时服务端传递了 config 包，里面包含了服务端公钥和两个随机数，客户端会将 config 存储下来，后续再连接时可以直接使用，从而跳过这个 1RTT，实现 0RTT
的业务数据交互。</p>
<p>客户端保存 config 是有时间期限的，在 config 失效之后仍然需要进行首次连接时的密钥交换。</p>
<h4 id="24-前向安全问题"><a class="header" href="#24-前向安全问题">2.4 前向安全问题</a></h4>
<p>前向安全是密码学领域的专业术语，看下百度上的解释：</p>
<p>前向安全或前向保密 Forward Secrecy 是密码学中通讯协议的安全属性，指的是长期使用的主密钥泄漏不会导致过去的会话密钥泄漏。</p>
<p>前向安全能够保护过去进行的通讯不受密码或密钥在未来暴露的威胁，如果系统具有前向安全性，就可以保证在主密钥泄露时历史通讯的安全，即使系统遭到主动攻击也是如此。</p>
<p>通俗来说，前向安全指的是密钥泄漏也不会让之前加密的数据被泄漏，影响的只有当前，对之前的数据无影响。</p>
<p>前面提到 QUIC 协议首次连接时先后生成了两个加密密钥，由于 config 被客户端存储了，如果期间服务端私钥泄漏，那么可以根据 K = mod p 计算出密钥 K。</p>
<p>如果一直使用这个密钥进行加解密，那么就可以用 K 解密所有历史消息，因此后续又生成了新密钥，使用其进行加解密，当时完成交互时则销毁，从而实现了前向安全。</p>
<p><img src="Network/./images/6c224f4a20a44623fec5572daecb35090df3d767.png" alt="" /></p>
<h4 id="25-前向纠错"><a class="header" href="#25-前向纠错">2.5 前向纠错</a></h4>
<p>前向纠错是通信领域的术语，看下百科的解释：</p>
<p>前向纠错也叫前向纠错码 Forward Error Correction 简称 FEC 是增加数据通讯可信度的方法，在单向通讯信道中，一旦错误被发现，其接收器将无权再请求传输。</p>
<p>FEC 是利用数据进行传输冗余信息的方法，当传输中出现错误，将允许接收器再建数据。</p>
<p>听这段描述就是做校验的，看看 QUIC 协议是如何实现的：</p>
<p>QUIC 每发送一组数据就对这组数据进行异或运算，并将结果作为一个 FEC 包发送出去，接收方收到这一组数据后根据数据包和 FEC 包即可进行校验和纠错。</p>
<h4 id="26-连接迁移"><a class="header" href="#26-连接迁移">2.6 连接迁移</a></h4>
<p>网络切换几乎无时无刻不在发生。</p>
<p>TCP 协议使用五元组来表示一条唯一的连接，当我们从 4G 环境切换到 wifi 环境时，手机的 IP 地址就会发生变化，这时必须创建新的 TCP 连接才能继续传输数据。</p>
<p>QUIC 协议基于 UDP 实现摒弃了五元组的概念，使用 64 位的随机数作为连接的 ID，并使用该 ID 表示连接。</p>
<p>基于 QUIC 协议之下，我们在日常 wifi 和 4G 切换时，或者不同基站之间切换都不会重连，从而提高业务层的体验。</p>
<p><img src="Network/./images/42166d224f4a20a4d314257ea2bbdf25730ed075.png" alt="" /></p>
<h3 id="quic-的应用和前景"><a class="header" href="#quic-的应用和前景">QUIC 的应用和前景</a></h3>
<p>通过前面的一些介绍我们看出来 QUIC 协议虽然是基于 UDP 来实现的，但是它将 TCP 的重要功能都进行了实现和优化，否则使用者是不会买账的。</p>
<p>QUIC 协议的核心思想是将 TCP 协议在内核实现的诸如可靠传输、流量控制、拥塞控制等功能转移到用户态来实现，同时在加密传输方向的尝试也推动了 TLS1.3 的发展。</p>
<p>但是 TCP 协议的势力过于强大，很多网络设备甚至对于 UDP 数据包做了很多不友好的策略，进行拦截从而导致成功连接率下降。</p>
<p>主导者谷歌在自家产品做了很多尝试，国内腾讯公司也做了很多关于 QUIC 协议的尝试。</p>
<p>其中腾讯云对 QUIC 协议表现了很大的兴趣，并做了一些优化然后在一些重点产品中对连接迁移、QUIC 成功率、弱网环境耗时等进行了实验，给出了来自生产环境的诸多宝贵数据。</p>
<p>简单看一组腾讯云在移动互联网场景下的不同丢包率下的请求耗时分布：</p>
<p><img src="Network/./images/3ac79f3df8dcd1009dede5055f620017b8122f94.png" alt="" /></p>
<p>任何新生事物的推动都是需要时间的，出现多年的 HTTP2.0 和 HTTPS 协议的普及度都没有预想高，IPv6 也是如此，不过 QUIC 已经展现了强大的生命力，让我们拭目以待吧！</p>
<p><a href="https://baijiahao.baidu.com/s?id=1677802258258817086&amp;wfr=spider&amp;for=pc">摘自</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vim-编辑器"><a class="header" href="#vim-编辑器">VIM 编辑器</a></h1>
<h2 id="进入编辑模式"><a class="header" href="#进入编辑模式">进入编辑模式：</a></h2>
<table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody>
<tr><td>a</td><td>光标字符后插入</td></tr>
<tr><td>A</td><td>光标行后插入</td></tr>
<tr><td>i</td><td>光标字符前插入</td></tr>
<tr><td>I</td><td>光标行钱插入</td></tr>
<tr><td>o</td><td>光标下插入新行</td></tr>
<tr><td>O</td><td>光标上插入新行</td></tr>
</tbody></table>
<h2 id="定位命令"><a class="header" href="#定位命令">定位命令：</a></h2>
<table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody>
<tr><td>：set nu</td><td>设置行号</td></tr>
<tr><td>：set nonu</td><td>取消行号</td></tr>
<tr><td>gg/G</td><td>gg 第一行，G 最后一行</td></tr>
<tr><td>nG</td><td>到第 n 行</td></tr>
<tr><td>：n</td><td>到第 n 行</td></tr>
<tr><td>$</td><td>移动到行尾</td></tr>
<tr><td>0</td><td>移动到行首</td></tr>
</tbody></table>
<h2 id="删除命令"><a class="header" href="#删除命令">删除命令：</a></h2>
<table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody>
<tr><td>x</td><td>删除光标所在处字符</td></tr>
<tr><td>nx</td><td>删除光标所在处后 n 个字符</td></tr>
<tr><td>dd</td><td>删除光标所在行，输入 n 可以删除 n 行</td></tr>
<tr><td>dG</td><td>删到文件尾</td></tr>
<tr><td>D</td><td>删光标所在到行尾</td></tr>
<tr><td>：n1，n2d</td><td>删除指定范围</td></tr>
</tbody></table>
<h2 id="复制和剪切命令"><a class="header" href="#复制和剪切命令">复制和剪切命令：</a></h2>
<table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody>
<tr><td>yy</td><td>复制当前行</td></tr>
<tr><td>nyy</td><td>复制下 n 行</td></tr>
<tr><td>dd</td><td>剪切当前行</td></tr>
<tr><td>ndd</td><td>剪切以下 n 行</td></tr>
<tr><td>p、P</td><td>粘贴在当前光标所在行下行/上行</td></tr>
</tbody></table>
<h2 id="替换和取消命令"><a class="header" href="#替换和取消命令">替换和取消命令：</a></h2>
<table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody>
<tr><td>r</td><td>取代光标所在处字符</td></tr>
<tr><td>R</td><td>从光标所在处开始替换字符，Esc 结束</td></tr>
<tr><td>u</td><td>取消上一步操作</td></tr>
</tbody></table>
<h2 id="搜索和替换命令"><a class="header" href="#搜索和替换命令">搜索和替换命令：</a></h2>
<table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody>
<tr><td>/string</td><td>搜索指定字符串</td></tr>
<tr><td>n</td><td>搜索指定字符串的下一个出现位置</td></tr>
<tr><td>：%s/old/new/g</td><td>全文替换指定字符串</td></tr>
<tr><td>：n1,n2s/old/new/g</td><td>在一定范围内替换指定字符串</td></tr>
</tbody></table>
<h2 id="保存和退出"><a class="header" href="#保存和退出">保存和退出：</a></h2>
<table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody>
<tr><td>：w</td><td>保存修改</td></tr>
<tr><td>：w new_filename</td><td>另存为指定文件</td></tr>
<tr><td>：wq</td><td>保存修改并退出</td></tr>
<tr><td>ZZ</td><td>保存修改并退出的快捷键</td></tr>
<tr><td>：q！</td><td>不保存修改退出</td></tr>
<tr><td>：wq！</td><td>保存修改并退出（文件所有者及 root 可用）</td></tr>
</tbody></table>
<h2 id="高级操作"><a class="header" href="#高级操作">高级操作：</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="简单命令"><a class="header" href="#简单命令">简单命令</a></h1>
<h2 id="1目录处理命令"><a class="header" href="#1目录处理命令">1.目录处理命令</a></h2>
<h3 id="显示目录ls"><a class="header" href="#显示目录ls">显示目录：ls</a></h3>
<p>英文：list</p>
<p>命令所在目录：/bin/ls</p>
<p>选项：</p>
<p>​ -a：显示所有文件，包括隐藏文件</p>
<p>​ -l：显示详细信息</p>
<p>​ -d：仅显示目录名，不显示目录下的内容列表</p>
<p>​ -h：人性化显示（hommization）</p>
<p>​ -i：查看任意一个文件的 i 节点（类似于身份证唯一信息）</p>
<p>​ -t：用文件和目录的更改时间排序；</p>
<blockquote>
<p>==. 开头的文件除非是目录，否则就是隐藏文件==</p>
</blockquote>
<p>-l：详细信息会显示很多信息</p>
<p>以 -rw-------. 1 root root 1.3k Mar 11 08:05 anacondaks.cfg 为例</p>
<ol>
<li>
<p>第一个表示类型和权限，开头一位表示文件类型。</p>
<p><code>-</code>表示二进制文件，<code>d</code>是目录，<code>l</code>是软连接</p>
<p>之后分三组，一共九位，每组 3 位，分别为 rwx，表示读、写、执行三种权限，每组分别对应 u、g、o</p>
<p>user、group、other。</p>
<p>这里表示用户具有读写权限，没有执行权限，其他无权限。</p>
</li>
<li>
<p>第二个表示所有者，默认是创建者</p>
</li>
<li>
<p>第三个表示所属组</p>
</li>
<li>
<p>第四个表示文件大小，不带单位的是字节</p>
</li>
<li>
<p>后面是文件最后==修改==时间</p>
</li>
<li>
<p>最后是文件名</p>
</li>
</ol>
<blockquote>
<p>Linux 没有明确的创建时间，只有最后一次访问时间、文 件的状态修改时间、文件的数据修改时间</p>
</blockquote>
<table><thead><tr><th>代表字符</th><th>权限</th><th>对文件的含义</th><th>对目录电脑含义</th></tr></thead><tbody>
<tr><td>r</td><td>读权限</td><td>可以查看文件内容</td><td>可以列出目录中的内容</td></tr>
<tr><td>w</td><td>写权限</td><td>可以修改文件内容</td><td>可以在目录中创建、删除文件</td></tr>
<tr><td>x</td><td>执行权限</td><td>可以执行文件件</td><td>可以进入目录</td></tr>
</tbody></table>
<h3 id="创建文件夹mkdir"><a class="header" href="#创建文件夹mkdir">创建文件夹：mkdir</a></h3>
<p>英文：make directories</p>
<p>命令所在目录：/bin/mkdir</p>
<p>选项：</p>
<p>-p 递归创建</p>
<blockquote>
<ol>
<li>如果目录已存在，则提示无法创建</li>
<li>不带参数，会在当前目录下创建目录</li>
<li>不带<code>-p</code>参数，如果新建的文件上级目录不存在则会报错。</li>
<li>想创建需要有访问目录的权限</li>
</ol>
</blockquote>
<h3 id="切换目录cd"><a class="header" href="#切换目录cd">切换目录：cd</a></h3>
<p>英文：change direcotry</p>
<p>命令所在目录：shell <strong>内置命令</strong></p>
<p>用法：</p>
<p>​ 切换到指定目录：cd 绝对/相对路径</p>
<p>​ 回到上一级：cd ..</p>
<p>​ 当前级：cd .</p>
<p>​ 返回进入这个目录之前的目录：cd -</p>
<p>​</p>
<blockquote>
<p>shell 内置命令会比内部命令（bin 下的）快很多，因为 bin 下的执行要创建进程</p>
</blockquote>
<h3 id="显示当前目录pwd"><a class="header" href="#显示当前目录pwd">显示当前目录：pwd</a></h3>
<p>英文：print working directory</p>
<p>命令所在目录：/bin/pwd</p>
<h3 id="删除空目录rmdir"><a class="header" href="#删除空目录rmdir">删除空目录：rmdir</a></h3>
<h3 id="复制文件或目录cp"><a class="header" href="#复制文件或目录cp">复制文件或目录：cp</a></h3>
<p>英文：make directories</p>
<p>命令所在目录：/bin/mkdir</p>
<p>选项：</p>
<p>​ -r ：复制目录</p>
<p>​ -p ：保留文件属性（时间等）</p>
<p>语法：cp -rp 源 目的</p>
<h3 id="剪切文件或目录mv"><a class="header" href="#剪切文件或目录mv">剪切文件或目录：mv</a></h3>
<p>英文：move</p>
<p>命令所在目录：/bin/mv</p>
<p>可以用于更改文件名</p>
<h3 id="删除文件或目录rm"><a class="header" href="#删除文件或目录rm">删除文件或目录：rm</a></h3>
<p>英文：remove</p>
<p>命令所在目录：/bin/rm</p>
<p>参数：</p>
<p>​ -r 删除目录</p>
<p>​ -f 强制执行</p>
<p>​ -i 提醒</p>
<h3 id="创建空文件touch"><a class="header" href="#创建空文件touch">创建空文件：touch</a></h3>
<p>英文：touch</p>
<p>命令所在目录：/bin/touch</p>
<blockquote>
<p>不要有空格，有空格就是两个文件，否则就是用引号</p>
</blockquote>
<p>所有文件默认没有执行权限</p>
<p>所以，所有文件夹默认都是 775 权限</p>
<p>所有文件都是 664 权限</p>
<h3 id="显示文件内容内容较少cat"><a class="header" href="#显示文件内容内容较少cat">显示文件内容（内容较少）：cat</a></h3>
<p>英文：cat</p>
<p>命令所在目录：/bin/cat</p>
<p>参数：</p>
<p>​ -n 显示文件行号</p>
<h3 id="反向显示文件内容少tac"><a class="header" href="#反向显示文件内容少tac">反向显示文件内容（少）：tac</a></h3>
<p>英文：tac</p>
<p>命令所在目录：/bin/tac</p>
<h3 id="分页显示文件内容不能前进翻页more"><a class="header" href="#分页显示文件内容不能前进翻页more">分页显示文件内容（不能前进翻页）：more</a></h3>
<p>英文：more</p>
<p>命令所在目录：/bin/more</p>
<p>命令：</p>
<p>​ 空格或者<code>f</code>翻页（一页一页）</p>
<p>​<code>Enter</code>一行一行</p>
<p>​<code>q</code>,<code>Q</code>退出</p>
<h3 id="分页显示文件内容可以前后翻页less"><a class="header" href="#分页显示文件内容可以前后翻页less">分页显示文件内容（可以前后翻页）：less</a></h3>
<p>英文：less</p>
<p>命令所在目录：/usr/bin/less</p>
<p>命令：</p>
<p>​ 空格或者<code>f</code>或<code>PgDn</code>翻页（一页一页向下）</p>
<p>​<code>PgUp</code>向前翻页</p>
<p>​<code>Enter</code>或下箭头一行一行</p>
<p>​ 上箭头一行一行向前显示</p>
<p>​<code>q</code>,<code>Q</code>退出</p>
<p>​ 输入/想搜索的字符，然后回车可以搜索</p>
<h3 id="显示文件内容指定行数head"><a class="header" href="#显示文件内容指定行数head">显示文件内容（指定行数）：head</a></h3>
<p>英文：head</p>
<p>命令所在目录：/usr/bin/head</p>
<p>命令：</p>
<p>​<code>-n</code>指定显示的行数</p>
<p>不加-n 默认显示前 20 行的数据</p>
<h3 id="反向文件内容命令文件即时更新后也能动态显示多用于日志文件显-示tail"><a class="header" href="#反向文件内容命令文件即时更新后也能动态显示多用于日志文件显-示tail">反向文件内容命令（文件即时更新后也能动态显示，多用于日志文件显 示）：tail</a></h3>
<p>英文：tail</p>
<p>命令所在目录：/usr/bin/tail</p>
<p>参数：</p>
<p>​<code>-n</code>指定显示的行数</p>
<p>​<code>-f</code>动态显示文件末尾内容（文件实时变化就实时展示）</p>
<p>不加-n 默认显示后 20 行的数据</p>
<h2 id="2生成链接文件命令ln"><a class="header" href="#2生成链接文件命令ln">2.生成链接文件命令：ln</a></h2>
<p>英文：link</p>
<p>命令所在目录：/usr/bin/tail</p>
<p>参数：</p>
<p>​ -s 创建软连接</p>
<p>​ 不加就是创建硬链接</p>
<ol>
<li>软连接开头是<code>l</code>，就可以理解为快捷方式。</li>
<li>软连接所有者和所属组具有全部操作的权限，rwxrwxrwx，而硬链接不是。</li>
<li>显示的时候会有个箭头指向</li>
<li>硬链接 = copy + 实时更新</li>
<li>ls -i 命令查看的时候，硬链接和源文件的 i 节点是相同的，软连接是不同的</li>
<li>硬链接不允许指向目录，不允许跨分区创建硬链接</li>
<li>软连接指向的源文件被删除的时候，软连接失效。而硬链接不受影响。</li>
<li>软连接的文件图标上面有个箭头。</li>
</ol>
<h2 id="3权限管理命令chmod"><a class="header" href="#3权限管理命令chmod">3.权限管理命令：chmod</a></h2>
<p>英文：change mode</p>
<p>命令所在目录：/bin/chmod</p>
<p>语法：</p>
<p>​ chmod +-= rwx filename</p>
<p>​ 或者用 chmod (421) fileneme</p>
<p>​ -R 递归修改</p>
<p>​ r -&gt; 4</p>
<p>​ w -&gt; 2</p>
<p>​ x -&gt; 1</p>
<p>对文件：r 为读，w 为修改，x 为可执行</p>
<p>对文件夹：r 为查看文件夹内容，w 可以创建删除文件，x 可以进入文件夹（一般都给）</p>
<h2 id="4更改文件所有者chown"><a class="header" href="#4更改文件所有者chown">4.更改文件所有者：chown</a></h2>
<p>只有 root 可以修改。</p>
<h2 id="5更改组chgrp"><a class="header" href="#5更改组chgrp">5.更改组：chgrp</a></h2>
<p>只有 root 可以修改</p>
<h2 id="6定义默认权限umask"><a class="header" href="#6定义默认权限umask">6.定义默认权限：umask</a></h2>
<p>-S 可以看，显示的是缺失的权限（4.2.1）。</p>
<p>第一位 0 是特殊位，其他的就用 777 减掉已有的权限就有了</p>
<p>一般得到的是 002</p>
<h2 id="7获取帮助文档manhelp"><a class="header" href="#7获取帮助文档manhelp">7.获取帮助文档（man、help）</a></h2>
<p>man + 外部指令</p>
<p>help + shell 内部指令</p>
<p>外部指令 + --help</p>
<h2 id="8用户管理命令"><a class="header" href="#8用户管理命令">8.用户管理命令</a></h2>
<h3 id="81-添加用户useradd"><a class="header" href="#81-添加用户useradd">8.1 添加用户（useradd）</a></h3>
<p>目录： usr/bin/useradd</p>
<p>执行权限：root</p>
<h3 id="82-设置密码passwd"><a class="header" href="#82-设置密码passwd">8.2 设置密码（passwd）</a></h3>
<p>目录：usr/bin/passwd</p>
<p>执行权限：root</p>
<p>root 能修改任何密码，普通用户只能设置自己的密码</p>
<h3 id="83-查询用户简单信息who"><a class="header" href="#83-查询用户简单信息who">8.3 查询用户简单信息（who）</a></h3>
<p>who</p>
<p>目录：usr/bin/who</p>
<h3 id="84-查询用户详细信息w"><a class="header" href="#84-查询用户详细信息w">8.4 查询用户详细信息（w）</a></h3>
<p>w</p>
<p>目录：usr/bin/w</p>
<p>执行权限：root</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="搜索命令"><a class="header" href="#搜索命令">搜索命令</a></h1>
<h2 id="搜索find"><a class="header" href="#搜索find">搜索：find</a></h2>
<p>目录所在：/bin/find</p>
<p>语法：find 搜索范围 匹配条件</p>
<blockquote>
<p>搜索严格区分大小写</p>
</blockquote>
<p>匹配条件：</p>
<p>​<strong>按名字搜索：</strong></p>
<p>​ -name：区分大小写，==不是模糊查询==</p>
<p>​ 通配符：*任意个字符，？任意一个字符。（Ubuntu 中表达式要加引号）</p>
<p>​ -iname：不区分大小写</p>
<p>​ 按文件大小查询：</p>
<p>​ -size：按文件大小查询。后面跟<code>+</code>（大于）或<code>-</code>（小于）或直接数字，数字的单位是数据块（0.5kb/块） ==不足的也占有一块==</p>
<p>​</p>
<p>​<strong>按所属者查找：</strong></p>
<p>​ -user：按所属者</p>
<p>​ -group：按所属组查</p>
<p>​<strong>按时间属性查找：</strong></p>
<p>​ -amin：访问时间</p>
<p>​ -cmin：文件属性被更改</p>
<p>​ -mmin：文件内容被更改</p>
<p>​</p>
<p>​<strong>按照文件类型或者 i 节点查找</strong></p>
<p>​ -type：f 表示文件，d 表示目录，l 表示软连接</p>
<p>​ -inum：根据 i 节点查找</p>
<p>​<strong>组合查找</strong></p>
<p>​ -a ： and</p>
<p>​ -o ： or</p>
<h2 id="搜索命令locate"><a class="header" href="#搜索命令locate">搜索命令：locate</a></h2>
<p>命令目录：/usr/bin/locate</p>
<p><code>find</code>是全盘搜索，<code>locate</code>是在文件资料库中进行搜索。所以比<code>find</code>快很多。</p>
<p>文件资料库（索引）是要不断更新的。新建的文件<code>locate</code>是找不到的。需要使用<code>updatedb</code>来更新索引。</p>
<p>但是/tmp 目录不是索引范围，所以/tmp 文件夹下面的文件是搜索不到的。</p>
<p>默认是模糊查询，不带任何参数。</p>
<h2 id="搜索命令所在的目录和详细信息which"><a class="header" href="#搜索命令所在的目录和详细信息which">搜索命令所在的目录和详细信息：which</a></h2>
<p>命令所在目录：/usr/bin/which</p>
<p>/bin 或/usr/bin，所有人都可以用</p>
<p>/sbin 或/usr/sbin，只有管理员可以用。</p>
<blockquote>
<p>centos 有别名，Ubuntu 没有别名</p>
</blockquote>
<h2 id="搜索命令所在目录以及帮助文档路径whereis"><a class="header" href="#搜索命令所在目录以及帮助文档路径whereis">搜索命令所在目录以及帮助文档路径：whereis</a></h2>
<p>命令所在目录：/usr/bin/whereis</p>
<h2 id="在文件中搜索字符串匹配的行并输出grep"><a class="header" href="#在文件中搜索字符串匹配的行并输出grep">在文件中搜索字符串匹配的行并输出：grep</a></h2>
<p>语法：</p>
<p>​ grep &quot;要匹配的字符&quot; 匹配的文件名</p>
<p>区分大小写，可以加<code>-i</code>指令不区分大小写</p>
<p><code>-v</code>取反。</p>
<p>grep -v “^#” filename 去掉注释</p>
<h2 id="压缩命令"><a class="header" href="#压缩命令">压缩命令</a></h2>
<p>语法：</p>
<p>​ 压缩：gzip 文件名</p>
<p>​ 解压缩：gunzip 文件名</p>
<blockquote>
<p>解压后不保留源文件，不能压缩目录</p>
</blockquote>
<blockquote>
<p>压缩后也不保留源文件</p>
</blockquote>
<h2 id="打包命令"><a class="header" href="#打包命令">打包命令</a></h2>
<p>tar -cvf 压缩后的文件名 要打包的目录</p>
<p>f 必须写在后面：打包并压缩：tar -cxvf</p>
<p>选项：</p>
<p>​ -c 打包</p>
<p>​ -x 解包</p>
<p>​ -z 同时压缩</p>
<p>​ -v 显示详细信息</p>
<p>​ -f 指定文件名（必须在最后）</p>
<p>​</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="网络命令等"><a class="header" href="#网络命令等">网络命令等</a></h1>
<h2 id="测试网络连通性ping"><a class="header" href="#测试网络连通性ping">测试网络连通性：ping</a></h2>
<p>ping 地址</p>
<p>-c 指定发送次数，不指定永远 ping</p>
<h2 id="查看网卡信息ifconfigip-add"><a class="header" href="#查看网卡信息ifconfigip-add">查看网卡信息：ifconfig（ip add）</a></h2>
<p>ifconfig 网卡名称 ip 地址</p>
<h2 id="列出所有登录系统的用户信息last"><a class="header" href="#列出所有登录系统的用户信息last">列出所有登录系统的用户信息：last</a></h2>
<p>last 就可以了</p>
<h2 id="追踪数据包traceroute"><a class="header" href="#追踪数据包traceroute">追踪数据包：traceroute</a></h2>
<p>traceroute ip 地址</p>
<h2 id="显示网络相关信息netstat"><a class="header" href="#显示网络相关信息netstat">显示网络相关信息：netstat</a></h2>
<p>包括端口之类的信息</p>
<p>-t TCP 协议</p>
<p>-u UDP 协议</p>
<p>-l 监听</p>
<p>-r 路由</p>
<p>-n 显示 IP 地址和端口</p>
<h2 id="挂载命令mount"><a class="header" href="#挂载命令mount">挂载命令：mount</a></h2>
<p>给光盘或 U 盘等外设分配盘符，便于访问。</p>
<p>mount -t 文件系统 设备文件名 挂载点</p>
<h2 id="关机shutdown"><a class="header" href="#关机shutdown">关机：shutdown</a></h2>
<p>-c 取消前一个命令</p>
<p>-h 关机</p>
<p>-r 重启</p>
<p>马上关机：shutdown -h now</p>
<p>指定时间关机：shutdown -h 时间</p>
<p>其他关机命令：</p>
<p>​ halt，poweroff，init0</p>
<p>重启：</p>
<p>​ reboot、init6</p>
<p>退出登录：</p>
<p>​ logout</p>
<div style="break-before: page; page-break-before: always;"></div><p>参考：<a href="https://www.jianshu.com/p/447750ec1186">https://www.jianshu.com/p/447750ec1186</a></p>
<pre><code class="language-shell"># 创建安装包目录，把3.7.0换为你要版本即可
mkdir -p /root/Downloads/python_install &amp;&amp; cd /root/Downloads/python_install
# 下载
wget https://www.python.org/ftp/python/3.7.0/Python-3.7.0.tgz
#解压源码包
tar -zxvf Python-3.7.0.tgz
#创建安装目录
mkdir /usr/local/python3
cd Python-3.7.0/
#安装到指定目录
./configure --prefix=/usr/local/python3

#安装一些依赖，ubuntu同名
yum install libffi-devel

# 编译
make &amp;&amp; make install
# 漫长的等待……
</code></pre>
<pre><code class="language-shell">cd /usr/local/python3
ln -s /usr/local/python3/bin/python3 /usr/local/bin//python3
ln -s /usr/local/python3/bin/pip3 /usr/local/bin/pip3

vim ~/.bashrc
增加如下内容
export PATH=$HOME/bin:/usr/local/bin:$PATH
export PATH=PATH=$HOME/bin:/usr/local/python3/bin:/usr/local/bin:$PATH

---------
pip3 install python-openstackclient
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code>CZ7WU-2MF01-488FZ-L6Z5T-PYAU4

CY1TH-0XZ5M-M85NY-MNXGG-ZZHU8

ZZ3EK-62W1P-H803P-4WN7T-Q7HT2

CY75U-ATW0P-H8EYZ-WDZE9-N68D6

GY7EH-DLY86-081EP-4GP59-WFRX0
</code></pre>
<pre><code class="language-shell">sudo apt-get install gcc-6 g++-6

wget https://download3.vmware.com/software/wkst/file/VMware-Workstation-Full-15.5.6-16341506.x86_64.bundle

sudo chmod +x VMware-Workstation-Full-15.5.6-16341506.x86_64.bundle

# install
sudo ./VMware-Workstation-Full-15.5.6-16341506.x86_64.bundle

# uninstall
sudo ./VMware-Workstation-Full-15.5.6-16341506.x86_64.bundle -u vmware-workstation
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="安装-docker"><a class="header" href="#安装-docker">安装 Docker</a></h1>
<h2 id="卸载旧的-docker-相关文件"><a class="header" href="#卸载旧的-docker-相关文件">卸载旧的 Docker 相关文件</a></h2>
<pre><code class="language-shell">sudo yum remove docker \
                docker-client \
                docker-client-latest \
                docker-common \
                docker-latest \
                docker-latest-logrotate \
                docker-logrotate \
                docker-engine
</code></pre>
<h2 id="更换华为源"><a class="header" href="#更换华为源">更换华为源</a></h2>
<pre><code class="language-shell">cp -a /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.bak

wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.huaweicloud.com/repository/conf/CentOS-7-anon.repo

yum clean all
yum makecache
</code></pre>
<h2 id="安装华为源依赖"><a class="header" href="#安装华为源依赖">安装华为源依赖</a></h2>
<pre><code class="language-shell">sudo yum install -y yum-utils

wget -O /etc/yum.repos.d/docker-ce.repo https://mirrors.huaweicloud.com/docker-ce/linux/centos/docker-ce.repo

sudo sed -i 's+download.docker.com+mirrors.huaweicloud.com/docker-ce+' /etc/yum.repos.d/docker-ce.repo

sudo yum makecache fast
</code></pre>
<h2 id="安装-docker-1"><a class="header" href="#安装-docker-1">安装 Docker</a></h2>
<pre><code class="language-shell">sudo yum install docker-ce docker-ce-cli containerd.io

sudo systemctl start docker
</code></pre>
<h2 id="修改-docker-镜像地址"><a class="header" href="#修改-docker-镜像地址">修改 Docker 镜像地址</a></h2>
<pre><code class="language-shell">tee &gt; /etc/docker/daemon.json &lt;&lt; EOF
{
 &quot;registry-mirrors&quot;: [&quot;https://wixr7yss.mirror.aliyuncs.com&quot;, &quot;https://registry.docker-cn.com&quot;]
}
EOF

systemctl restart docker

docker info
</code></pre>
<h2 id="安装-docker-compose"><a class="header" href="#安装-docker-compose">安装 docker-compose</a></h2>
<pre><code class="language-shell">sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.27.0/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose

sudo chmod +x /usr/local/bin/docker-compose

sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose

docker-compose --version
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="git-设置代理"><a class="header" href="#git-设置代理">Git 设置代理</a></h1>
<p>1.设置代理:</p>
<pre><code class="language-shell">git config --global http.proxy http://IP:Port
</code></pre>
<p>2.代理设置完成后，查看设置是否生效：</p>
<pre><code class="language-shell">git config -–get -–global http.proxy
</code></pre>
<p>3.删除代理设置</p>
<pre><code class="language-shell">git config --global --unset http.proxy
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gitlab-ce-的备份和恢复"><a class="header" href="#gitlab-ce-的备份和恢复">Gitlab-ce 的备份和恢复</a></h1>
<h2 id="备份"><a class="header" href="#备份">备份</a></h2>
<pre><code class="language-shell">gitlab-rake gitlab:backup:create
</code></pre>
<p>会产生一个文件在 data 的 backup 里。名字会写。找不到就 find。</p>
<h2 id="恢复"><a class="header" href="#恢复">恢复</a></h2>
<pre><code class="language-shell">gitlab-rake gitlab:backup:restore BACKUP=xxxxx
</code></pre>
<p>BACKUP 后缀会自动补，少写一小段就好了。</p>
<h2 id="升级"><a class="header" href="#升级">升级</a></h2>
<p>直接升级即可。跨版本要按版本升级。参考官方版本升级如下：
<a href="https://docs.gitlab.com/ee/policy/maintenance.html#upgrade-recommendations">https://docs.gitlab.com/ee/policy/maintenance.html#upgrade-recommendations</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="保存本地-commit-记录的同时合并提交到-origin"><a class="header" href="#保存本地-commit-记录的同时合并提交到-origin">保存本地 commit 记录的同时合并提交到 origin</a></h1>
<p>开发中需要让开发分支保持整洁，因此本地分支分为两个。</p>
<ul>
<li>一个是 master 分支，用来和 origin 分支保持一致并提交到 origin 分支。</li>
<li>develop 分支，用来做开发。并保存本地的开发记录（commit 记录，因为 rebase 会丢失 commit 记录，我不想丢失）。</li>
</ul>
<p>现假设我们从 origin 产生本地 master 分支和 develop 分支，在 develop 分支开发，产生了 6 个 commit。</p>
<p>我们现在需要把这四个 commit 合并到 master 分支上并提交到 origin。</p>
<p>图片丢失，幻想一下吧。</p>
<p>那么，假设我们只需要将 commit2、3、4 合并成一个 commit 并整合到 master（比如分到两个开发任务，但是开发的时候忘记提交，代码混合在一起了，但是 2、3、4 是第一个 issue
的），最后 review 并提交到 origin。</p>
<h2 id="step1创建分支并在-develop-产生提交"><a class="header" href="#step1创建分支并在-develop-产生提交">Step1、创建分支并在 develop 产生提交</a></h2>
<p>先注意一下：</p>
<blockquote>
<p>不要通过 rebase 对任何已经提交到公共仓库中的 commit 进行修改（你自己一个人玩的分支除外）。 一般也不会有权限 push 的</p>
</blockquote>
<p>rebase 的作用简要概括为：可以对某一段线性提交历史进行编辑、删除、复制、粘贴；因此，合理使用 rebase 命令可以使我们的提交历史干净、简洁！</p>
<p>以上文字纯属照抄。</p>
<p>首先创建分支：</p>
<pre><code class="language-shell">git branch develop
git branch master(应该克隆下来就有了，按自己的来)
</code></pre>
<p>然后我们切换到 develop 分支进行开发。</p>
<p>以下省略开发无数代码。</p>
<p>那么，现在要做的就是将 2-4 的 commit 放入 master 上，并且合并为同一个。</p>
<h2 id="step2将-commit-复制到-master-上"><a class="header" href="#step2将-commit-复制到-master-上">Step2、将 commit 复制到 master 上</a></h2>
<p>切换到 mater 分支上，然后执行如下命令。</p>
<pre><code class="language-shell">git rebase [startpoint] [endpoint] --onto [branchName]
</code></pre>
<p>startpoint 表示开始的点，endpoint 表示结束点，但是有点左闭右开的意思。</p>
<p>即如果要合并 2、3、4 的 commit 并提交到 master 上，应当是如下语句。</p>
<pre><code class="language-shell">git rebase 8bedc1d 2c1955b --onto master
</code></pre>
<p>前几次提交已经到了 master 分支上了。</p>
<p>那么现在可以进行合并操作了。</p>
<h2 id="step3将-master-上的-commit-合并"><a class="header" href="#step3将-master-上的-commit-合并">Step3、将 master 上的 commit 合并</a></h2>
<pre><code class="language-shell">git rebase -i HEAD~3
</code></pre>
<p>其中<code>-i</code>的意思是<code>--interactive</code>，即弹出交互式的界面让用户编辑完成合并操作，<code>[startpoint] [endpoint]</code>则指定了一个编辑区间，如果不指定<code>[endpoint]</code>，则该区间的终点默认是当前分支
HEAD 所指向的 commit(注：该区间指定的是一个前开后闭的区间)。</p>
<p>之后的界面如下，可以使用 vim 进行编辑。大致解释 git 也给出来了。接下来翻译一下。</p>
<p>图片丢失，自行操作一下吧。</p>
<p>翻译如下：</p>
<blockquote>
<p>pick：保留该 commit（缩写:p）</p>
</blockquote>
<blockquote>
<p>reword：保留该 commit，但我需要修改该 commit 的注释（缩写:r）</p>
</blockquote>
<blockquote>
<p>edit：保留该 commit, 但我要停下来修改该提交(不仅仅修改注释)（缩写:e）</p>
</blockquote>
<blockquote>
<p>squash：将该 commit 和前一个 commit 合并（缩写:s），两个注释分成两行。</p>
</blockquote>
<blockquote>
<p>fixup：将该 commit 和前一个 commit 合并，但我不要保留该提交的注释信息（缩写:f），只保留前一个 commit 信息。</p>
</blockquote>
<blockquote>
<p>exec：执行 shell 命令（缩写:x）</p>
</blockquote>
<blockquote>
<p>drop：我要丢弃该 commit（缩写:d）</p>
</blockquote>
<p>根据我们的需求，只有第一个是 pick，其余全是 squash。</p>
<p>修改如下：</p>
<pre><code class="language-shell">pick dbf1da1 commit 2
s 3454a8f commit 3
s 2c1955b commit 4
</code></pre>
<p>wq 保存之后</p>
<p>这个界面可以类似理解为，已经合并完了，但是要你修改一下 commit 信息。所以按照正常的 commit 信息填写即可。</p>
<p>wq 保存。即可看到变更。</p>
<p>此时已经达到目的了。我们的本地 commit 记录保留下来了，并且 master 上也只有 commit2、3、4 的提交。如果不需要保留本地的 commit 记录，则可以直接从第三步开始操作。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="java-实现多线程的三种方式"><a class="header" href="#java-实现多线程的三种方式">Java 实现多线程的三种方式</a></h1>
<ul>
<li>
<p>继承 Thread 类</p>
</li>
<li>
<p>实现 Runnable 接口（Callable 类）</p>
</li>
</ul>
<h2 id="继承-thread-类"><a class="header" href="#继承-thread-类">继承 Thread 类</a></h2>
<p>Thread 类是一个支持多线程的功能类，只要有一个子类它就可以实现多线程的支持</p>
<pre><code class="language-java">public class MyThread extends Thread {// 多线程的操作类}
</code></pre>
<p>所有程序的起点是 main（）方法，线程的起点是 run（）方法。</p>
<p>在多线程的每个主体类中都要覆写 Thread 类中所提供的 run（）方法。</p>
<pre><code class="language-java">public class MyThread extends Thread(){
    @Override
    public void run(){
        super.run();
    }
}
</code></pre>
<p>所有线程和进程是一样的，要轮流抢占资源，所以多线程执行应该是多个线程彼此交替执行。</p>
<p>如果直接调用 run（）方法，不能直接启动多线程。</p>
<p>而是要使用 start（）方法。（调用此方法执行的方法体是 run（）方法定义的）</p>
<pre><code class="language-java">public synchronized void start() {
        if (threadStatus != 0)
            throw new IllegalThreadStateException();
        group.add(this);
        boolean started = false;
        try {
            start0();
            started = true;
        } finally {
            try {
                if (!started) {
                    group.threadStartFailed(this);
                }
            } catch (Throwable ignore) {
        	}
        }
    }

    private native void start0();
</code></pre>
<p>IllegalThreadStateException 是 RuntimeException 的子类，选择性处理。</p>
<p>如果一个线程对象重复启动，就会抛出此异常。</p>
<p>start0 方法与抽象方法类似，但是使用了 native 声明。（调用操作系统的 API）</p>
<p>所以此操作是 JVM 根据不同的操作系统实现。</p>
<h2 id="实现-runnable-接口"><a class="header" href="#实现-runnable-接口">实现 Runnable 接口</a></h2>
<p><strong>推荐使用这种方法。</strong></p>
<p><strong>虽然 Thread 类可以实现多线程的主体类定义，但是 Java 具有单继承局限，所以针对类的继承都应该回避。</strong></p>
<p><strong>多线程也一样。为了解决单继承的限制，专门实现了 Runnable 接口。</strong></p>
<pre><code class="language-java">@FunctionalInterface
public interface Runnable {
    public abstract void run();
}
</code></pre>
<p>函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。</p>
<p>接口中的所有方法都是 public</p>
<p>只需要让一个类实现 Runnable 接口、覆写 run（）方法，就可以实现多线程。</p>
<p>但是和之前的区别就是，不能直接继承 start 方法。不能通过 start 方法启动。</p>
<p><strong>不论任何情况，要想启动多线程，一定要依靠 Thread 类完成</strong></p>
<p>在 Thread 类中有可以接受 Runnable 接口对象的 constructor</p>
<pre><code class="language-java">class MyThread implements Runnable{
    // 多线程的操作类
    private String name;
    public MyThread(String name){
        this.name = name;
    }
    @Override
    public void run() {
        for (int x = 0 ;x &lt; 200; x++){
            System.out.println(this.name+&quot;----&gt;&quot;+x);
        }
    }
}

public class Main{
    public static void main(String[] args) {
        MyThread mt1 = new MyThread(&quot;线程A&quot;);
        MyThread mt2 = new MyThread(&quot;线程B&quot;);
        MyThread mt3 = new MyThread(&quot;线程C&quot;);
        new Thread(mt1).start();
        new Thread(mt2).start();
        new Thread(mt3).start();
    }
}
</code></pre>
<p>基本工作中基本都是实现 Runnable 接口。</p>
<h2 id="多线程两种实现方式的区别面试题"><a class="header" href="#多线程两种实现方式的区别面试题">多线程两种实现方式的区别（面试题）</a></h2>
<p><strong>1.首先明确，使用 Runnable 比 Thread，解决了单继承的局限性。</strong></p>
<pre><code class="language-java">public class Thread implements Runnable {}
</code></pre>
<p>Thread 类实现了 Runnable 接口。（有 start 方法，就是一个线程对象，可以直接启动）</p>
<p>整个结构有点像代理设计模式。但是代理的话应该也调用 run 方法，但是使用的 start 方法。</p>
<p><strong>2.使用 Runnable 比 Thread 可以更好的描述数据共享的概念。</strong></p>
<p>此时的数据共享指的是多个线程访问同一资源的操作。</p>
<ul>
<li>如果使用 Thread：</li>
</ul>
<pre><code class="language-java">class MyThread extends Thread{
    // 多线程的操作类
    private int ticket = 10;
    @Override
    public void run() {
        for (int x = 0 ;x &lt; 200; x++){
            if (this.ticket &gt; 0){
                System.out.println(&quot;卖票 ，ticket = &quot; + this.ticket--);
            }
        }
    }
}

public class Main{
    public static void main(String[] args) {
        MyThread mt1 = new MyThread();
        MyThread mt2 = new MyThread();
        MyThread mt3 = new MyThread();
        mt1.start();
        mt2.start();
        mt3.start();
    }
}

out:
卖票 ，ticket = 10
卖票 ，ticket = 9
卖票 ，ticket = 8
卖票 ，ticket = 7
卖票 ，ticket = 6
卖票 ，ticket = 5
卖票 ，ticket = 4
卖票 ，ticket = 3
卖票 ，ticket = 2
卖票 ，ticket = 1
卖票 ，ticket = 10
卖票 ，ticket = 9
卖票 ，ticket = 8
卖票 ，ticket = 7
卖票 ，ticket = 6
卖票 ，ticket = 5
卖票 ，ticket = 4
卖票 ，ticket = 3
卖票 ，ticket = 2
卖票 ，ticket = 1
卖票 ，ticket = 10
卖票 ，ticket = 9
卖票 ，ticket = 8
卖票 ，ticket = 7
卖票 ，ticket = 6
卖票 ，ticket = 5
卖票 ，ticket = 4
卖票 ，ticket = 3
卖票 ，ticket = 2
卖票 ，ticket = 1
Process finished with exit code 0
</code></pre>
<ul>
<li>如果使用 Runnable</li>
</ul>
<pre><code class="language-java">class MyThread implements Runnable{
    // 多线程的操作类
    private int ticket = 10;
    @Override
    public void run() {
        for (int x = 0 ;x &lt; 200; x++){
            if (this.ticket &gt; 0){
                System.out.println(&quot;卖票 ，ticket = &quot; + this.ticket--);
            }
        }
    }
}

public class Main{
    public static void main(String[] args) {
        MyThread mt = new MyThread();
        new Thread(mt).start();
        new Thread(mt).start();
        new Thread(mt).start();
    }
}

out:
卖票 ，ticket = 10
卖票 ，ticket = 9
卖票 ，ticket = 8
卖票 ，ticket = 7
卖票 ，ticket = 6
卖票 ，ticket = 5
卖票 ，ticket = 4
卖票 ，ticket = 3
卖票 ，ticket = 2
卖票 ，ticket = 1

Process finished with exit code 0
</code></pre>
<p>这样就实现了数据共享</p>
<h2 id="多线程的第三种实现方式"><a class="header" href="#多线程的第三种实现方式">多线程的第三种实现方式</a></h2>
<p>Runnable 里面的 run 方法不能返回操作结果。</p>
<p>为了解决这样，提供了新的 Callable 接口。</p>
<p>在 java.util.concurrent 包中。</p>
<pre><code class="language-java">@FunctionalInterface
public interface Callable&lt;V&gt; {
    public V call() throws Exception;
}
</code></pre>
<p>返回结果的类型由 Callable 接口上的泛型来决定。</p>
<pre><code class="language-java">class MyThread implements Callable&lt;String&gt;{
    private int ticket = 10;

    @Override
    public String call() throws Exception {
        for (int x = 0 ; x &lt;100 ; x++){
            if(this.ticket&gt;0){
                System.out.println(&quot;卖票，ticket = &quot;+ ticket--);
            }
        }
        return &quot;票已经卖光&quot;;
    }
}
</code></pre>
<p>Thread 类中并没有 Callable 的构造方法，但是 jdk1.5 开始，有 java.util.concurrent.FutureTask<T>类。</p>
<p>专门来负责 Callable 接口类的操作</p>
<pre><code class="language-java">public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; {}
</code></pre>
<pre><code class="language-java">public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; {
    void run();
}
</code></pre>
<p>在 FutureTask 中有如下构造方法</p>
<pre><code class="language-java">public FutureTask(Callable&lt;V&gt; callable) {}
</code></pre>
<p>接受的目的只有一个，取得 call 方法的返回结果。</p>
<pre><code class="language-java">public class Main {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        MyThread mt1 = new MyThread();
        MyThread mt2 = new MyThread();
        FutureTask&lt;String&gt; task1 = new FutureTask&lt;&gt;(mt1);
        FutureTask&lt;String&gt; task2 = new FutureTask&lt;&gt;(mt2);
        // 是Runnable的子类，可以使用Thread来启动
        new Thread(task1).start();
        new Thread(task2).start();
        // 通过get获取返回值
        System.out.println(&quot;A返回&quot;+task1.get());
        System.out.println(&quot;B返回&quot;+task2.get());
    }
}

out：
卖票，ticket = 10
卖票，ticket = 9
卖票，ticket = 8
卖票，ticket = 7
卖票，ticket = 6
卖票，ticket = 5
卖票，ticket = 4
卖票，ticket = 10
卖票，ticket = 3
卖票，ticket = 9
卖票，ticket = 2
卖票，ticket = 8
卖票，ticket = 1
卖票，ticket = 7
卖票，ticket = 6
卖票，ticket = 5
卖票，ticket = 4
卖票，ticket = 3
A返回票已经卖光
卖票，ticket = 2
卖票，ticket = 1
B返回票已经卖光

Process finished with exit code 0
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="多线程的常用操作方法"><a class="header" href="#多线程的常用操作方法">多线程的常用操作方法</a></h1>
<h2 id="1线程的命名与取得"><a class="header" href="#1线程的命名与取得">1.线程的命名与取得</a></h2>
<p>所有线程程序的执行，会根据自己的情况进行资源抢占。要区分线程，就要依靠线程的名字。</p>
<p>对于线程的名字，一般而言，会在其启动之前进行定义。不建议对已启动的线程进行命名或修改。也不建议命名重复。</p>
<p>如果想要进行线程名称的操作，Thread 有如下方法：</p>
<ul>
<li>
<p>构造方法：</p>
<pre><code class="language-java">public Thread(Runnable target, String name){}
</code></pre>
<p>其他也有很多构造方法包含 name 参数进行命名。</p>
</li>
<li>
<p>通过 set 方法设置名字</p>
<pre><code class="language-java">public final String getName() {
        return name;
}
</code></pre>
</li>
<li>
<p>通过 get 方法取得名字</p>
<pre><code class="language-java">public final String getName() {
	return name;
}
</code></pre>
</li>
</ul>
<p>对于线程名字操作有个问题，这些方法是属于 Thread 的，使用 Runnable 的话。</p>
<p>那么能够取得的就是当前执行本方法的线程名字。</p>
<p>所以 Thread 中有一个取得当前线程的方法。</p>
<ul>
<li>
<pre><code class="language-java">public static native Thread currentThread();
</code></pre>
</li>
</ul>
<p>如果在实例化 Thread 对象的时候没有命名，那么会自动进行编号命名，保证对象不重复。</p>
<pre><code class="language-java">class MyThread implements Runnable{
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName());
    }
}

public class Main {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        MyThread mt = new MyThread();
        new Thread(mt).start();
        new Thread(mt).start();
        new Thread(mt).start();
    }
}


out:
Thread-0
Thread-1
Thread-2

Process finished with exit code 0
</code></pre>
<p>对于直接调用 run 方法有如下情况：</p>
<pre><code class="language-java">class MyThread implements Runnable{
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName());
    }
}

public class Main {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        MyThread mt = new MyThread();
        new Thread(mt,&quot;A&quot;).start();
        mt.run();
    }
}

out:
main
A

Process finished with exit code 0
</code></pre>
<p>run 方法打印了 main，即 main 线程。</p>
<p>所有在 main 方法上创建的线程实例都可以将其表示为子线程。</p>
<p>线程一直存在，主方法就是主线程。</p>
<p>进程是在用 java 命令解释一个程序类的时候启动的。</p>
<p>对于操作系统而言，都相当于启动了一个新的进程，main 只是这个新进程中的子线程。</p>
<p><strong><u>每个 JVM 进程启动的时候至少启动几个线程？</u></strong></p>
<ul>
<li>main 线程：程序的主要执行，以及启动子线程；</li>
<li>gc 线程：进行垃圾处理；</li>
</ul>
<h2 id="2线程的休眠"><a class="header" href="#2线程的休眠">2.线程的休眠</a></h2>
<p>让线程的执行速度稍微变慢一点。</p>
<p>休眠的方法：</p>
<pre><code class="language-java">public static void sleep(long millis) throws InterruptedException{}
</code></pre>
<p>默认情况下，如果休眠的时候如果设置了多个线程对象，那么所有线程将“一起”进入 run()方法。</p>
<p>因为先后顺序太短了，实际上是几微秒到几毫秒的区别。</p>
<h2 id="3线程的优先级"><a class="header" href="#3线程的优先级">3.线程的优先级</a></h2>
<p>所谓的优先级指的是越高的优先级，越有可能先执行。在 Thread 中有两个方法进行优先级操作。</p>
<ul>
<li>
<p>设置优先级：</p>
<pre><code class="language-java">public final void setPriority(int newPriority) { }
</code></pre>
</li>
<li>
<p>取得优先级：</p>
<pre><code class="language-java">public final int getPriority() { }
</code></pre>
</li>
</ul>
<p>参数是 int 类型。对于此内容有三种取值</p>
<pre><code class="language-java">public final static int MIN_PRIORITY = 1;

    public final static int NORM_PRIORITY = 5; //默认

    public final static int MAX_PRIORITY = 10;
</code></pre>
<p><strong>主线程的优先级是？</strong></p>
<p>​ 主线程属于中等优先级 ( 5 )</p>
<h2 id="4线程的同步与死锁"><a class="header" href="#4线程的同步与死锁">4.线程的同步与死锁</a></h2>
<ol>
<li>
<p>线程的同步产生的原因</p>
</li>
<li>
<p>线程的同步处理操作</p>
</li>
<li>
<p>线程的死锁情况</p>
</li>
</ol>
<p>同步：</p>
<p>多个线程访问同一资源时，资源的重复读的类似的问题。</p>
<pre><code class="language-java">class MyThread implements Runnable{
    private int ticket = 5;
    @Override
    public void run() {
        for (int i = 0 ; i &lt; 20 ; i++){
            if (this.ticket &gt; 0){
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() + &quot;卖票 ， ticket = &quot;+ticket--);
            }
        }
    }
}

public class Main {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        Thread.currentThread().getPriority();
        MyThread mt = new MyThread();
        Thread t1 = new Thread(mt,&quot;A&quot;);
        Thread t2 = new Thread(mt,&quot;B&quot;);
        Thread t3 = new Thread(mt,&quot;C&quot;);
        t1.start();
        t2.start();
        t3.start();
    }
}


out:
A卖票 ， ticket = 4
B卖票 ， ticket = 4
C卖票 ， ticket = 5
A卖票 ， ticket = 3
B卖票 ， ticket = 2
C卖票 ， ticket = 3
C卖票 ， ticket = 1
B卖票 ， ticket = 0
A卖票 ， ticket = -1

Process finished with exit code 0
</code></pre>
<p>出现了负数，这是因为出现了延迟，数据重复读了。</p>
<h3 id="同步操作"><a class="header" href="#同步操作">同步操作</a></h3>
<p>​ 问题就出现在判断和修改数据是分开完成的。</p>
<p>可以使用 synchronized 关键字实现同步。有两种方法：</p>
<ol>
<li>同步代码块</li>
<li>同步方法</li>
</ol>
<pre><code class="language-java">class MyThread implements Runnable{
    private int ticket = 5;
    @Override
    public void run() {
        for (int i = 0 ; i &lt; 20 ; i++){
            synchronized (this){	//同步代码块
                if (this.ticket &gt; 0){
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println(Thread.currentThread().getName() + &quot;卖票 ， ticket = &quot;+ticket--);
                }
            }
        }
    }
}
</code></pre>
<pre><code class="language-java">class MyThread implements Runnable {
    private int ticket = 20;
    @Override
    public void run() {
        for (int i = 0; i &lt; 20; i++) {
            this.sale();
        }
    }
    public synchronized void sale() {
        if (this.ticket &gt; 0) {
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + &quot;卖票 ， ticket = &quot; + ticket--);
        }
    }
}
</code></pre>
<p>推荐使用同步方法。</p>
<p>多个线程访问同一个资源的时候一定要使用同步。（同步的是数据）</p>
<h3 id="死锁"><a class="header" href="#死锁">死锁</a></h3>
<p>所谓的同步就是一个对象等待另一个线程对象执行完毕的操作形式。</p>
<p>线程同步过多有可能造成死锁。</p>
<p>死锁产生的情况：</p>
<p>我说：你给我本子我就给你笔，</p>
<p>你说：你给我笔我就给你本子。</p>
<p>双方都等不到，都占用着，逻辑错误！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="03-生产者消费者实战"><a class="header" href="#03-生产者消费者实战">03-生产者消费者实战</a></h1>
<ol>
<li>生产者和消费者问题的产生</li>
<li>Object 类多多线程的支持</li>
</ol>
<h2 id="问题的引出"><a class="header" href="#问题的引出">问题的引出</a></h2>
<p>生产者和消费者是两个不同的线程类对象，操作同一资源的情况。</p>
<ol>
<li>生产者生产数据，消费者幅取走数据；</li>
<li>生产者每生产完一组数据之后，消费者就要取走一组数据</li>
</ol>
<pre><code class="language-java">class Info {
    private String title;
    private String content;

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public String getContent() {
        return content;
    }

    public void setContent(String content) {
        this.content = content;
    }
}

class Productor implements Runnable {
    private Info info;

    public Productor(Info info) {
        this.info = info;
    }

    @Override
    public void run() {
        for (int x = 0; x &lt; 100; x++) {
            if (x % 2 == 0) {
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                this.info.setTitle(&quot;AAA&quot;);
                this.info.setContent(&quot;AAA---&quot;);
            } else {
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                this.info.setTitle(&quot;BBB&quot;);
                this.info.setContent(&quot;BBB---&quot;);
            }
        }
    }
}

class Customer implements Runnable {
    private Info info;

    public Customer(Info info) {
        this.info = info;
    }

    @Override
    public void run() {
        for (int x = 0; x &lt; 100; x++) {
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(this.info.getTitle() + &quot;-&quot; + this.info.getContent());
        }
    }
}


public class Main {
    public static void main(String[] args) {
        Info info = new Info();
        new Thread(new Productor(info)).start();
        new Thread(new Customer(info)).start();
    }
}
</code></pre>
<p>以上代码会产生脏读，重复读的问题。</p>
<ul>
<li>数据错位</li>
<li>数据重复取出，重复设置</li>
</ul>
<h2 id="解决数据错乱问题"><a class="header" href="#解决数据错乱问题">解决数据错乱问题</a></h2>
<p>因为非同步的操作所造成的，所以应该使用同步处理（synchronized）</p>
<p>因为设置和取想进行同步控制，所以要定义在一个类里面完成。</p>
<pre><code class="language-java">class Info {
    private String title;
    private String content;

    public synchronized void set(String title,String content){
        this.title=title;
        try {
            Thread.sleep(200);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        this.content=content;
    }
    public synchronized void get(){
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(this.title + &quot;-&quot; + this.content);
    }
}

class Productor implements Runnable {
    private Info info;

    public Productor(Info info) {
        this.info = info;
    }

    @Override
    public void run() {
        for (int x = 0; x &lt; 100; x++) {
            if (x % 2 == 0) {
                this.info.set(&quot;AAA&quot;,&quot;AAA---&quot;);
            } else {
                this.info.set(&quot;BBB&quot;,&quot;BBB---&quot;);
            }
        }
    }
}

class Customer implements Runnable {
    private Info info;

    public Customer(Info info) {
        this.info = info;
    }

    @Override
    public void run() {
        for (int x = 0; x &lt; 100; x++) {
            this.info.get();
        }
    }
}

public class Main {
    public static void main(String[] args) {
        Info info = new Info();
        new Thread(new Productor(info)).start();
        new Thread(new Customer(info)).start();
    }
}
</code></pre>
<p>上述代码解决了数据错乱的问题，但是重复操作的问题更加严重。</p>
<h2 id="解决重复的问题"><a class="header" href="#解决重复的问题">解决重复的问题</a></h2>
<p>如果要实现整个代码的操作，但是必须加入等待与唤醒机制。</p>
<p>在 Object 类中提供了专有方法。</p>
<ol>
<li>等待方法：</li>
</ol>
<pre><code class="language-java">public final void wait() throws InterruptedException { }
</code></pre>
<ol start="2">
<li>唤醒第一个等待线程：</li>
</ol>
<pre><code class="language-java">public final native void notify();
</code></pre>
<ol start="3">
<li>唤醒全部等待线程，哪个优先级高就先执行哪一个：</li>
</ol>
<pre><code class="language-java">public final native void notifyAll();
</code></pre>
<p>因此使用上述方法解决重复问题：</p>
<pre><code class="language-java">class Info {
    private String title;
    private String content;
    // True 表示可以生产，不可以取走
    // False 表示可以取走，不可以生产
    private boolean flag = true;
    public synchronized void set(String title,String content){
        if (this.flag == false){
            try {
                super.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        this.title=title;
        try {
            Thread.sleep(200);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        this.content=content;
        this.flag=false; //修改生产标记
        super.notify(); //唤醒其他等待线程
    }
    public synchronized void get(){
        if (this.flag==true){
            try {
                super.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(this.title + &quot;-&quot; + this.content);
        this.flag=true;
        super.notify();
    }
}

class Productor implements Runnable {
    private Info info;

    public Productor(Info info) {
        this.info = info;
    }

    @Override
    public void run() {
        for (int x = 0; x &lt; 100; x++) {
            if (x % 2 == 0) {
                this.info.set(&quot;AAA&quot;,&quot;AAA---&quot;);
            } else {
                this.info.set(&quot;BBB&quot;,&quot;BBB---&quot;);
            }
        }
    }
}

class Customer implements Runnable {
    private Info info;

    public Customer(Info info) {
        this.info = info;
    }

    @Override
    public void run() {
        for (int x = 0; x &lt; 100; x++) {
            this.info.get();
        }
    }
}

public class Main {
    public static void main(String[] args) {
        Info info = new Info();
        new Thread(new Productor(info)).start();
        new Thread(new Customer(info)).start();
    }
}
</code></pre>
<p>至此，程序按照我们的预期执行。生产一个取一个。</p>
<h2 id="面试题解释-sleep-和-wait-的区别"><a class="header" href="#面试题解释-sleep-和-wait-的区别">面试题：解释 sleep 和 wait 的区别？</a></h2>
<ul>
<li>sleep()是 Thread 类定义的方法，wait()是 Object 类定义的方法</li>
<li>sleep()可以设置休眠时间，时间到了自动唤醒，wait()必须等待 notify()唤醒。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="04-stringbuffer-类"><a class="header" href="#04-stringbuffer-类">04-StringBuffer 类</a></h1>
<ol>
<li>StringBuffer 类的主要特点；</li>
<li>StringBuffer、StringBuilder、String 的区别；</li>
</ol>
<h2 id="1-string-类的特点"><a class="header" href="#1-string-类的特点">1. String 类的特点：</a></h2>
<ul>
<li>String 类对象有两种实例化方式：
<ul>
<li>直接赋值：只开辟一块堆内存空间，可以自动入池；</li>
<li>构造方法：开辟两块堆内存空间，不会自动入池，使用 intern()手工入池；</li>
</ul>
</li>
<li>任何一个字符串都是 String 类的匿名对象；</li>
<li><strong>字符串一旦声明不可改变</strong>，可以改变的只是 String 类对象的引用。</li>
</ul>
<h2 id="2-stringbuffer-类的引出"><a class="header" href="#2-stringbuffer-类的引出">2. StringBuffer 类的引出</a></h2>
<p>生产中，字符串的操作往往很多。</p>
<p>因此在 Java 中，<strong>有 StringBuffer 类，里面的内容可以修改。</strong></p>
<p>String 类可以使用+进行字符串连接操作。</p>
<p>StringBuffer 类必须使用 append 进行字符串连接。（继续返回 StringBuffer 类对象）</p>
<table><thead><tr><th>String 类</th><th>StringBuffer 类</th></tr></thead><tbody>
<tr><td>public final class String implements java.io.Serializable, Comparable<String>, <strong>CharSequence</strong> { }</td><td>public final class StringBuffer extends AbstractStringBuilder implements java.io.Serializable, <strong>CharSequence</strong> { }</td></tr>
</tbody></table>
<p>都是 CharSequence 接口的子类。</p>
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        // 向上转型，String是CharSequence接口的子类。
        CharSequence cs = &quot;Hello&quot;;
		// 可以输出Hello，调用了String类覆写的toString()方法
        System.out.println(cs);
    }
}
</code></pre>
<p>虽然 String 和 StringBuffer 类有共同的接口，但是这两个类不能直接转换</p>
<h2 id="3-互相转换"><a class="header" href="#3-互相转换">3. 互相转换</a></h2>
<h3 id="1-string---stringbuffer"><a class="header" href="#1-string---stringbuffer">1. String -&gt; StringBuffer</a></h3>
<ul>
<li>利用 StringBuffer 的构造方法。</li>
<li>利用 append 方法。</li>
</ul>
<h3 id="2-stringbuffer---string"><a class="header" href="#2-stringbuffer---string">2. StringBuffer -&gt; String</a></h3>
<ul>
<li>利用 toString()方法</li>
<li>利用 String 类的构造方法</li>
</ul>
<h3 id="神奇的发现"><a class="header" href="#神奇的发现">神奇的发现：</a></h3>
<p>String 类中提供有一个和 StringBuffer 类比较的方法：</p>
<pre><code class="language-java">public boolean contentEquals(StringBuffer sb) { }
</code></pre>
<h2 id="4-stringbuffer-类的操作方法"><a class="header" href="#4-stringbuffer-类的操作方法">4. StringBuffer 类的操作方法</a></h2>
<ol>
<li>字符串反转：</li>
</ol>
<pre><code class="language-java">public synchronized StringBuffer reverse() { }
</code></pre>
<ol start="2">
<li>在指定索引位置增加数据：</li>
</ol>
<pre><code class="language-java">public synchronized StringBuffer insert(int index, char[] str, int offset,int len) { }
</code></pre>
<ol start="3">
<li>删除部分数据：</li>
</ol>
<pre><code class="language-java">public synchronized StringBuffer delete(int start, int end) { }
</code></pre>
<h2 id="5stringbuilder-类"><a class="header" href="#5stringbuilder-类">5.StringBuilder 类</a></h2>
<p>JDK1.5 之后增加了一个新的字符串操作类：StringBuilder 类</p>
<pre><code class="language-java">public final class StringBuilder
    extends AbstractStringBuilder
    implements java.io.Serializable, CharSequence
</code></pre>
<p>定义结构和 StringBuffer 类是一样的，StringBuffer 的大部分方法都有。</p>
<p>但是 StringBuilder 不使用 synchronized 修饰方法。</p>
<p><strong>面试题：解释 String，StringBuffer，StringBuilder 的区别</strong></p>
<ul>
<li>String 的内容一旦声明不能改变，StringBuilder 和 StringBuffer 可以改变</li>
<li>StringBuffer 类中提供的方法都是同步方法，属于安全的线程操作，而 StringBuilder 使用异步的，属于不安全的线程操作</li>
</ul>
<p>结论：生产过程中，95%使用 String 类，只有需要频繁修改操作的时候才考虑使用 StringBuffer 和 StringBuilder。</p>
<p>String 类依然是最常用的</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="05-runtime-类"><a class="header" href="#05-runtime-类">05-RunTime 类</a></h1>
<ol>
<li>RunTime 类的主要作用；</li>
<li>RunTime 类的定义形式；</li>
</ol>
<p>在每个 JVM 进程里面都会存在 RunTime 类的对象，</p>
<p>主要是取得与运行时有关的环境属性或者是创建新的进程之类的有关操作</p>
<p>在 RunTime 类定义的时候，它的构造方法已经被私有化了，属于单例模式。</p>
<p>所以有一个 static 的方法获取实例化的对象：</p>
<pre><code class="language-java">public static Runtime getRuntime() {
    return currentRuntime;
}
</code></pre>
<p>RunTime 类是直接与本地运行有关的所有相关属性的集合</p>
<p>有如下方法：</p>
<ol>
<li>返回所有可用内存空间</li>
</ol>
<pre><code class="language-java">public native long totalMemory();
</code></pre>
<ol start="2">
<li>返回最大可用内存空间</li>
</ol>
<pre><code class="language-java">public native long maxMemory();
</code></pre>
<ol start="3">
<li>返回空余内存空间</li>
</ol>
<pre><code class="language-java">public native long freeMemory();
</code></pre>
<ol start="4">
<li>产生了过多的垃圾之后会影响空间，释放垃圾空间</li>
</ol>
<pre><code class="language-java">public native void gc();
</code></pre>
<p><strong>面试题：解释什么叫 GC，如何处理？</strong></p>
<ul>
<li>GC，即 garbage collector，垃圾收集器，指的是释放无用的内存空间。</li>
<li>GC 会由系统不定期进行自动的回收，或者调用 RunTime 类的 gc()方法手工回收。</li>
</ul>
<p><strong>RunTime 可以调用本机的可执行程序，并且可以创建进程。</strong></p>
<pre><code class="language-java">public Process exec(String command) throws IOException { }
</code></pre>
<p>创建之后会返回一个 Process 对象，通过 Process 对象的 destroy 方法可以销毁进程。</p>
<pre><code class="language-java">public class Main{
    public static void main(String[] args) throws IOException, InterruptedException {
        Runtime runtime = Runtime.getRuntime();
        Process pro = runtime.exec(&quot;mspaint.exe&quot;);
        Thread.sleep(2000);
        pro.destroy();
    }
}
</code></pre>
<p>意义不大。</p>
<p><strong>总结：</strong></p>
<ol>
<li>RunTime 使用类单例设计模式，必须使用 getRunTime 方法获取。</li>
<li>提供了 gc 方法，用于手工释放内存。</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="06-system-类"><a class="header" href="#06-system-类">06-System 类</a></h1>
<ol>
<li>如何计算某个代码的执行时间；</li>
<li>进行垃圾收集操作</li>
</ol>
<p>通过 System.currentTimeMillis()获取系统当前时间。</p>
<p>相减即可获得代码执行时间。</p>
<p>System 类的 gc 操作，就是 RunTime 类中的 gc 操作。</p>
<p>一个对象产生，会调用构造方法。</p>
<p>如果需要给对象销毁一些操作。可以考虑覆写 Object 类的 finalize 方法。</p>
<p>finalize 是留给对象回收前使用的。</p>
<p><strong>面试题：解释 final、finally、finalize 的区别</strong></p>
<ul>
<li>
<p>final：定义不能被继承的类、不能被覆写的方法、常量。</p>
</li>
<li>
<p>finally：异常的统一出口</p>
</li>
<li>
<p>finalize：方法，Object 提供的方法。（protected void finalize() throws Throwable），即使出现了异常也不会导致程序中断执行。</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="07-对象克隆"><a class="header" href="#07-对象克隆">07-对象克隆</a></h1>
<ol>
<li>清楚对象克隆的操作结构</li>
<li>巩固接口的作用</li>
</ol>
<p>克隆的定义：</p>
<p>​ 对象克隆指的是对象的复制操作。</p>
<p>​ 在 Object 类中提供了用于复制的操作。（clone)</p>
<pre><code class="language-java">protected native Object clone() throws CloneNotSupportedException;
</code></pre>
<p>此方法抛出 CloneNotSupportedException 异常。</p>
<p>如果要使用对象克隆的类没有实现 Cloneable 的接口，就会抛出此异常。</p>
<pre><code class="language-java">public interface Cloneable { }
</code></pre>
<p>此为标识接口，表示一种操作能力。里面没有任何方法。</p>
<p>接口的作用：</p>
<ul>
<li>制定标准</li>
<li>标识接口，表示一种操作能力</li>
</ul>
<p>可以直接覆写 clone（）方法。改为 public</p>
<p>即可进行调用，调用后是深克隆。不是拷贝的引用。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数学操作类mathrandom大数字操作类"><a class="header" href="#数学操作类mathrandom大数字操作类">数学操作类（Math、Random、大数字操作类）</a></h1>
<h2 id="1-math-类了解"><a class="header" href="#1-math-类了解">1. Math 类（了解）</a></h2>
<p>专门进行数学计算的操作类。</p>
<p>所有方法都是 static 方法。因为 Math 类没有普通属性。</p>
<p>比较要注意的是四舍五入：</p>
<pre><code class="language-java">public static long round(double a) { }
</code></pre>
<p>对于正数而言，大于等于 0.5 就进 1</p>
<p>对于负数而言，小数位大于 0.5 才进位（不包含等于！只有 java 的 Math 会这样）</p>
<pre><code class="language-java">public class Main{
    public static void main(String[] args){
        System.out.println(Math.round(15.5));
        System.out.println(Math.round(-15.5));
        System.out.println(Math.round(-15.51));
    }
}

out:
16
-15
-16

Process finished with exit code 0
</code></pre>
<h2 id="2-random-类"><a class="header" href="#2-random-类">2. Random 类</a></h2>
<p>主要功能是取得随机数的操作</p>
<p><strong>例子：产生 10 个不大于 100 的正整数</strong></p>
<pre><code class="language-java">public class Main{
    public static void main(String[] args){
        Random rand = new Random();
        for (int i = 0 ; i&lt; 10 ; i++){
            System.out.print(rand.nextInt(100) + &quot;、&quot; );
        }
    }
}

out:
44、59、79、94、54、67、71、56、9、86、
Process finished with exit code 0
</code></pre>
<p><strong>例子：36 选 7</strong></p>
<p>最大值是 36，边界值是 37，并且里面不能有 0 或者是重复的数据。</p>
<pre><code class="language-java">import java.util.Random;

public class Main{
    public static void main(String[] args){
        Random rand = new Random();
        int data[] = new int[7];
        int foot = 0;
        while(foot &lt; 7){
            int t = rand.nextInt(37);
            if (!isRepeat(data,t)){
                data[ foot ++ ] = t;
            }
        }
        java.util.Arrays.sort(data);
        for (int i = 0 ; i&lt; data.length;i++){
            System.out.println(data[i]+&quot;、&quot;);
        }
    }

    /**
     * 判断是否存在重复的内容，但是不允许保存0
     * @param temp 指的是已经保存的数据
     * @param num 新生成的数据
     * @return 存在true，否则返回false
     */
    public static boolean isRepeat(int temp[],int num){
        if (num==0){
            return true;
        }
        for (int i = 0; i &lt; temp.length ; i++){
            if (temp[i] == num){
                return true;
            }
        }
        return false;
    }
}
</code></pre>
<h2 id="3-biginteger-大整数操作类"><a class="header" href="#3-biginteger-大整数操作类">3. BigInteger 大整数操作类</a></h2>
<p>如果数值很大，首先考虑使用 double。但是超出之后，用什么？</p>
<pre><code class="language-java">class Main {
    public static void main(String [] args){
        System.out.println(Double.MAX_VALUE*Double.MAX_VALUE);
    }
}

out:
Infinity

Process finished with exit code 0
</code></pre>
<p>首先不使用 Double 保存，只有使用 String 进行保存。</p>
<p>java.math 中提供了 BigInteger 和 BigDecimal 类进行大数操作（可以接受 String 构造）</p>
<p>例子：</p>
<pre><code class="language-java">import java.math.BigInteger;

class Main {
    public static void main(String [] args){
        BigInteger bigA = new BigInteger(&quot;2212316548977456&quot;);
        BigInteger bigB = new BigInteger(&quot;98756456&quot;);
        System.out.println(bigA.add(bigB));
        System.out.println(bigA.subtract(bigB));
        System.out.println(bigA.multiply(bigB));
        System.out.println(bigA.divide(bigB));
        //返回两个数，一个商，一个余数
        BigInteger result[] = bigA.divideAndRemainder(bigB);
        System.out.println(&quot;商：&quot;+ result[0] + &quot; , 余数：&quot;+result[1]);
    }
}

out:
2212316647733912
2212316450221000
218480541927163978455936
22401740
商：22401740 , 余数：98344016

Process finished with exit code 0
</code></pre>
<h2 id="4-bigdecimal-大浮点数"><a class="header" href="#4-bigdecimal-大浮点数">4. BigDecimal 大浮点数</a></h2>
<p>BigInteger 不能存小数，BigDecimal 可以保存小数。</p>
<ul>
<li>构造 1 接受 String</li>
<li>构造 2 接受 double</li>
</ul>
<p><strong>但是 BigInteger 不能接受 int 构造</strong></p>
<p>BigDecimal 也支持大量基础数学计算。</p>
<p>但是利用 BigDecimal 进行准确的四舍五入操作 ！</p>
<p>但是没有直接的提供四舍五入的操作，我们可以利用除法操作来实现。</p>
<pre><code class="language-java">public BigDecimal divide(BigDecimal divisor, int scale, RoundingMode roundingMode) {
    return divide(divisor, scale, roundingMode.oldMode);
}
</code></pre>
<p>BigDecimal divisor：是被除数</p>
<p>int scale：保留的小数位数</p>
<p>RoundingMode roundingMode：进位模式</p>
<p><strong>进行准确的四舍五入</strong></p>
<pre><code class="language-java">/**
 * 实现准确的四舍五入操作
 * @param num 操作数
 * @param scale 保留的小数位数
 * @return
 */
 public static double round(double num ,int scale){
	 BigDecimal bigA = new BigDecimal(num);
     BigDecimal bigB = new BigDecimal(1);
     return bigA.divide(bigB, scale,BigDecimal.ROUND_HALF_UP).doubleValue();
 }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="09-日期处理"><a class="header" href="#09-日期处理">09-日期处理</a></h1>
<ol>
<li>Date 类的使用；</li>
<li>Calendar 类的使用；</li>
<li>SimpleDateFormat 类的使用；</li>
</ol>
<h2 id="date"><a class="header" href="#date">Date</a></h2>
<p>java 里面有个 java.util.Date，直接表示当前时间。</p>
<pre><code class="language-java">import java.util.Date;

class Main {
    public static void main(String [] args){
        Date date = new Date();
        System.out.println(date);
    }
}

out：
Wed Jul 31 09:45:17 CST 2019

Process finished with exit code 0
</code></pre>
<p>Date 的构造方法：</p>
<ul>
<li>无参构造：public Date()；</li>
<li>有参构造：public Date(long date)，接受 long 型数据；</li>
<li>转换为 long 型：public long getTime()</li>
</ul>
<p>Date 与 long 的转换。</p>
<pre><code class="language-java">import java.util.Date;

class Main {
    public static void main(String [] args){
        long cur = System.currentTimeMillis();
        Date date = new Date(cur);
        System.out.println(date);
        System.out.println(cur);
        System.out.println(date.getTime());
    }
}

out:
Wed Jul 31 10:15:43 CST 2019
1564539343189
1564539343189
</code></pre>
<p>getTime 方法是一个重要的方法！</p>
<h2 id="日期格式化simpledateformat核心"><a class="header" href="#日期格式化simpledateformat核心">日期格式化：SimpleDateFormat(核心)</a></h2>
<p>java.text 是一个专门处理格式的国际化的包。</p>
<p>SimpleDateFormat 是里面一个处理日期的，将日期转换为 String 型的形式显示。</p>
<p>主要使用以下方法：</p>
<ul>
<li>构造函数：public SimpleDateFormat(String pattern)，需要传入转换格式；</li>
<li>将 Date 转换为 String：public final String format(Date date)；</li>
<li>将 String 转换为 Date：public Date parse(String source) throws ParseException；</li>
</ul>
<p>关键在于转换格式上：</p>
<table><thead><tr><th>名称</th><th>格式</th></tr></thead><tbody>
<tr><td>年</td><td>yyyy</td></tr>
<tr><td>月</td><td>MM</td></tr>
<tr><td>日</td><td>dd</td></tr>
<tr><td>时</td><td>HH</td></tr>
<tr><td>分</td><td>mm</td></tr>
<tr><td>秒</td><td>ss</td></tr>
<tr><td>毫秒</td><td>SSS</td></tr>
</tbody></table>
<p><strong>范例：将日期格式化显示</strong></p>
<pre><code class="language-java">import java.text.SimpleDateFormat;
import java.util.Date;

class Main {
    public static void main(String [] args){
        long cur = System.currentTimeMillis();
        Date date = new Date(cur);
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;);
        String str = sdf.format(date);
        System.out.println(str);
    }
}

out:
2019-07-31 10:27:30.681
</code></pre>
<p><strong>范例：字符串转日期</strong></p>
<pre><code class="language-java">import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

class Main {
    public static void main(String [] args) throws ParseException {
        String str = &quot;2019-07-31 10:27:30.681&quot;;
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;);
        Date date = sdf.parse(str);
        System.out.println(date);
    }
}

out:
Wed Jul 31 10:27:30 CST 2019
</code></pre>
<p><strong>注意：</strong></p>
<p>如果输入了不存在的字符串，那么我们认为是错误的，</p>
<p>但是程序会自动给我们进位。并不会抛异常。</p>
<p>如果给定的字符串和转换格式不符合，就会抛出异常。</p>
<h2 id="总结"><a class="header" href="#总结">总结：</a></h2>
<p>在数据库的操作中，有几个常用类型：VARCHAR2(String)、CLOB（String）、NUMBER（int、double）、Date（java.util.Date）</p>
<ul>
<li>date 与 string 类转换依靠的是 SimpleDateFormat</li>
<li>string 与基本类型转换依靠的是包装类和 String.valueOf()方法</li>
<li>long 与 Date 转换依靠的是 Date 类提供的构造以及 getTIme()方法</li>
</ul>
<h2 id="calendar-类"><a class="header" href="#calendar-类">Calendar 类</a></h2>
<p>Date 类和 Simpledate 类是一起使用的，</p>
<p>Calendar 类主要是进行一些日期计算的。</p>
<pre><code class="language-java">public abstract class Calendar implements Serializable, Cloneable, Comparable&lt;Calendar&gt;
</code></pre>
<p>这是一个抽象类，依靠子类进行对象的实例化操作。但是这个类提供一个静态方法，getInstance()返回本类对象。</p>
<p><strong>范例：取得当前日期时间</strong></p>
<pre><code class="language-java">import java.util.Calendar;

class Main {
    public static void main(String [] args){
        Calendar cal = Calendar.getInstance();
        StringBuffer buf = new StringBuffer();
        buf.append(cal.get(Calendar.YEAR)).append(&quot;-&quot;);
        buf.append(cal.get(Calendar.MONTH) + 1).append(&quot;-&quot;);  //月是从0开始
        buf.append(cal.get(Calendar.DAY_OF_MONTH)).append(&quot; &quot;);
        buf.append(cal.get(Calendar.HOUR_OF_DAY)).append(&quot;:&quot;);
        buf.append(cal.get(Calendar.MINUTE)).append(&quot;:&quot;);
        buf.append(cal.get(Calendar.SECOND));
        System.out.println(buf);
    }
}

out:
2019-7-31 10:48:18
</code></pre>
<p>如果是日期计算，这个是相当简单的，直接进行操作就行了。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="10-比较器"><a class="header" href="#10-比较器">10-比较器</a></h1>
<ol>
<li>重新认识 Arrays 类</li>
<li>两种比较器的使用</li>
<li>数据结构——二叉树（Binary Tree）</li>
</ol>
<h2 id="arrays-类"><a class="header" href="#arrays-类">Arrays 类</a></h2>
<p>java.util.Arrays.sort()可以实现数组的排序。</p>
<ol>
<li>这个类里存在二分查找法</li>
</ol>
<pre><code class="language-java">public static int binarySearch(long[] a, long key) {}
</code></pre>
<ol start="2">
<li>还提供了数组比较，但是要想判断数组是否相同，需要顺序完全一致：</li>
</ol>
<pre><code class="language-java">import java.util.Arrays;

class Main {
    public static void main(String [] args){
        int dataA[] = new int[] {1,2,3};
        int dataB[] = new int[] {2,1,3};
        System.out.println(Arrays.equals(dataA, dataB));
        Arrays.sort(dataB);
        System.out.println(Arrays.equals(dataA, dataB));
    }
}

out:
false
true
</code></pre>
<ol start="3">
<li>
<p>填充数组：</p>
<pre><code class="language-java">public static void fill(T[] a, T val) {}
</code></pre>
</li>
<li>
<p>将数组变为字符串输出：</p>
<pre><code class="language-java">public static String toString(T[] a) {}
</code></pre>
</li>
</ol>
<p>范例：</p>
<pre><code class="language-java">import java.util.Arrays;

class Main {
    public static void main(String [] args){
        int data[] = new int[10];
        Arrays.fill(data, 3);
        System.out.println(Arrays.toString(data));
    }
}

out:
[3, 3, 3, 3, 3, 3, 3, 3, 3, 3]
</code></pre>
<p>基操，比较少出现。</p>
<h2 id="比较器comparable核心"><a class="header" href="#比较器comparable核心">比较器：Comparable（核心）</a></h2>
<p>Arrays 类里面可以直接利用 sort（）方法实现对象数组的排序。</p>
<pre><code class="language-java">import java.util.Arrays;

class Book{
    private String name;
    private double price;

    public Book(String name , double price){
        this.name=name;
        this.price=price;
    }

    @Override
    public String toString() {
        return &quot;书名：&quot; + this.name + &quot;，价格：&quot; + this.price;
    }
}

class Main {
    public static void main(String [] args){
        Book [] books = new Book[]{
                new Book(&quot;1&quot;, 1),
                new Book(&quot;2&quot;, 2),
                new Book(&quot;3&quot;, 3),
                new Book(&quot;4&quot;, 4)
            };
        Arrays.sort(books);
        System.out.println(Arrays.toString(books));
    }
}


out:
Exception in thread &quot;main&quot; java.lang.ClassCastException: Book cannot be cast to java.lang.Comparable
	at java.util.ComparableTimSort.countRunAndMakeAscending(ComparableTimSort.java:320)
	at java.util.ComparableTimSort.sort(ComparableTimSort.java:188)
	at java.util.Arrays.sort(Arrays.java:1246)
	at Main.main(Main.java:26)
</code></pre>
<p>此类异常的原因只有一个：两个没有关系的对象发生了强制性的转换。</p>
<p>每一个对象实际上值保留有地址信息，地址里面有内容。如果普通 int 型数组比较大小就够了。如果是对象数组，里面包含的如果只是编码（地址），比较是没有意义的。</p>
<p>因此要实现 Comparable 接口：</p>
<pre><code class="language-java">public interface Comparable&lt;T&gt; {
    public int compareTo(T o);
}
</code></pre>
<p>String 类就是 Comparable 的子类。</p>
<p>建议覆写 compareTo（）返回三种数据：</p>
<ul>
<li>大于：1</li>
<li>等于：0</li>
<li>小于：-1</li>
</ul>
<p><strong>实现比较</strong></p>
<pre><code class="language-java">import java.util.Arrays;

class Book implements Comparable&lt;Book&gt; {
    private String name;
    private double price;

    public Book(String name, double price) {
        this.name = name;
        this.price = price;
    }

    @Override
    public String toString() {
        return &quot;书名：&quot; + this.name + &quot;，价格：&quot; + this.price;
    }

    @Override
    public int compareTo(Book o) {
        // Arrays.sort()会自动调用此方法进行比较
        if (this.price &gt; o.price) {
            return 1;
        } else if (this.price &lt; o.price) {
            return -1;
        } else return 0;
    }
}

class Main {
    public static void main(String[] args) {
        Book[] books = new Book[]{
                new Book(&quot;1&quot;, 1),
                new Book(&quot;2&quot;, 2),
                new Book(&quot;3&quot;, 3),
                new Book(&quot;4&quot;, 4)
        };
        Arrays.sort(books);
        System.out.println(Arrays.toString(books));
    }
}
</code></pre>
<p>Arrays.sort()会自动调用 compareTo（）方法进行比较。</p>
<h2 id="数据结构binarytree"><a class="header" href="#数据结构binarytree">数据结构——BinaryTree</a></h2>
<p>树是比链表更复杂的动态数组。</p>
<p>二叉排序树，每个节点的左子树的值总比节点小，右子树的值总比节点大</p>
<p>中序遍历会得到有序序列。</p>
<p><strong>实现二叉树：</strong></p>
<ul>
<li>step1：实现数据类：</li>
</ul>
<pre><code class="language-java">class Book implements Comparable&lt;Book&gt; {
    private String name;
    private double price;

    public Book(String name, double price) {
        this.name = name;
        this.price = price;
    }

    @Override
    public String toString() {
        return &quot;书名：&quot; + this.name + &quot;，价格：&quot; + this.price;
    }

    @Override
    public int compareTo(Book o) {
        // Arrays.sort()会自动调用此方法进行比较
        if (this.price &gt; o.price) {
            return 1;
        } else if (this.price &lt; o.price) {
            return -1;
        } else return 0;
    }
}
</code></pre>
<ul>
<li>定义二叉树，所有数据结构都要有 Node 类的支持</li>
</ul>
<pre><code class="language-java">class BinaryTree{
    private class Node{
        private Comparable data;
        private Node left;
        private Node right;
        public Node(Comparable data){
            this.data = data;
        }
        public void addNode(Node newNode){
            if (this.data.compareTo(newNode.data) &gt; 0){ // 升降序调节
                if (this.left == null){
                    this.left = newNode;
                }else {
                    this.left.addNode(newNode);
                }
            }else {
                if (this.right == null){
                    this.right = newNode;
                }else {
                    this.right.addNode(newNode);
                }
            }
        }

        public void toArrayNode() {
            if (this.left!=null){
                this.left.toArrayNode();
            }
            BinaryTree.this.retData[BinaryTree.this.foot++] = this.data;
            if (this.right!=null){
                this.right.toArrayNode();
            }
        }
    }
    private Node root; //定义根节点
    private int count;
    private Object[] retData;
    private int foot;
    public void add (Object obj){
        Comparable com = (Comparable) obj;
        Node newNode = new Node(com);
        if (this.root == null){
            this.root = newNode;
        }else{
            this.root.addNode(newNode);
        }
        this.count++;
    }

    public Object[] toArray(){
        if (this.root == null){
            return null;
        }
        this.foot=0;
        this.retData = new Object[this.count];
        this.root.toArrayNode();
        return this.retData;
    }
}
</code></pre>
<p>二叉树中所有操作符合中序遍历！</p>
<ul>
<li>最后实现主函数：</li>
</ul>
<pre><code class="language-java">class Main {
    public static void main(String[] args) {
        BinaryTree bt = new BinaryTree();
        bt.add(new Book(&quot;test1&quot;, 10));
        bt.add(new Book(&quot;test2&quot;, 30));
        bt.add(new Book(&quot;test3&quot;, 50));
        bt.add(new Book(&quot;test4&quot;, 5));
        System.out.println(Arrays.toString(bt.toArray()));
    }
}

out:
[书名：test4，价格：5.0, 书名：test1，价格：10.0, 书名：test2，价格：30.0, 书名：test3，价格：50.0]
</code></pre>
<h2 id="挽救的比较器comparator"><a class="header" href="#挽救的比较器comparator">挽救的比较器：Comparator</a></h2>
<p>Comparable 接口需要在类定义的时候就实现了，如果要在后期实现比较就要使用 Comparator（不修改原有的类）</p>
<p>java.util.Comparator</p>
<pre><code class="language-java">@FunctionalInterface
public interface Comparator&lt;T&gt; {
    int compare(T o1, T o2);
    boolean equals(Object obj);
}
</code></pre>
<p>因此只需要覆写 compare 方法。（equals 方法是 Object 类所拥有的）</p>
<p>需要重新编写一个工具类来实现比较！</p>
<p><strong>实现比较工具</strong></p>
<pre><code class="language-java">class BookComparator implements Comparator&lt;Book&gt;{
    @Override
    public int compare(Book o1, Book o2) {
        if (o1.getPrice() &gt; o2.getPrice()){
            return 1;
        }else if (o1.getPrice() &lt; o2.getPrice()){
            return -1;
        }else return 0;
    }
}
</code></pre>
<p>之前使用 Comparable 接口的时候直接使用的 Arrays.sort（）方法进行排序的，现在更换了 Comparator 之后，可以使用另一个重载的 sort 方法。</p>
<pre><code class="language-java">public static &lt;T&gt; void sort(T[] a, Comparator&lt;? super T&gt; c) {}
</code></pre>
<p><strong>重新实现排序</strong></p>
<pre><code class="language-java">class Main {
    public static void main(String[] args) {
        Book books[] = new Book[]{
                new Book(&quot;test1&quot;, 10),
                new Book(&quot;test2&quot;, 30),
                new Book(&quot;test3&quot;, 50),
                new Book(&quot;test4&quot;, 5)
        };
        Arrays.sort(books,new BookComparator());
        System.out.println(Arrays.toString(books));
    }
}

out：
[书名：test4，价格：5.0, 书名：test1，价格：10.0, 书名：test2，价格：30.0, 书名：test3，价格：50.0]
</code></pre>
<p>使用 Comparator 比较麻烦。尽量使用 Comparable。</p>
<p><strong>面试题：解释 Comparable 和 Comparator 的区别</strong></p>
<ul>
<li>如果对象数组要进行排序，那么必须设置排序规则，可以使用上述两个接口。</li>
<li>java.lang.Comparable 是在一个类定义的时候要实现 compareTo（）。</li>
<li>java.util.Comparator 是在一个类定义之后，专门实现 compare（）方法的工具类。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="11-正则表达式"><a class="header" href="#11-正则表达式">11-正则表达式</a></h1>
<p>所有的开发一定要有正则的支持。</p>
<ol>
<li>
<p>匹配中文字符</p>
<pre><code class="language-js">/[\u4e00-\u9fa5]/gm;
</code></pre>
</li>
<li>
<p>匹配双字节字符</p>
<pre><code class="language-js">/[^\x00-\xff]/gim;
</code></pre>
</li>
<li>
<p>匹配中行尾首行空白</p>
<pre><code class="language-js">/(^\s*)|(\s*$)/;
</code></pre>
</li>
<li>
<p>匹配数字</p>
<pre><code class="language-js">/^\d+$/;
</code></pre>
</li>
<li>
<p>匹配 n 个数字</p>
<pre><code class="language-js">/^\d{n}$/;
</code></pre>
</li>
<li>
<p>匹配至少 n 个数字</p>
<pre><code class="language-js">/^\d{n,}$/;
</code></pre>
</li>
<li>
<p>匹配 m 到 n 个数字</p>
<pre><code class="language-js">/^\d{m,n}$/;
</code></pre>
</li>
<li>
<p>匹配英文字母</p>
<pre><code class="language-js">/^[a-z]+$/i;
</code></pre>
</li>
<li>
<p>匹配英文和数字</p>
<pre><code class="language-js">/^[a-z0-9]+$/i;
</code></pre>
</li>
<li>
<p>匹配英文数字和下划线</p>
<pre><code class="language-js">/^\w+$/;
</code></pre>
</li>
<li>
<p>匹配邮箱</p>
<pre><code class="language-js">/\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*/;
</code></pre>
</li>
<li>
<p>匹配 URL 地址</p>
<pre><code class="language-js">/^https?:\/\/(([a-zA-Z0-9_-])+(\.)?)*(:\d+)?(\/((\.)?(\?)?=?&amp;?[a-zA-Z0-9_-](\?)?)*)*$/i;
</code></pre>
</li>
<li>
<p>匹配手机号码</p>
<pre><code class="language-js">/^(0|86|17951)?(13[0-9]|15[012356789]|166|17[3678]|18[0-9]|14[57])[0-9]{8}$/;
</code></pre>
</li>
<li>
<p>匹配身份证号</p>
<pre><code class="language-js">/^(^[1-9]\d{7}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{3}$)|(^[1-9]\d{5}[1-9]\d{3}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])((\d{4})|\d{3}[Xx])$)$/;
</code></pre>
</li>
<li>
<p>匹配邮编</p>
<pre><code class="language-js">/^[1-9]\d{5}(?!\d)$/;
</code></pre>
</li>
<li>
<p>匹配日期 yyyy-MM-dd</p>
<pre><code class="language-js">/^[1-2][0-9][0-9][0-9]-[0-1]{0,1}[0-9]-[0-3]{0,1}[0-9]$/;
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="单点登录原理与简单实现"><a class="header" href="#单点登录原理与简单实现">单点登录原理与简单实现</a></h1>
<p>转自<a href="https://www.cnblogs.com/morethink/p/8047711.html">morethink</a></p>
<h1 id="单系统登录机制"><a class="header" href="#单系统登录机制">单系统登录机制</a></h1>
<p>web 应用采用 browser/server 架构，http 作为通信协议。http
是无状态协议，浏览器的每一次请求，服务器会独立处理，不与之前或之后的请求产生关联，这个过程用下图说明，三次请求/响应对之间没有任何联系。</p>
<p><img src="Java/./images/02c5bff6aa0c8a04bbda6261bb0fbd7f.png" alt="无状态的Http协议" /></p>
<p>无状态的 Http 协议</p>
<p>但这也同时意味着，任何用户都能通过浏览器访问服务器资源，如果想保护服务器的某些资源，必须限制浏览器请求；要限制浏览器请求，必须鉴别浏览器请求，响应合法请求，忽略非法请求；要鉴别浏览器请求，必须清楚浏览器请求状态。既然
http 协议无状态，那就让服务器和浏览器共同维护一个状态吧！这就是会话机制。</p>
<h2 id="会话机制"><a class="header" href="#会话机制">会话机制</a></h2>
<p>浏览器第一次请求服务器，服务器创建一个会话，并将会话的 id 作为响应的一部分发送给浏览器，浏览器存储会话 id，并在后续第二次和第三次请求中带上会话 id，服务器取得请求中的会话 id
就知道是不是同一个用户了，这个过程用下图说明，后续请求与第一次请求产生了关联。</p>
<p><img src="Java/./images/41970737be124812ef2b457d33aa38df.png" alt="会话机制" /></p>
<p>会话机制</p>
<p>服务器在内存中保存会话对象，浏览器怎么保存会话 id 呢？</p>
<p>你可能会想到两种方式</p>
<ul>
<li>请求参数</li>
<li>cookie</li>
</ul>
<p>将会话 id 作为每一个请求的参数，服务器接收请求自然能解析参数获得会话 id，并借此判断是否来自同一会话，很明显，这种方式不靠谱。那就浏览器自己来维护这个会话 id 吧，每次发送 http
请求时浏览器自动发送会话 id，cookie 机制正好用来做这件事。cookie 是浏览器用来存储少量数据的一种机制，数据以&quot;key/value&quot;形式存储，浏览器发送 http 请求时自动附带
cookie 信息。</p>
<p>tomcat 会话机制当然也实现了 cookie，访问 tomcat 服务器时，浏览器中可以看到一个名为<code>JSESSIONID</code>的 cookie，这就是 tomcat 会话机制维护的会话 id，使用了
cookie 的请求响应过程如下图：</p>
<p><img src="Java/./images/61273ed59b80ddef53862a0cba5f83a0.png" alt="JSESSIONID" /></p>
<p>​ JSESSIONID</p>
<h2 id="登录状态"><a class="header" href="#登录状态">登录状态</a></h2>
<p>有了会话机制，登录状态就好明白了，我们假设浏览器第一次请求服务器需要输入用户名与密码验证身份，服务器拿到用户名密码去数据库比对，正确的话说明当前持有这个会话的用户是合法用户，应该将这个会话标记为“已授权”或者“已登录”等等之类的状态，既然是会话的状态，自然要保存在会话对象中，tomcat
在会话对象中设置登录状态如下：</p>
<pre><code class="language-java">HttpSession session = request.getSession();
session.setAttribute(&quot;isLogin&quot;, true);
</code></pre>
<p>用户再次访问时，tomcat 在会话对象中查看登录状态：</p>
<pre><code class="language-java">HttpSession session = request.getSession();
session.getAttribute(&quot;isLogin&quot;);
</code></pre>
<p>实现了登录状态的浏览器请求服务器模型如下图描述：</p>
<p><img src="Java/./images/39ec3914d68cc400fab2d251d84370e6.png" alt="登录状态控制" /></p>
<p>​ 登录状态控制</p>
<p>每次请求受保护资源时都会检查会话对象中的登录状态，只有 <code>isLogin=true</code> 的会话才能访问，登录机制因此而实现。</p>
<h1 id="多系统的复杂性"><a class="header" href="#多系统的复杂性">多系统的复杂性</a></h1>
<p>web 系统早已从久远的单系统发展成为如今由多系统组成的应用群，面对如此众多的系统，用户难道要一个一个登录、然后一个一个注销吗？就像下图描述的这样</p>
<p><img src="Java/./images/1c722018d9dfd78b8623a1c5c50cd740.png" alt="多系统" /></p>
<p>​ 多系统</p>
<p>​</p>
<p><strong>web 系统由单系统发展成多系统组成的应用群，复杂性应该由系统内部承担，而不是用户。无论 web 系统内部多么复杂，对用户而言，都是一个统一的整体，也就是说，用户访问 web
系统的整个应用群与访问单个系统一样，登录/注销只要一次就够了</strong>。</p>
<p><img src="Java/./images/33e912634f234d469982fd25afac8e2a.png" alt="单系统的登录" /></p>
<p>​ 单系统的登录</p>
<p><strong>虽然单系统的登录解决方案很完美，但对于多系统应用群已经不再适用了，为什么呢？</strong></p>
<p>单系统登录解决方案的核心是 cookie，cookie 携带会话 id 在浏览器与服务器之间维护会话状态。但 cookie 是有限制的，这个限制就是 cookie
的域（通常对应网站的域名），浏览器发送 http 请求时会自动携带与该域匹配的 cookie，而不是所有 cookie。</p>
<p><img src="Java/./images/3d3db13c2cab0ba0863b8ecfe4c3f7b2.png" alt="夸域名" /></p>
<p>​ 跨域名</p>
<h2 id="子域名-cookie-共享完成单点登录"><a class="header" href="#子域名-cookie-共享完成单点登录">子域名 cookie 共享完成单点登录</a></h2>
<p>既然这样，为什么不将 web 应用群中所有子系统的域名统一在一个顶级域名下，例如“<code>*.baidu.com</code>”，然后将它们的 cookie
域设置为“baidu.com”，这种做法理论上是可以的，甚至早期很多多系统登录就采用这种同域名共享 cookie 的方式。</p>
<p>然而，可行并不代表好，共享 cookie 的方式存在众多局限。</p>
<ol>
<li>首先，应用群域名得统一。</li>
<li>其次，应用群各系统使用的技术（至少是 web 服务器）要相同，不然 cookie 的 key 值（tomcat 为 JSESSIONID）不同，无法维持会话，共享 cookie
的方式是无法实现跨语言技术平台登录的，比如 java、php、.net 系统之间。</li>
<li>第三，cookie 本身不安全。</li>
</ol>
<p>除上面之外，如果我们在<code>session</code>存放的是<code>User</code>对象，那么我们使用全局 cookie 共享<code>JSESSIONID</code>值，每一个子域名就可以访问同一个 session，登录成功后保存一个
user 对象，注销后就移除这个 user 对象。session 中的 user 对象必须先序列化保存到 redis 中，并且每次访问的时候，都需要去 redis 中取出
session，并且重新序列化成 user 对象。<strong>这样会造成额外的消耗</strong>。</p>
<p>因此，我们需要一种全新的登录方式来实现多系统应用群的登录，这就是单点登录。</p>
<h1 id="单点登录"><a class="header" href="#单点登录">单点登录</a></h1>
<p><strong>什么是单点登录</strong>？</p>
<p>单点登录全称 Single Sign On（以下简称 SSO），是指在多系统应用群中登录一个系统，便可在其他所有系统中得到授权而无需再次登录，包括单点登录与单点注销两部分。</p>
<h2 id="登录"><a class="header" href="#登录">登录</a></h2>
<p>相比于单系统登录，sso 需要一个独立的认证中心，只有认证中心能接受用户的用户名密码等安全信息，其他系统不提供登录入口，只接受认证中心的间接授权。间接授权通过令牌实现，sso
认证中心验证用户的用户名密码没问题，创建授权令牌，在接下来的跳转过程中，授权令牌作为参数发送给各个子系统，子系统拿到令牌，即得到了授权，可以借此创建局部会话，局部会话登录方式与单系统的登录方式相同。</p>
<p>这个过程，也就是单点登录的原理，用下图说明：</p>
<p><img src="Java/./images/797930-20161203152650974-276822362.png" alt="单点登录" /></p>
<p>​ 单点登录</p>
<p>下面对上图简要描述：</p>
<ol>
<li>用户访问系统 1 的受保护资源，系统 1 发现用户未登录，跳转至 sso 认证中心，并将自己的地址作为参数。</li>
<li>sso 认证中心发现用户未登录，将用户引导至登录页面。</li>
<li>用户输入用户名密码提交登录申请。</li>
<li>sso 认证中心校验用户信息，创建用户与 sso 认证中心之间的会话，称为全局会话，同时创建授权令牌。</li>
<li>sso 认证中心带着令牌跳转会最初的请求地址（系统 1）。</li>
<li>系统 1 拿到令牌，去 sso 认证中心校验令牌是否有效。</li>
<li>sso 认证中心校验令牌，返回有效，注册系统 1。</li>
<li>系统 1 使用该令牌创建与用户的会话，称为局部会话，返回受保护资源。</li>
<li>用户访问系统 2 的受保护资源。</li>
<li>系统 2 发现用户未登录，跳转至 sso 认证中心，并将自己的地址作为参数。</li>
<li>sso 认证中心发现用户已登录，跳转回系统 2 的地址，并附上令牌。</li>
<li>系统 2 拿到令牌，去 sso 认证中心校验令牌是否有效。</li>
<li>sso 认证中心校验令牌，返回有效，注册系统 2。</li>
<li>系统 2 使用该令牌创建与用户的局部会话，返回受保护资源。</li>
</ol>
<p>用户登录成功之后，会与 sso 认证中心及各个子系统建立会话，用户与 sso
认证中心建立的会话称为全局会话，用户与各个子系统建立的会话称为局部会话，局部会话建立之后，用户访问子系统受保护资源将不再通过 sso 认证中心，全局会话与局部会话有如下约束关系：</p>
<ul>
<li>局部会话存在，全局会话一定存在。</li>
<li>全局会话存在，局部会话不一定存在。</li>
<li>全局会话销毁，局部会话必须销毁。</li>
</ul>
<p>你可以通过博客园、百度、csdn、淘宝等网站的登录过程加深对单点登录的理解，注意观察登录过程中的跳转 url 与参数</p>
<h2 id="注销"><a class="header" href="#注销">注销</a></h2>
<p>单点登录自然也要单点注销，在一个子系统中注销，所有子系统的会话都将被销毁，用下面的图来说明：</p>
<p><img src="Java/./images/797930-20161129155242271-222889796.png" alt="单点注销" /></p>
<p>​ 单点注销</p>
<p>sso 认证中心一直监听全局会话的状态，一旦全局会话销毁，监听器将通知所有注册系统执行注销操作</p>
<p>下面对上图简要说明：</p>
<ol>
<li>用户向系统 1 发起注销请求。</li>
<li>系统 1 根据用户与系统 1 建立的会话 id 拿到令牌，向 sso 认证中心发起注销请求。</li>
<li>sso 认证中心校验令牌有效，销毁全局会话，同时取出所有用此令牌注册的系统地址。</li>
<li>sso 认证中心向所有注册系统发起注销请求。</li>
<li>各注册系统接收 sso 认证中心的注销请求，销毁局部会话。</li>
<li>sso 认证中心引导用户至登录页面。</li>
</ol>
<h2 id="部署图"><a class="header" href="#部署图">部署图</a></h2>
<p>单点登录涉及 sso 认证中心与众子系统，子系统与 sso 认证中心需要通信以交换令牌、校验令牌及发起注销请求，因而子系统必须集成 sso 的客户端，sso 认证中心则是 sso
服务端，整个单点登录过程实质是 sso 客户端与服务端通信的过程，用下图描述：</p>
<p><img src="Java/./images/797930-20161129155244646-2067469767.png" alt="部署图" /></p>
<p>​ 部署图</p>
<p>sso 认证中心与 sso 客户端通信方式有多种，这里以简单好用的 httpClient 为例，web service、rpc、restful api 都可以。</p>
<h1 id="实现"><a class="header" href="#实现">实现</a></h1>
<p>只是简要介绍下基于 java 的实现过程，不提供完整源码，明白了原理，我相信你们可以自己实现。sso 采用客户端/服务端架构，我们先看 sso-client 与 sso-server
要实现的功能（下面：sso 认证中心=sso-server）。</p>
<h3 id="sso-client"><a class="header" href="#sso-client">sso-client</a></h3>
<ol>
<li>拦截子系统未登录用户请求，跳转至 sso 认证中心。</li>
<li>接收并存储 sso 认证中心发送的令牌。</li>
<li>与 sso-server 通信，校验令牌的有效性。</li>
<li>建立局部会话。</li>
<li>拦截用户注销请求，向 sso 认证中心发送注销请求。</li>
<li>接收 sso 认证中心发出的注销请求，销毁局部会话。</li>
</ol>
<h3 id="sso-server"><a class="header" href="#sso-server">sso-server</a></h3>
<ol>
<li>验证用户的登录信息。</li>
<li>创建全局会话。</li>
<li>创建授权令牌。</li>
<li>与 sso-client 通信发送令牌。</li>
<li>校验 sso-client 令牌有效性。</li>
<li>系统注册。</li>
<li>接收 sso-client 注销请求，注销所有会话。</li>
</ol>
<p>接下来，我们按照原理来一步步实现 sso 吧！</p>
<h2 id="sso-client-拦截未登录请求"><a class="header" href="#sso-client-拦截未登录请求">sso-client 拦截未登录请求</a></h2>
<p>java 拦截请求的方式有 servlet、filter、listener 三种方式，我们采用 filter。在 sso-client 中新建 LoginFilter.java 类并实现 Filter
接口，在 doFilter()方法中加入对未登录用户的拦截：</p>
<pre><code class="language-java">public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    HttpServletRequest req = (HttpServletRequest) request;
    HttpServletResponse res = (HttpServletResponse) response;
    HttpSession session = req.getSession();

    if (session.getAttribute(&quot;isLogin&quot;)) {
        chain.doFilter(request, response);
        return;
    }
    //跳转至sso认证中心
    res.sendRedirect(&quot;sso-server-url-with-system-url&quot;);
}
</code></pre>
<h2 id="sso-server-拦截未登录请求"><a class="header" href="#sso-server-拦截未登录请求">sso-server 拦截未登录请求</a></h2>
<p>拦截从 sso-client 跳转至 sso 认证中心的未登录请求，跳转至登录页面，这个过程与 sso-client 完全一样。</p>
<h2 id="sso-server-验证用户登录信息"><a class="header" href="#sso-server-验证用户登录信息">sso-server 验证用户登录信息</a></h2>
<p>用户在登录页面输入用户名密码，请求登录，sso 认证中心校验用户信息，校验成功，将会话状态标记为“已登录”。</p>
<pre><code class="language-java">@RequestMapping(&quot;/login&quot;)
public String login(String username, String password, HttpServletRequest req) {
    this.checkLoginInfo(username, password);
    req.getSession().setAttribute(&quot;isLogin&quot;, true);
    return &quot;success&quot;;
}
</code></pre>
<h2 id="sso-server-创建授权令牌"><a class="header" href="#sso-server-创建授权令牌">sso-server 创建授权令牌</a></h2>
<p>授权令牌是一串随机字符，以什么样的方式生成都没有关系，只要不重复、不易伪造即可，下面是一个例子：</p>
<pre><code class="language-java">String token = UUID.randomUUID().toString();
</code></pre>
<h2 id="sso-client-取得令牌并校验"><a class="header" href="#sso-client-取得令牌并校验">sso-client 取得令牌并校验</a></h2>
<p>sso 认证中心登录后，跳转回子系统并附上令牌，子系统（sso-client）取得令牌，然后去 sso 认证中心校验，在 LoginFilter.java 的 doFilter()中添加几行：</p>
<pre><code class="language-java">// 请求附带token参数
String token = req.getParameter(&quot;token&quot;);
if (token != null) {
    // 去sso认证中心校验token
    boolean verifyResult = this.verify(&quot;sso-server-verify-url&quot;, token);
    if (!verifyResult) {
        res.sendRedirect(&quot;sso-server-url&quot;);
        return;
    }
    chain.doFilter(request, response);
}
</code></pre>
<p>verify()方法使用 httpClient 实现，这里仅简略介绍，httpClient 详细使用方法请参考官方文档。</p>
<pre><code class="language-java">HttpPost httpPost = new HttpPost(&quot;sso-server-verify-url-with-token&quot;);
HttpResponse httpResponse = httpClient.execute(httpPost);
</code></pre>
<h2 id="sso-server-接收并处理校验令牌请求"><a class="header" href="#sso-server-接收并处理校验令牌请求">sso-server 接收并处理校验令牌请求</a></h2>
<ul>
<li>用户在 sso 认证中心登录成功后，sso-server 创建授权令牌并存储该令牌，所以，sso-server 对令牌的校验就是去查找这个令牌是否存在以及是否过期，令牌校验成功后
sso-server 将发送校验请求的系统注册到 sso 认证中心（就是存储起来的意思）</li>
<li>令牌与注册系统地址通常存储在 key-value 数据库（如 redis）中，redis 可以为 key 设置有效时间也就是令牌的有效期。redis 运行在内存中，速度非常快，正好
sso-server 不需要持久化任何数据。</li>
<li>令牌与注册系统地址可以用下图描述的结构存储在 redis 中，可能你会问，为什么要存储这些系统的地址？如果不存储，注销的时候就麻烦了，用户向 sso 认证中心提交注销请求，sso
认证中心注销全局会话，但不知道哪些系统用此全局会话建立了自己的局部会话，也不知道要向哪些子系统发送注销请求注销局部会话。</li>
</ul>
<p><img src="Java/./images/797930-20161129155245506-1069288802.png" alt="img" /></p>
<h2 id="sso-client-校验令牌成功创建局部会话"><a class="header" href="#sso-client-校验令牌成功创建局部会话">sso-client 校验令牌成功创建局部会话</a></h2>
<p>令牌校验成功后，sso-client 将当前局部会话标记为“已登录”，修改 LoginFilter.java，添加几行：</p>
<pre><code class="language-java">if (verifyResult) {
    session.setAttribute(&quot;isLogin&quot;, true);
}
</code></pre>
<p>sso-client 还需将当前会话 id 与令牌绑定，表示这个会话的登录状态与令牌相关，此关系可以用 java 的 hashmap 保存，保存的数据用来处理 sso 认证中心发来的注销请求</p>
<h2 id="注销过程"><a class="header" href="#注销过程">注销过程</a></h2>
<p>用户向子系统发送带有“logout”参数的请求（注销请求），sso-client 拦截器拦截该请求，向 sso 认证中心发起注销请求：</p>
<pre><code class="language-java">String logout = req.getParameter(&quot;logout&quot;);
if (logout != null) {
    this.ssoServer.logout(token);
}
</code></pre>
<p>sso 认证中心也用同样的方式识别出 sso-client 的请求是注销请求（带有“logout”参数），sso 认证中心注销全局会话：</p>
<pre><code class="language-java">@RequestMapping(&quot;/logout&quot;)
public String logout(HttpServletRequest req) {
    HttpSession session = req.getSession();
    if (session != null) {
        session.invalidate();//触发LogoutListener
    }
    return &quot;redirect:/&quot;;
}
</code></pre>
<p>sso 认证中心有一个全局会话的监听器，一旦全局会话注销，将通知所有注册系统注销</p>
<pre><code class="language-java">public class LogoutListener implements HttpSessionListener {
    @Override
    public void sessionCreated(HttpSessionEvent event) {}
    @Override
    public void sessionDestroyed(HttpSessionEvent event) {
        //通过httpClient向所有注册系统发送注销请求
    }
}
</code></pre>
<h1 id="代码部署"><a class="header" href="#代码部署">代码部署</a></h1>
<p>GitHub 地址： https://github.com/morethink/simple-sso.git</p>
<h2 id="idea-部署"><a class="header" href="#idea-部署">IDEA 部署</a></h2>
<p><img src="Java/./images/3a48b1deaaecd4dc74377a5eacec4a08.png" alt="img" />
<img src="Java/./images/d341e21bdb77889efae518d35d754b34.png" alt="img" />
<img src="Java/./images/1439e11d0b2659b62780e887bd22b20f.png" alt="img" /></p>
<h2 id="单点登录-1"><a class="header" href="#单点登录-1">单点登录</a></h2>
<p><strong>访问 a 系统</strong>：</p>
<p>http://localhost/a/test</p>
<p><img src="Java/./images/a743f4b854fb7f82bf4855112de304de.png" alt="img" /></p>
<p><strong>访问 b 系统</strong>：</p>
<p>http://localhost/b/test</p>
<p><img src="Java/./images/e619435d561a998088a6d11a4ecc22cc.png" alt="img" /></p>
<p><strong>a 系统登录成功</strong>：</p>
<p><img src="Java/./images/07a3bf0aefd180dfaa5779ba740998b4.png" alt="img" /></p>
<p><strong>b 系统同时也登录成功</strong>:</p>
<p><img src="Java/./images/e504ce5c9dc7e9e70303b9f3f54d20c2.png" alt="img" /></p>
<div style="break-before: page; page-break-before: always;"></div><p>Flask 是一个轻量级的 web 库。</p>
<p>Flask 简单应用：</p>
<div style="break-before: page; page-break-before: always;"></div><p>实现 HTTPServer</p>
<p>简单开始</p>
<pre><code class="language-python">import selectors
import socket

tcp_socket = socket.socket()

tcp_socket.bind((&quot;127.0.0.1&quot;,8888))

tcp_socket.listen(5)

def my_accept(sock,mask):
    new_sock,add = sock.accept()
    data = new_sock.recv(1024)
    print(data)

selector = selectors.DefaultSelector()

selector.register(tcp_socket,selectors.EVENT_READ,my_accept)

while True:
    print(&quot;服务器开始运行&quot;)
    events = selector.select()
    for key,mask in events:
        callback = key.data
        callback(key.fileobj,mask)
</code></pre>
<p>使用<code>selectors</code>实现并发和管理<code>socket</code></p>
<pre><code class="language-python">import selectors
import socket


class StaticHttpServer(object):

    def __init__(self, host, port):
        self.selector = selectors.DefaultSelector()
        self.tcp_server_socket = socket.socket()
        self.tcp_server_socket.bind((host, port))
        self.tcp_server_socket.listen(5)
        self.tcp_server_socket.setblocking(False)

    def my_accept(self, sock, mask):
        conn, add = sock.accept()
        conn.setblocking(False)
        self.selector.register(conn, selectors.EVENT_READ, self.read)

    def read(self, conn, mask):
        data = conn.recv(1024)
        conn.setblocking(False)
        self.selector.unregister(conn)
        print(data)
        self.selector.register(conn, selectors.EVENT_WRITE, self.write)

    def write(self, conn, mask):
        retData = '''HTTP/1.1 200 OK\r\nServer:my_server\r\n\r\nHello World'''
        self.selector.unregister(conn)
        conn.send(retData.encode())
        conn.setblocking(False)

    def server_forever(self):
        self.selector.register(self.tcp_server_socket, selectors.EVENT_READ, self.my_accept)
        while True:
            events = self.selector.select()
            for key, mask in events:
                callback = key.data
                callback(key.fileobj, mask)


if __name__ == '__main__':
    host = '127.0.0.1'
    port = 8888
    tcp_server = StaticHttpServer(host, port)
    tcp_server.server_forever()
</code></pre>
<p>加上报文解析：</p>
<pre><code class="language-python">import selectors
import socket
from http_parsed import BaseRequest


class StaticHttpServer(object):

    def __init__(self, host, port):
        self.selector = selectors.DefaultSelector()
        self.tcp_server_socket = socket.socket()
        self.tcp_server_socket.bind((host, port))
        self.tcp_server_socket.listen(5)
        self.tcp_server_socket.setblocking(False)

    def my_accept(self, sock, mask):
        conn, add = sock.accept()
        conn.setblocking(False)
        self.selector.register(conn, selectors.EVENT_READ, self.read)

    def read(self, conn: socket.socket, mask):
        data = conn.recv(1024)
        if data:
            conn.setblocking(False)
            self.selector.unregister(conn)
            self.req = BaseRequest(data)
            print(&quot;请求方法：&quot;, self.req.method)
            print(&quot;请求路径：&quot;, self.req.path)
            print(&quot;请求头：&quot;, self.req.headers)
            print(&quot;请求体：&quot;, self.req.body)
            self.selector.register(conn, selectors.EVENT_WRITE, self.write)
        else:
            print(&quot;客户端离线&quot;)
            conn.close()

    def write(self, conn, mask):
        retData = '''HTTP/1.1 200 OK\r\nServer:my_server\r\n\r\nHello World'''
        self.selector.unregister(conn)
        conn.send(retData.encode())
        conn.setblocking(False)

    def server_forever(self):
        self.selector.register(self.tcp_server_socket, selectors.EVENT_READ, self.my_accept)
        try:
            while True:
                events = self.selector.select()
                for key, mask in events:
                    callback = key.data
                    callback(key.fileobj, mask)
        except Exception as e:
            print(e)
        finally:
            self.tcp_server_socket.close()


if __name__ == '__main__':
    host = '127.0.0.1'
    port = 8888
    tcp_server = StaticHttpServer(host, port)
    tcp_server.server_forever()
</code></pre>
<p>http_parsed.py</p>
<pre><code class="language-python">class BaseRequest(object):

    def __init__(self, request):
        self.request = request.decode()
        self.parse_headers()
        self.parse_body()
        self.parse_method()
        self.parse_path()

    def parse_headers(self):
        sp = self.request.split('\r\n\r\n', 1)[0].split('\r\n')[1:]
        dic = {}
        for i in sp:
            k, v = i.split(': ', 1)
            dic[k] = v
        self.headers = dic

    def parse_body(self):
        self.body = &quot;Nothing to show&quot; or self.request.split(&quot;\r\n&quot;)[-1]

    def parse_path(self):
        self.path = self.request.split()[1]

    def parse_method(self):
        self.method = self.request.split()[0]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1栈"><a class="header" href="#1栈">1.栈</a></h1>
<p>先进后出</p>
<p><code>Stack</code>通常的操作：</p>
<ul>
<li><code>Stack()</code>建立一个空的栈对象</li>
<li><code>push()</code>压入栈</li>
<li><code>pop()</code>出栈</li>
<li><code>peek()</code>查看顶层元素</li>
<li><code>isEmpty()</code>判断是否为空</li>
<li><code>size()</code>返回元素个数</li>
</ul>
<h2 id="11-实现一个简单的栈"><a class="header" href="#11-实现一个简单的栈">1.1 实现一个简单的栈</a></h2>
<p>借助<code>list</code>实现简单的栈</p>
<pre><code class="language-python">class Stack:
    def __init__(self):
        self.stack = []

    def push(self, item):
        self.stack.append(item)

    def pop(self):
        ret = self.stack[-1]
        self.stack = self.stack[0:-1]
        return ret

    def peek(self):
        if not self.isEmpty():
            return self.stack[-1]
        else:raise Exception(&quot;栈为空&quot;)

    def isEmpty(self):
        return len(self.stack) == 0

    def size(self):
        return len(self.stack)

    def __str__(self):
        return self.stack.__str__()

if __name__ == '__main__':
    stack = Stack()
    print(stack.isEmpty())
    stack.push(&quot;hello&quot;)
    print(stack)
    print(stack.isEmpty())
    print(stack.peek())
    print(stack.pop())
    print(stack)

out;
True
['hello']
False
hello
hello
[]
</code></pre>
<h2 id="12-栈的应用后缀表达式"><a class="header" href="#12-栈的应用后缀表达式">1.2 栈的应用：后缀表达式</a></h2>
<ul>
<li>
<p>计算后缀表达式：</p>
<p>从左到右遍历后缀表达式，遇到数字压入栈，遇到符号出栈两个数字，然后将计算的结果压入栈。</p>
</li>
<li>
<p>将中缀表达式转换为后缀表达式：</p>
<p>规则： 从左到右遍历中缀表达式中的每个数字和符号，若是数字就输出，即成为后缀表达式的一部分；若是符号则要分为两种情况：
1）是括号时，如果是左括号，直接将左括号入栈，如果是右括号则栈顶元素依次出栈并输出，直到有一个左括号出栈（出栈的左括号不输出到后缀表达式）。
2）是运算符号时，如果栈顶符号为左括号，则直接将这个运算符号入栈。栈顶符号不为左括号时，如果该运算符号优先级比栈顶运算符号高则入栈，比栈顶符号低或者相等时则栈顶元素依次出栈并输出直到栈为空或者栈顶为左括号为止，==然后将这个符号入栈==。
最后将栈顶符号依次出栈并输出，得到的结果即为最终的后缀表达式。</p>
</li>
</ul>
<p>在编写算法的时候可以将上述两步合并为一步：</p>
<p>用一个栈 data 保存运算数字，一个栈 opt 保存运算符号。</p>
<p>从左到右遍历中缀表达式，如果是数字就入栈 data，如果是符号，以下四种情况直接将符号入栈 opt：</p>
<ol>
<li>
<p>栈为空；</p>
</li>
<li>
<p>栈顶为左括号；</p>
</li>
<li>
<p>该符号为左括号；</p>
</li>
<li>
<p>该运算符号优先级比栈顶符号高。</p>
</li>
</ol>
<p>如果是右括号，则执行一次计算 步骤：从 opt 出栈一个运算符号，从 data 出栈两个数字进行一次运算并将结果入栈 data。重复执行该计算步骤，直到 opt
栈顶为左括号，然后将该左括号出栈；如果该符号优先级低于 opt 栈顶符号或 者与栈顶符号优先级相同时，重复执行与之前相同的计算步骤，直到 opt 栈为空，若中途 opt 栈顶符
号为左括号则停止执行计算步骤。中缀表达式遍历完成后，继续执行之前的计算步骤直到 opt 栈为空。</p>
<pre><code class="language-python">def compare(opt1, opt2):
    &quot;&quot;&quot;
    比较优先级大小，opt1优先级高True，opt2优先级高False
    :param opt1:
    :param opt2:
    :return: opt1优先级高True，opt2优先级高False
    &quot;&quot;&quot;
    return opt1 in [&quot;*&quot;, &quot;/&quot;] and opt2 in [&quot;+&quot;, &quot;-&quot;]


def getValue(data:Stack,opt:Stack):
    &quot;&quot;&quot;
    计算方法，从data中取出两个数字，从opt中取出一个符号，进行计算后压入data栈
    :param data:数字栈
    :param opt:符号栈
    :return:
    &quot;&quot;&quot;
    op = opt.pop()
    num1 = data.pop()
    num2 = data.pop()
    if op == &quot;+&quot;:
        ret = num2 + num1
    elif op == &quot;-&quot;:
        ret = num2 - num1
    elif op == &quot;*&quot;:
        ret = num2 * num1
    elif op == &quot;/&quot;:
        ret = num2 / num1
    data.push(ret)

def solution(s:str, data:Stack, opt:Stack):
    i = 0
    while i &lt; len(exp):
        # 如果是数字，就进入data栈。
        if s[i].isdigit():
            start = i
            while True:
                if i+1 &lt; len(s) and s[i + 1].isdigit():
                    i += 1
                else:
                    data.push(int(s[start:i + 1]))
                    break
        # 如果是符号，就进入opt栈，需要进行情况讨论。
        else:
            # 栈顶符号位(或栈为空，直接入栈
            if opt.isEmpty() or opt.peek() == &quot;(&quot;:
                opt.push(s[i])
            # 符号是(或者优先级高于栈顶元素，直接入栈
            elif s[i] == &quot;(&quot; or compare(s[i],opt.peek()):
                opt.push(s[i])
            # 符号是)则开始进行运算
            elif s[i] == &quot;)&quot;:
                while True:
                    if opt.peek()==&quot;(&quot;:
                        opt.pop()
                        break
                    getValue(data,opt)
            # 符号栈不为空，且本次符号优先级不大于栈顶符号优先级，则进行计算，最后进栈本符号
            else:
                while not opt.isEmpty() and not compare(s[i],opt.peek()):
                    if opt.isEmpty() or opt.peek()==&quot;(&quot;:
                        break
                    getValue(data,opt)
                opt.push(s[i])
        i += 1
    while not opt.isEmpty():
        getValue(data,opt)
    return data.pop()



if __name__ == '__main__':
    exp = &quot;(9+((3-1)*3+10/2))*2&quot;
    data = Stack()
    opt = Stack()
    print(solution(exp, data, opt))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="01-日志的全局配置"><a class="header" href="#01-日志的全局配置">01-日志的全局配置</a></h1>
<p>日志在 Python 中专门有一个库可以使用——logging</p>
<pre><code class="language-python">import logging

# 控制台输出日志
print(&quot;我是日志&quot;)
</code></pre>
<p>日志有五个级别：</p>
<pre><code class="language-python">logging.debug(&quot;我是debug&quot;)
logging.info(&quot;我是info&quot;)
logging.warning(&quot;我是warning&quot;)
logging.error(&quot;我是error&quot;)
logging.critical(&quot;我是critical&quot;)

out:
WARNING:root:我是warning
ERROR:root:我是error
CRITICAL:root:我是critical
</code></pre>
<p>root 是默认日志的名称，root 是一个对象。logging 就是在调用 root。</p>
<p>输出的时候会前面带上日志的级别和对象。</p>
<p>root 是默认日志的名称，只会输出 warning 级别以上的日志。</p>
<h2 id="11-配置日志修改配置项"><a class="header" href="#11-配置日志修改配置项">1.1 配置日志（修改配置项）</a></h2>
<p>配置默认的 root 日志</p>
<table><thead><tr><th>配置项</th><th align="left">意义</th></tr></thead><tbody>
<tr><td>format</td><td align="left">格式化输出</td></tr>
<tr><td>level</td><td align="left">0、10、20、30、40、50<br />分别对应日志的五个级别。<br />直接使用常量 logging.DEBUG</td></tr>
<tr><td>Handler</td><td align="left">指定日志输出位置</td></tr>
<tr><td>datefmt</td><td align="left">修改日期输出格式</td></tr>
<tr><td>filename</td><td align="left">日志文件名称</td></tr>
</tbody></table>
<pre><code class="language-python">import logging

logging.basicConfig(format=&quot;%(name)s - %(asctime)s - %(filename)s - %(lineno)s -%(message)s&quot;)


logging.debug(&quot;我是debug&quot;)
logging.info(&quot;我是info&quot;)
logging.warning(&quot;我是warning&quot;)
logging.error(&quot;我是error&quot;)
logging.critical(&quot;我是critical&quot;)

out:
root - 2019-08-07 14:26:04,058 - 01-日志的全局配置.py - 7 -我是warning
root - 2019-08-07 14:26:04,059 - 01-日志的全局配置.py - 8 -我是error
root - 2019-08-07 14:26:04,059 - 01-日志的全局配置.py - 9 -我是critical
</code></pre>
<h2 id="12formatter-参数"><a class="header" href="#12formatter-参数">1.2Formatter 参数</a></h2>
<table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody>
<tr><td>%(message)s</td><td>用户自定义要输出的信息</td></tr>
<tr><td>%(asctime)s</td><td>当前的日期时间</td></tr>
<tr><td>%(name)s</td><td>logger 实例的名称</td></tr>
<tr><td>%(module)s</td><td>使用 logger 实例的模块名</td></tr>
<tr><td>%(filename)s</td><td>使用 logger 实例的模块的文件名</td></tr>
<tr><td>%(funcName)s</td><td>使用 logger 实例的函数名</td></tr>
<tr><td>%(lineno)d</td><td>使用 logger 实例的代码行号</td></tr>
<tr><td>%(levelname)s</td><td>日志级别名称</td></tr>
<tr><td>%(levelno)s</td><td>表示日志级别的数字形式</td></tr>
<tr><td>%(threadName)s</td><td>使用 logger 实例的线程名称（测试多线程时有用）</td></tr>
<tr><td>%(thread)d</td><td>使用 logger 实例的线程号（测试多线程时有用）</td></tr>
<tr><td>%(process)d</td><td>使用 logger 实例的进程号（测试多进程时有用）</td></tr>
</tbody></table>
<p>创建 Formatter：</p>
<pre><code class="language-python">formatter = logging.Formatter
	('%(asctime)s - %(filename)s[line:%(lineno)d] - &lt;%(threadName)s %(thread)d&gt;' + '- &lt;Process %(process)d&gt; - %(levelname)s: %(message)s')
</code></pre>
<h2 id="13handler-参数"><a class="header" href="#13handler-参数">1.3Handler 参数</a></h2>
<h3 id="131-常用的-handler"><a class="header" href="#131-常用的-handler">1.3.1 常用的 Handler</a></h3>
<table><thead><tr><th>参数</th><th>意义</th></tr></thead><tbody>
<tr><td>logging.StreamHandler</td><td>输出到控制台</td></tr>
<tr><td>logging.FileHandler</td><td>输出到指定的日志文件中</td></tr>
<tr><td>logging.handlers.RotatingFileHandler</td><td>也是输出到日志文件中，还可以指定日志文件的最大大小和副本数，当日志文件增长到设置的大小 后，会先将原日志文件 test.log 重命名，如 test.log.1，然后再创建一个 test.log 继续写入日志。如 果设置了副本数 N，则最多只能存在 N 个重命名的日志文件</td></tr>
<tr><td>logging.handlers.TimedRotatingFileHandler</td><td>按日期时间保存日志文件，如果设置了滚动周期，则只存在这个周期内的日志文件。比如，只保留 一周内的日志</td></tr>
<tr><td>logging.handlers.SMTPHandler</td><td>捕获到指定级别的日志后，给相应的邮箱发送邮件</td></tr>
</tbody></table>
<h3 id="132-创建-handler"><a class="header" href="#132-创建-handler">1.3.2 创建 Handler</a></h3>
<pre><code class="language-python"># 创建StreamHandler，输出日志到控制台
stream_handler = logging.StreamHandler()
</code></pre>
<h3 id="132handler-常用方法"><a class="header" href="#132handler-常用方法">1.3.2Handler 常用方法</a></h3>
<p>设置日志的格式，调用 formatter</p>
<pre><code class="language-python">stream_handler.setFormatter(formatter)
</code></pre>
<p>设置日志级别</p>
<pre><code class="language-python">stream_handler.setLevel(logging.INFO)
</code></pre>
<h2 id="14logger-实例"><a class="header" href="#14logger-实例">1.4Logger 实例</a></h2>
<p>如前面所述，直接使用 logging.basicConfig() 默认使用 root 这个 logger 实例。</p>
<p>basicConfig 默认输出是 warning 级别的。</p>
<p>我们也可以使用 logging.getLogger()创建一个自定义命令的 logger 实例：</p>
<pre><code class="language-python">import logging

# 1. 创建一个叫aiotest的logger实例，如果参数为空则返回root
logger = logging.getLogger('aiotest')

# 2. 设置总日志级别, 也可以给不同的handler设置不同的日志级别
logger.setLevel(logging.DEBUG)

# 3. 设置Formatter
formatter = logging.Formatter('%(asctime)s - %(filename)s[line:%(lineno)d] - &lt;%(threadName)s %(thread)d&gt;' + '- &lt;Process %(process)d&gt; - %(levelname)s: %(message)s')

# 4. 创建Handler
# 文件Handler
file_handler = logging.FileHandler(&quot;logger.log&quot;, encoding=&quot;utf8&quot;)
# 控制台输出Handler
stream_handler = logging.StreamHandler()

# 5. 给Handler设置属性
stream_handler.setFormatter(formatter)
file_handler.setFormatter(formatter)
stream_handler.setLevel(logging.DEBUG)
file_handler.setLevel(logging.WARNING)

# 6. 将Handler添加到logger实例上
logger.addHandler(stream_handler)
logger.addHandler(file_handler)


# 输出日志
logger.debug(&quot;我是debug&quot;)
logger.info(&quot;我是info&quot;)
logger.warning(&quot;我是warning&quot;)
logger.error(&quot;我是error&quot;)
logger.critical(&quot;我是critical&quot;)


out:
2019-08-07 15:22:55,429 - 01-日志的全局配置.py[line:30] - &lt;MainThread 15616&gt;- &lt;Process 15732&gt; - DEBUG: 我是debug
2019-08-07 15:22:55,429 - 01-日志的全局配置.py[line:31] - &lt;MainThread 15616&gt;- &lt;Process 15732&gt; - INFO: 我是info
2019-08-07 15:22:55,430 - 01-日志的全局配置.py[line:32] - &lt;MainThread 15616&gt;- &lt;Process 15732&gt; - WARNING: 我是warning
2019-08-07 15:22:55,430 - 01-日志的全局配置.py[line:33] - &lt;MainThread 15616&gt;- &lt;Process 15732&gt; - ERROR: 我是error
2019-08-07 15:22:55,430 - 01-日志的全局配置.py[line:34] - &lt;MainThread 15616&gt;- &lt;Process 15732&gt; - CRITICAL: 我是critical

日志文件:
2019-08-07 15:23:37,297 - 01-日志的全局配置.py[line:32] - &lt;MainThread 74852&gt;- &lt;Process 74856&gt; - WARNING: 我是warning
2019-08-07 15:23:37,297 - 01-日志的全局配置.py[line:33] - &lt;MainThread 74852&gt;- &lt;Process 74856&gt; - ERROR: 我是error
2019-08-07 15:23:37,298 - 01-日志的全局配置.py[line:34] - &lt;MainThread 74852&gt;- &lt;Process 74856&gt; - CRITICAL: 我是critical
</code></pre>
<p>给 logger 设置最低的全局级别，优先级最高，最低的就是 logger.setLevel(logging.DEBUG)的级别，不会低于这个级别。</p>
<p>在其他地方使用自定义 logger，将上面的代码保存为 demo 文件。</p>
<pre><code class="language-python">from demo import logger

try:
    print(1/0)
except:
    logger.error(&quot;错误001&quot;)
</code></pre>
<h3 id="141-配合-os-和-time-模块使用"><a class="header" href="#141-配合-os-和-time-模块使用">1.4.1 配合 os 和 time 模块使用：</a></h3>
<pre><code class="language-python">import os
import time
import logging
# 1. 创建logger实例，如果参数为空则返回 root logger
logger = logging.getLogger('aiotest')

# 设置总日志级别, 也可以给不同的handler设置不同的日志级别
logger.setLevel(logging.DEBUG)

# 2. 创建Handler, 输出日志到控制台和文件
# 控制台日志和日志文件使用同一个Formatter
formatter = logging.Formatter('%(asctime)s - %(filename)s[line:%(lineno)d] - &lt;%(threadName)s %(thread)d&gt;' + '- &lt;Process %(process)d&gt; - %(levelname)s: %(message)s' )

# 日志文件FileHandler
basedir = os.path.abspath(os.path.dirname(__file__))
log_dest = os.path.join(basedir, 'logs')    # 日志文件所在目录
if not os.path.isdir(log_dest):
    os.mkdir(log_dest)

filename = time.strftime('%Y-%m-%d-%H-%M-%S', time.localtime(time.time())) + '.log'

# 日志文件名，以当前时间命名
file_handler = logging.FileHandler(os.path.join(log_dest, filename), encoding='utf-8')

file_handler.setFormatter(formatter)
# 设置Formatter
file_handler.setLevel(logging.WARNING)
# 单独设置日志文件的日志级别

# 控制台日志StreamHandler
stream_handler = logging.StreamHandler()
stream_handler.setFormatter(formatter)
# stream_handler.setLevel(logging.INFO)
# 单独设置控制台日志的日志级别，注释掉则使用总日志 级别
# 3. 将handler添加到logger中
logger.addHandler(file_handler)
logger.addHandler(stream_handler)
</code></pre>
<h1 id="02-深拷贝和浅拷贝"><a class="header" href="#02-深拷贝和浅拷贝">02-深拷贝和浅拷贝</a></h1>
<p>Python 赋值操作或函数参数传递，传递的永远是对象引用（即内存地址），而不是对象内容。在 Python
中一切皆对象，对象又分为可变（mutable）和不可变（immutable）两种类型。对象拷贝是指在内存中创建新的对象，产生新的内存地址。当顶层对象和它的子元素对象全都是 immutable
不可变对象时，不存在被拷贝，因为没有产生新对象。浅拷贝（Shallow Copy），拷贝顶层对象，但不会拷贝内部的子元素对象。深拷贝（Deep Copy），递归拷贝顶层对象，以及它内部的子元素对象。</p>
<h2 id="可变对象与不可变对象"><a class="header" href="#可变对象与不可变对象">可变对象与不可变对象</a></h2>
<p>Python
中一切皆对象，对象就像一个塑料盒子，里面装的是数据。对象有不同类型，例如布尔型和整型，类型决定了可以对它进行的操作。现实生活中的&quot;陶器&quot;会暗含一些信息（例如它可能很重且易碎，注意不要掉到地上）。
对象的类型还决定了它装着的数据是允许被修改的变量（可变的 mutable）还是不可被修改的常量（不可变的
immutable）。你可以把不可变对象想象成一个透明但封闭的盒子：你可以看到里面装的数据，但是无法改变它。类似地，可变对象就像一个开着口的盒子，你不仅可以看到里面的数据，还可以拿出来修改它，但你无法改变这个盒子本身，即你无法改变对象的类型。</p>
<ul>
<li>mutable：可变对象，如 List、Dict 和 Set</li>
<li>immutable：不可变对象，如 Number、String、Tuple、Frozenset</li>
</ul>
<p><strong>注意：</strong></p>
<p>​<strong>Python 赋值操作或函数参数传递，传递的永远是对象引用（即内存地址），而不是对象内容。</strong></p>
<pre><code class="language-python">In [1]: a = 1
In [2]: b = a

In [3]: id(a)
Out[3]: 9164864
In [4]: id(b)
Out[4]: 9164864

In [5]: b += 1
In [6]: a
Out[6]: 1
In [7]: b
Out[7]: 2
In [8]: id(a)  # 对象引用a还是指向Number对象1
Out[8]: 9164864
In [9]: id(b)  # 对象引用b指向了Number对象2
Out[9]: 9164896
</code></pre>
<p><strong>Python 会缓存使用非常频繁的小整数-5 至 256 、 ISO/IEC 8859-1 单字符 、 只包含大小写英文字 母的字符串 ，以对其复用，不会创建新的对象：</strong></p>
<pre><code class="language-python">1. 不会创建新对象 In [1]: a = 10
In [2]: b = 10
In [3]: id(a)
Out[3]: 9165152
In [4]: id(b)
Out[4]: 9165152
In [5]: a = '@'
In [6]: b = '@'
In [7]: id(a)
Out[7]: 139812844740424
In [8]: id(b)
Out[8]: 139812844740424
In [9]: a = 'HELLOWORLDhelloworld'
In [10]: b = 'HELLOWORLDhelloworld'
In [11]: id(a)
Out[11]: 139812785036792
In [12]: id(b)
Out[12]: 139812785036792
2. 会创建新的对象
In [1]: a = 1000
In [2]: b = 1000
In [3]: id(a)
Out[3]: 140528314730384
In [4]: id(b)
Out[4]: 140528314731824
In [5]: a = 'x*y'
In [6]: b = 'x*y'
In [7]: id(a)
Out[7]: 139897777405880
In [8]: id(b)
Out[8]: 139897777403808
In [9]: a = 'Hello World'
In [10]: b = 'Hello World'
In [11]: id(a)
Out[11]: 139897789146096
In [12]: id(b)
Out[12]: 139897789179568
</code></pre>
<p>copy 是浅拷贝 （只拷贝内存地址）</p>
<p>deepcopy 是深拷贝 （内容重新分配）</p>
<h1 id="03-对象属性管理"><a class="header" href="#03-对象属性管理">03-对象属性管理</a></h1>
<h2 id="31__dict__方法"><a class="header" href="#31__dict__方法">3.1<code>__dict__</code>方法</a></h2>
<p><code>__dict__</code>方法可以获取类或者对象的所有属性和方法。</p>
<p>类.<code>__dict__</code>可以直接获取到类定义时所有的方法和属性</p>
<p>实例对象.<code>__dict__</code>可以直接获取到实例的所有的方法和属性，<strong>不能获取到类中的</strong>。</p>
<p>但是实例对象的方法指向了类对象的方法，所以实例对象能调用类方法。</p>
<p>（对象添加属性或方法不影响类）</p>
<p>对象.<code>__dict__</code>['key']可以直接获取到 value</p>
<p>不存在的 key 会报错 KeyError</p>
<pre><code class="language-python">class Person(object):
    name = 'python'
    age = 18

    def __init__(self):
        self.sex = &quot;boy&quot;
        self.like = &quot;papapa&quot;

    @staticmethod
    def stat_func():
        print('this is stat_func')

    @classmethod
    def class_func(cls):
        print('class_func')

person = Person()
print('Person.__dict__: ', Person.__dict__)
print('person.__dict__: ', person.__dict__)

out:
Person.__dict__:  {'__module__': '__main__', 'name': 'python', 'age': 18, '__init__': &lt;function Person.__init__ at 0x000002C518993950&gt;, 'stat_func': &lt;staticmethod object at 0x000002C518996978&gt;, 'class_func': &lt;classmethod object at 0x000002C5189969B0&gt;, '__dict__': &lt;attribute '__dict__' of 'Person' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'Person' objects&gt;, '__doc__': None}

person.__dict__:  {'sex': 'boy', 'like': 'papapa'}
</code></pre>
<p>由此可见， 类的普通方法、类方法、静态方法、全局变量以及一些内置的属性都是放在类对 象 dict 里 而实例对象中存储了一些 self.xxx 的一些东西</p>
<h2 id="32-继承"><a class="header" href="#32-继承">3.2 继承</a></h2>
<p>在类的继承中，子类有自己的 dict, 父类也有自己的 dict,子类的全局变量和方法放在子类的 dict 中， 父类的放在父类 dict 中。</p>
<h2 id="33-动态语言限制属性的修改"><a class="header" href="#33-动态语言限制属性的修改">3.3 动态语言限制属性的修改</a></h2>
<p>现在我们终于明白了，动态语言与静态语言的不同</p>
<ul>
<li>
<p>动态语言：可以在运行的过程中，修改代码</p>
</li>
<li>
<p>静态语言：编译时已经确定好代码，运行过程中不能修改</p>
</li>
</ul>
<p>如果我们想要限制实例的属性怎么办？比如，只允许对 Person 实例添加 name 和 age 属性。</p>
<pre><code class="language-python">class Person:
    __slots__ = (&quot;name&quot;, &quot;age&quot;)
    def __init__(self,name,age):
        self.name = name
        self.age = age

p = Person(&quot;老王&quot;,20)
p.score = 100

out:
Traceback (most recent call last):  File &quot;C:/Users/Administrator/PycharmProjects/test/app.py&quot;, line 8, in &lt;module&gt;
    p.score = 100

AttributeError: 'Person' object has no attribute 'score'
</code></pre>
<blockquote>
<p>使用 <code>__slots__</code> 要注意， <code>__slots__</code> 定义的属性仅对当前类实例起作用，对继承的子类是不起作用</p>
</blockquote>
<p>当你定义<code>__slots__</code>后，Python 就会为实例使用一种更加紧凑的内部表示。
实例通过一个很小的固定大小的数组来构建，而不是为每个实例定义一个字典。所以<code>__slots__</code>是创建大量对象时节省内存的方法。</p>
<p><code>__slots__</code>的副作用是作为一个封装工具来防止用户给实例增加新的属性。 尽管使用<code>__slots__</code>可以达到这样的目的，但是这个并不是它的初衷。</p>
<h2 id="34-一些方法"><a class="header" href="#34-一些方法">3.4 一些方法</a></h2>
<p>hasattr()函数用于判断对象是否包含对应的属性</p>
<p>getattr()函数用于返回一个对象属性值</p>
<p>setattr 函数，用于设置属性值，该属性必须存在</p>
<p>delattr 函数用于删除属性，delattr(x,'foobar)相当于 del x.foobar</p>
<h1 id="04-__call__魔法方法"><a class="header" href="#04-__call__魔法方法">04-<code>__call__</code>魔法方法</a></h1>
<p>可以使得函数可以直接被调用</p>
<pre><code class="language-python">class Person(object):

    def __call__(self, *args, **kwargs):
        return &quot;ToString()&quot;

person = Person()
print(person())

out:
ToString()
</code></pre>
<h1 id="05-闭包"><a class="header" href="#05-闭包">05-闭包</a></h1>
<p>闭包就是，内层函数调用了外层函数的方法或变量，并返回内层方法。</p>
<p><strong>闭包会保存局部作用域的变量。</strong></p>
<pre><code class="language-python">def outer(num):
    num = num

    def inner():
        nonlocal num
        num += 1
        print(num)

    return inner

func = outer(100)
func()
func()
func()
func()

out:
101
102
103
104
</code></pre>
<blockquote>
<p><strong>闭包的内部函数不可以使用外部循环的变量，或者会变化的变量</strong></p>
</blockquote>
<pre><code class="language-python">def count():
    fs = []
    for i in range(1, 4):
        def f():
            return i*i
        fs.append(f)
    return fs

f1, f2, f3 = count()
print(f1())
print(f2())
print(f3())

out:
9
9
9
</code></pre>
<p>原因是，调用的时候，i 已经变为 3 了，def 定义的函数不会立即执行。</p>
<p>进行一些修改：</p>
<pre><code class="language-python">def count():
    def f(j):
        return lambda: j * j
    fs = []
    for i in range(1, 4):
        fs.append(f(i))
        # f(i)立刻被执行，因此i的当前值被传入闭包lambda: j * j
    return fs


f1, f2, f3 = count()
print(f1())
print(f2())
print(f3())

out：
1
4
9
</code></pre>
<p>f(i)立刻被执行，因此 i 的当前值被传入闭包 lambda: j * j，调用的时候只是在调用 lambda:j*j</p>
<p>也可以这么写：</p>
<pre><code class="language-python">def count():
    def f(j):
        def double():
            return j*j
        return double
    fs = []
    for i in range(1, 4):
        fs.append(f(i))
    return fs
</code></pre>
<h1 id="06-装饰器"><a class="header" href="#06-装饰器">06-装饰器</a></h1>
<p>装饰器（decorator）接受一个 callable 对象 （可以是函数或者实现了 call 方法的类）作为参数，并返回一个 callable 对象
它经常用于有切面需求的场景，比如：插入日志、性能测试（函数执行时间统计）、事务处理、缓存、权限校验等场景。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码并继续重用。
举个实例，假设你写好了 100 个 Flask 中的路由函数，现在要在访问这些路由函数前，先判断用户 是否有权限，你不可能去这 100 个路由函数中都添加一遍权限判断的代码（如果权限判断代码为 5
行，你得加 500 行）。那么，你可能想把权限认证的代码抽离为一个函数，然后去那 100 个路由函 数中调用这个权限认证函数，这样只要加 100
行。但是，根据开放封闭原则，对于已经实现的功能代码建议不能修改， 但可以扩展，因为可能你在这些路由函数中直接添加代码会导致原函数出 现问题，那么最佳实践是使用装饰器</p>
<pre><code class="language-python">def my_func():
    print(&quot;step 2 : my_func&quot;)


def outer(my_func):
    print(&quot;step 1 : outer&quot;)
    def inner():
        my_func()
        print(&quot;step 3 : inner&quot;)
    return inner


# 传入my_func的引用
# 方法名即变量名，是引用，也就是改变了my_func的指向。即可在不改变原有功能下，增加新功能
my_func = outer(my_func)
my_func()

out：
step 1 : outer
step 2 : my_func
step 3 : inner
</code></pre>
<blockquote>
<p>传入 my_func 的引用，方法名即变量名，是引用，也就是改变了 my_func 的指向。即可在不改变原有功能下，增加新功能</p>
</blockquote>
<p>使用 Python 语法糖<code>@</code>，</p>
<p><code>@</code>也就是封装了一行语句：<code>my_func = outer(my_func)</code>，将这行代码简化</p>
<pre><code class="language-python">def outer(my_func):
    print(&quot;step 1 : outer&quot;)
    def inner():
        my_func()
        print(&quot;step 3 : inner&quot;)
    return inner

@outer
def my_func():
    print(&quot;step 2 : my_func&quot;)

my_func()#等价于inner()

out：
step 1 : outer
step 2 : my_func
step 3 : inner
</code></pre>
<blockquote>
<p>被装饰器修饰的代码块一定是在下面的，是原来的功能。</p>
</blockquote>
<blockquote>
<p>新的方法应当写在老方法的上面，然后在老方法用<code>@新方法名</code>修饰，然后老代码无需修改，即可调用新的功能</p>
</blockquote>
<h2 id="61-装饰器的几种"><a class="header" href="#61-装饰器的几种">6.1 装饰器的几种</a></h2>
<blockquote>
<p>对原函数而言</p>
</blockquote>
<h3 id="611-没有参数没有返回值"><a class="header" href="#611-没有参数没有返回值">6.1.1 没有参数、没有返回值</a></h3>
<p>同上述的例子</p>
<h3 id="612-有参数没有返回值"><a class="header" href="#612-有参数没有返回值">6.1.2 有参数、没有返回值</a></h3>
<pre><code class="language-python">def outer(my_func):
    print(&quot;step 1 : outer&quot;)
    def inner(num):
        my_func(num)
        print(&quot;step 3 : inner&quot;)
    return inner

@outer
def my_func(num):
    print(&quot;step 2 : my_func      传入的参数&quot;,num)

my_func(100) #等价于inner(100)

out：
step 1 : outer
step 2 : my_func      传入的参数 100
step 3 : inner
</code></pre>
<h3 id="613-没有参数有返回值"><a class="header" href="#613-没有参数有返回值">6.1.3 没有参数、有返回值</a></h3>
<pre><code class="language-python">def outer(my_func):
    print(&quot;step 1 : outer&quot;)
    def inner():
        print(&quot;step 2 : 进入内部函数&quot;)
        return my_func()
    return inner


@outer
def my_func():
    print(&quot;step 3 : my_func&quot;)
    return &quot;初始函数返回值&quot;


print(my_func())

out：
step 1 : outer
step 2 : 进入内部函数
step 3 : my_func
初始函数返回值
</code></pre>
<h3 id="614-有参数有返回值"><a class="header" href="#614-有参数有返回值">6.1.4 有参数、有返回值</a></h3>
<pre><code class="language-python">def outer(my_func):
    print(&quot;step 1 : outer&quot;)
    def inner(num):
        print(&quot;step 2 : 进入内部函数&quot;)
        return my_func(num)
    return inner


@outer
def my_func(num):
    print(&quot;step 3 : my_func,传入的参数：&quot;, num)
    num += 1
    return &quot;加1之后：&quot; + str(num)


print(my_func(num=100))


out：
step 1 : outer
step 2 : 进入内部函数
step 3 : my_func,传入的参数： 100
加1之后：101
</code></pre>
<h2 id="62-万能装饰器"><a class="header" href="#62-万能装饰器">6.2 万能装饰器</a></h2>
<p>利用<code>*args</code>，<code>*kwargs</code>传参</p>
<blockquote>
<p>需要注意的是，传入到 inner 内部调用的函数的时候，需要解包</p>
</blockquote>
<blockquote>
<p>即还是写成<code>*args,*kwargs</code></p>
</blockquote>
<h2 id="63-多装饰器"><a class="header" href="#63-多装饰器">6.3 多装饰器</a></h2>
<pre><code class="language-python">def outer1(func):
    print(&quot;outer1&quot;)
    def inner():
        print(&quot;inner1&quot;)
        return func()
    return inner

def outer2(func):
    print(&quot;outer2&quot;)
    def inner():
        print(&quot;inner2&quot;)
        return func()
    return inner


@outer1
@outer2
def func():
    print(&quot;func&quot;)


func()


out：
outer2
outer1
inner1
inner2
func
</code></pre>
<h2 id="64-带参数的装饰器"><a class="header" href="#64-带参数的装饰器">6.4 带参数的装饰器</a></h2>
<pre><code class="language-python">def outer(str):
    print(&quot;outer&quot;)
    def outer1(func):
        print(&quot;outer1&quot;)
        def inner():
            print(str)
            print(&quot;inner&quot;)
            return func()
        return inner
    return outer1

@outer(&quot;哈哈哈&quot;)
def func():
    print(&quot;func&quot;)


func()

out：
outer
outer1   # 到此处都是装饰的时候生成的，下面才是调用的时候生成的
哈哈哈
inner
func
</code></pre>
<p>@函数名是装饰器</p>
<p>@函数名（）是在调用函数后装饰</p>
<p>则在此处，outer()应当返回一个函数引用。</p>
<blockquote>
<p>三层嵌套的函数可以为装饰器接受参数。</p>
</blockquote>
<blockquote>
<p>二层嵌套的函数不可以接受参数。</p>
</blockquote>
<h2 id="65-还原函数名称"><a class="header" href="#65-还原函数名称">6.5 还原函数名称</a></h2>
<pre><code class="language-python">def outer(func):
    print(&quot;outer&quot;)
    def inner():
        print(&quot;inner&quot;)
        print(func.__name__)
        return func()
    return inner

@outer
def func():
    print(&quot;func in&quot;)

func()  # 就是innner()

# 获取当前函数的名称
print(func.__name__)

out:
outer
inner
func
func in
inner
</code></pre>
<p>被装饰器修饰过的方法，打印的方法名称都是 inner，在打印日志的时候就无法追踪了。</p>
<p>在此需要还原方法名称</p>
<p>使用 Python 的<code>@wraps</code>帮助还原被装饰器修饰的函数名</p>
<pre><code class="language-python">from functools import wraps

def outer(func):
    print(&quot;outer&quot;)
    # 将方法名传入wraps
    @wraps(func)
    def inner():
        print(&quot;inner&quot;)
        print(func.__name__)
        return func()
    return inner

@outer
def func():
    print(&quot;func in&quot;)

@outer
def func1():
    print(&quot;func1 in&quot;)

func()  # 就是innner()
func1()

# 获取当前函数的名称
print(func.__name__)
print(func1.__name__)


out：
outer
outer
inner
func
func in
inner
func1
func1 in
func
func1
</code></pre>
<p>用<code>@wraps（函数名）</code>修饰 inner 的内部方法。即可还原函数名</p>
<h2 id="66-类装饰器"><a class="header" href="#66-类装饰器">6.6 类装饰器</a></h2>
<p>用类装饰的函数</p>
<pre><code class="language-python">class A:
    # outer
    def __init__(self,func):
        print(&quot;开始装饰&quot;)
        self.func = func

    # inner
    def __call__(self, *args, **kwargs):
        print(&quot;类装饰器&quot;)
        return self.func()


@A       # func = A(func) 创建一个对象，func--&gt;A类的实例对象。
def func():
    print(&quot;this is func&quot;)

func()

out:
开始装饰
类装饰器
this is func
</code></pre>
<h1 id="7-案例"><a class="header" href="#7-案例">7-案例</a></h1>
<h2 id="1函数执行时间的统计"><a class="header" href="#1函数执行时间的统计">1.函数执行时间的统计</a></h2>
<pre><code class="language-python">import time
from functools import wraps

def outer(func):
    @wraps(func)
    def inner(num):
        start = time.time()
        ret = func(num)
        end = time.time()
        print(&quot;执行时间为：&quot;, end-start)
        return ret
    return inner

@outer
def func(num):
    ret = 0
    for i in range(num+1):
        ret += i
    return ret

print(func(100000000))


out:
执行时间为： 7.979628324508667
5000000050000000
</code></pre>
<h2 id="2日志记录"><a class="header" href="#2日志记录">2.日志记录</a></h2>
<p>首先是之前的日志模块，这里重新贴一遍，略作修改</p>
<pre><code class="language-python">import logging

# 1. 创建一个叫aiotest的logger实例，如果参数为空则返回root
logger = logging.getLogger('aiotest')

# 2. 设置总日志级别, 也可以给不同的handler设置不同的日志级别
logger.setLevel(logging.DEBUG)

# 3. 设置Formatter
formatter = logging.Formatter('%(asctime)s - %(filename)s [line:%(lineno)d] - %(func)s - &lt;%(threadName)s %(thread)d&gt;' +
                              ' - &lt;Process %(process)d&gt; - %(levelname)s: %(message)s')

# 4. 创建Handler
# 文件Handler
file_handler = logging.FileHandler(&quot;logger.log&quot;, encoding=&quot;utf8&quot;)
# 控制台输出Handler
stream_handler = logging.StreamHandler()

# 5. 给Handler设置属性
stream_handler.setFormatter(formatter)
file_handler.setFormatter(formatter)
stream_handler.setLevel(logging.DEBUG)
file_handler.setLevel(logging.WARNING)

# 6. 将Handler添加到logger实例上
logger.addHandler(stream_handler)
logger.addHandler(file_handler)
</code></pre>
<p>因为<code>%(funcName)s</code>永远获取的是调用函数的 inner
的名字，所以这里传入新的自定义变量，将正确的函数名通过<code>@wraps(函数引用)</code>来传入，并通过<code>.__name__</code>方法获取正确的函数名称。</p>
<pre><code class="language-python">from functools import wraps
from myLog import logger


def outer(func):
    @wraps(func)
    def inner(*args, **kwargs):
        try:
            logger.info(&quot;当前执行方法为：&quot; + func.__name__, extra={'func': func.__name__})
            return func(*args, **kwargs)
        except Exception as e:
            logger.error(e.__repr__(), extra={'func': func.__name__})

    return inner


@outer
def func1(*args, **kwargs):
    return 1 / 1


@outer
def func2(*args, **kwargs):
    return 1 / 0


print(func1())
print(func2())

out：
2019-08-08 23:37:10,982 - 02-对象.py [line:8] - func1 - &lt;MainThread 14556&gt; - &lt;Process 18380&gt; - INFO: 当前执行方法为：func1
1.0
2019-08-08 23:37:10,983 - 02-对象.py [line:8] - func2 - &lt;MainThread 14556&gt; - &lt;Process 18380&gt; - INFO: 当前执行方法为：func2
None
2019-08-08 23:37:10,983 - 02-对象.py [line:11] - func2 - &lt;MainThread 14556&gt; - &lt;Process 18380&gt; - ERROR: ZeroDivisionError('division by zero',)

日志文件中的记录：
2019-08-08 23:41:24,756 - 02-对象.py [line:12] - func2 - &lt;MainThread 16856&gt; - &lt;Process 8564&gt; - ERROR: ZeroDivisionError('division by zero',)
</code></pre>
<p>疑问：</p>
<p>执行顺序问题。多次执行打印的顺序不一样？</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1正则表达式"><a class="header" href="#1正则表达式">1.正则表达式</a></h1>
<p>Regular Expression，正则表达式</p>
<p>用来描述匹配规则的表达式，针对字符串进行比较和匹配</p>
<p>作用：用来检索、替换哪些符合某个规则的文本</p>
<p>使用场景：</p>
<ul>
<li>验证数据 前端，电话/邮箱</li>
<li>抓数据 页面抓取数据</li>
<li>洗数据 洗掉冗余数据</li>
</ul>
<h2 id="11python-里的正则表达式re-模块"><a class="header" href="#11python-里的正则表达式re-模块">1.1Python 里的正则表达式（re 模块）</a></h2>
<ol>
<li><code>match(匹配规则，被匹配的字符串)</code>方法==从头==开始匹配，匹配成功返回 match 对象，匹配失败返回 None（只匹配一次）</li>
<li>从 match 对象获取字符串的方法为<code>.group()</code></li>
<li>获取索引位置的元组<code>span()</code>、起始位置<code>start()</code>、结束位置<code>end()</code></li>
</ol>
<pre><code class="language-python">import re

s = &quot;我喜欢吃火锅&quot;
ret = re.match(&quot;我喜欢&quot;,s)
print(ret)

print(ret.group())
print(ret.span())
print(ret.start())
print(ret.end())

out：
&lt;_sre.SRE_Match object; span=(0, 3), match='我喜欢'&gt;
我喜欢
(0, 3)
0
3
</code></pre>
<ol start="4">
<li><code>search(匹配规则，被匹配的字符串)</code>从字符串中进行搜索，一旦匹配成功返回第一次匹配成功的位置，不成功返回 None，使用方法和 match 一样（只匹配一次）</li>
</ol>
<pre><code class="language-python">import re

s = &quot;我喜欢吃火锅我喜欢吃火锅&quot;

ret1 = re.search(&quot;火锅&quot;,s)
print(ret1)
print(ret1.group())

out：
&lt;_sre.SRE_Match object; span=(4, 6), match='火锅'&gt;
火锅
</code></pre>
<ol start="5">
<li>
<p><code>findall(匹配规则，被匹配的字符串)</code>，搜索全部，匹配全部，返回一个列表，包含所有符合规则的字符串。</p>
</li>
<li>
<p><code>finditer(匹配规则，被匹配的字符串)</code>，搜索全部，匹配全部，返回一个迭代器，对象是 match 对象。</p>
</li>
</ol>
<pre><code class="language-python">import re

s = &quot;我喜欢吃火锅我喜欢吃火锅&quot;

ret1 = re.findall(&quot;火锅&quot;, s)
print(ret1)
ret2 = re.finditer(&quot;火锅&quot;, s)
for i in ret2:
    print(i)


out：
['火锅', '火锅']
&lt;_sre.SRE_Match object; span=(4, 6), match='火锅'&gt;
&lt;_sre.SRE_Match object; span=(10, 12), match='火锅'&gt;
</code></pre>
<ol start="7">
<li><code>split()</code>将字符串按照匹配规则进行切割，返回一个切割后的列表</li>
</ol>
<pre><code class="language-python">import re

s = &quot;asdf jkl;     asdf  werq,asdf,   foo&quot;

# 先匹配一个空格，后面可能有任意个空格
ret = re.split(&quot;[\s,;]\s*&quot;, s)
print(ret)

out：
['asdf', 'jkl', 'asdf', 'werq', 'asdf', 'foo']
</code></pre>
<ol start="8">
<li><code>sbu(规则，替换的串，被匹配的字符串)</code>用来做高级替换</li>
</ol>
<pre><code class="language-python">import re

s = &quot;我还要再活500年,20年&quot;

ret = re.sub(&quot;\d+&quot;, &quot;1000&quot;, s)
print(ret)
ret = re.sub(&quot;\d+&quot;, &quot;2000&quot;, s)
print(ret)

out：
我还要再活1000年,1000年
我还要再活2000年,2000年
</code></pre>
<p><code>sub()</code>还有高阶用法，传入函数，对匹配到的 Match 对象进行操作，并返回一个字符串</p>
<pre><code class="language-pytohn">import re

s = &quot;我还要再活500年,20年&quot;


def func(num):
    # 匹配到的是一个Match对象，所以传进来是个Match对象，要使用group获取字符串
    n = num.group()
    return str(int(n) + 1)


ret = re.sub(&quot;\d+&quot;, func, s)
print(ret)
ret = re.sub(&quot;\d+&quot;, func, s)
print(ret)

out：
我还要再活501年,21年
我还要再活501年,21年
</code></pre>
<h2 id="12-正则表达式的语法"><a class="header" href="#12-正则表达式的语法">1.2 正则表达式的语法</a></h2>
<h3 id="121-单字符匹配"><a class="header" href="#121-单字符匹配">1.2.1 单字符匹配</a></h3>
<table><thead><tr><th>方法</th><th>含义</th></tr></thead><tbody>
<tr><td>.</td><td>匹配单字符（万能匹配，什么都可以匹配），但是不能匹配<code>\n</code></td></tr>
<tr><td>\d</td><td>匹配所有的数字（0-9 的单字符）</td></tr>
<tr><td>\D</td><td>匹配所有的非数字（0-9 的单字符）</td></tr>
<tr><td>\w</td><td>匹配所有的单词字符（数字、字母和下划线），Python3 中汉字也是单词字符</td></tr>
<tr><td>\W</td><td>上述相反</td></tr>
<tr><td>\s</td><td>匹配所有空白符</td></tr>
<tr><td>\S</td><td>匹配所有非空白符</td></tr>
<tr><td>[]</td><td>内部任意一个（^表示非）</td></tr>
</tbody></table>
<p><strong>案例：</strong></p>
<pre><code class="language-python">ret = re.match(&quot;张.龙&quot;, &quot;张海龙&quot;)
print(ret)
ret = re.match(&quot;张.龙&quot;, &quot;张龙&quot;)
print(ret)
ret = re.match(&quot;张.龙&quot;, &quot;张\n龙&quot;)
print(ret)

out:
&lt;_sre.SRE_Match object; span=(0, 3), match='张海龙'&gt;
None
None
</code></pre>
<pre><code class="language-python">ret = re.match(&quot;张.龙&quot;, &quot;张2龙&quot;)
print(ret)
ret = re.match(&quot;张\d龙&quot;, &quot;张2龙&quot;)
print(ret)
ret = re.match(&quot;张\d龙&quot;, &quot;张12龙&quot;)
print(ret)
ret = re.match(&quot;张\d龙&quot;, &quot;张海龙&quot;)
print(ret)

out:
&lt;_sre.SRE_Match object; span=(0, 3), match='张2龙'&gt;
&lt;_sre.SRE_Match object; span=(0, 3), match='张2龙'&gt;
None
None
</code></pre>
<pre><code class="language-python">ret = re.match(&quot;张\D龙&quot;, &quot;张2龙&quot;)
print(ret)
ret = re.match(&quot;张\D龙&quot;, &quot;张s龙&quot;)
print(ret)
ret = re.match(&quot;张\D龙&quot;, &quot;张#龙&quot;)
print(ret)
ret = re.match(&quot;张\D龙&quot;, &quot;张海龙&quot;)
print(ret)

out:
None
&lt;_sre.SRE_Match object; span=(0, 3), match='张s龙'&gt;
&lt;_sre.SRE_Match object; span=(0, 3), match='张#龙'&gt;
&lt;_sre.SRE_Match object; span=(0, 3), match='张海龙'&gt;
</code></pre>
<pre><code class="language-python">ret = re.match(&quot;张\w龙&quot;, &quot;张海龙&quot;)
print(ret)
ret = re.match(&quot;张\w龙&quot;, &quot;张s龙&quot;)
print(ret)
ret = re.match(&quot;张\w龙&quot;, &quot;张#龙&quot;)
print(ret)
ret = re.match(&quot;张\w龙&quot;, &quot;张2龙&quot;)
print(ret)

out：
&lt;_sre.SRE_Match object; span=(0, 3), match='张海龙'&gt;
&lt;_sre.SRE_Match object; span=(0, 3), match='张s龙'&gt;
None
&lt;_sre.SRE_Match object; span=(0, 3), match='张2龙'&gt;
</code></pre>
<pre><code class="language-python">ret = re.match(&quot;张\W龙&quot;, &quot;张海龙&quot;)
print(ret)
ret = re.match(&quot;张\W龙&quot;, &quot;张s龙&quot;)
print(ret)
ret = re.match(&quot;张\W龙&quot;, &quot;张#龙&quot;)
print(ret)
ret = re.match(&quot;张\W龙&quot;, &quot;张2龙&quot;)
print(ret)

out:
None
None
&lt;_sre.SRE_Match object; span=(0, 3), match='张#龙'&gt;
None
</code></pre>
<pre><code class="language-python">ret = re.match(&quot;张\s龙&quot;, &quot;张 龙&quot;)
print(ret)
ret = re.match(&quot;张\s龙&quot;, &quot;张\n龙&quot;)
print(ret)
ret = re.match(&quot;张\s龙&quot;, &quot;张\r龙&quot;)
print(ret)
ret = re.match(&quot;张\s龙&quot;, &quot;张\t龙&quot;)
print(ret)
ret = re.match(&quot;张\s龙&quot;, &quot;张\f龙&quot;)
print(ret)
ret = re.match(&quot;张\s龙&quot;, &quot;张海龙&quot;)
print(ret)
ret = re.match(&quot;张\s龙&quot;, &quot;张龙&quot;)
print(ret)

out：
&lt;_sre.SRE_Match object; span=(0, 3), match='张 龙'&gt;
&lt;_sre.SRE_Match object; span=(0, 3), match='张\n龙'&gt;
&lt;_sre.SRE_Match object; span=(0, 3), match='张\r龙'&gt;
&lt;_sre.SRE_Match object; span=(0, 3), match='张\t龙'&gt;
&lt;_sre.SRE_Match object; span=(0, 3), match='张\x0c龙'&gt;
None
None
</code></pre>
<pre><code class="language-python">ret = re.match(&quot;张\S龙&quot;, &quot;张 龙&quot;)
print(ret)
ret = re.match(&quot;张\S龙&quot;, &quot;张\n龙&quot;)
print(ret)
ret = re.match(&quot;张\S龙&quot;, &quot;张\r龙&quot;)
print(ret)
ret = re.match(&quot;张\S龙&quot;, &quot;张\t龙&quot;)
print(ret)
ret = re.match(&quot;张\S龙&quot;, &quot;张\f龙&quot;)
print(ret)
ret = re.match(&quot;张\S龙&quot;, &quot;张海龙&quot;)
print(ret)
ret = re.match(&quot;张\S龙&quot;, &quot;张龙&quot;)
print(ret)

out：
None
None
None
None
None
&lt;_sre.SRE_Match object; span=(0, 3), match='张海龙'&gt;
None
</code></pre>
<pre><code class="language-python">import re

ret = re.match(&quot;张[\d\w\s#]龙&quot;, &quot;张#龙&quot;)
print(ret)
ret = re.match(&quot;张[a-zA-Z0-9]龙&quot;, &quot;张1龙&quot;)
print(ret)
# ^表示非
ret = re.match(&quot;张[^a-zA-Z0-9]龙&quot;, &quot;张1龙&quot;)
print(ret)
ret = re.match(&quot;张[^a-zA-Z0-9]龙&quot;, &quot;张海龙&quot;)
print(ret)
ret = re.match(&quot;张[^a-zA-Z0-9]龙&quot;, &quot;张A龙&quot;)
print(ret)

out:
&lt;_sre.SRE_Match object; span=(0, 3), match='张#龙'&gt;
&lt;_sre.SRE_Match object; span=(0, 3), match='张1龙'&gt;
None
&lt;_sre.SRE_Match object; span=(0, 3), match='张海龙'&gt;
None
</code></pre>
<h3 id="122-多字符匹配"><a class="header" href="#122-多字符匹配">1.2.2 多字符匹配</a></h3>
<table><thead><tr><th>方法</th><th>含义</th></tr></thead><tbody>
<tr><td>*</td><td>匹配 0 或任意个前面的字符</td></tr>
<tr><td>+</td><td>匹配 1 或任意个前面的字符</td></tr>
<tr><td>？</td><td>匹配 0 或 1 个前面的字符</td></tr>
<tr><td>{m}</td><td>匹配指定 m 个前面的字符<br />数量不足返回失败</td></tr>
<tr><td>{n,m}</td><td>匹配范围[n-m]数量前面的字符<br />数量不足返回失败</td></tr>
</tbody></table>
<pre><code class="language-python">import re

s = &quot;我的电话是12345678905.&quot;

# 匹配成功，但是是空，因为*是匹配0或任意个，匹配到了0个
ret = re.search(&quot;\d*&quot;, s)
print(ret)

# 匹配成功,因为+是匹配1或任意个
ret = re.search(&quot;\d+&quot;, s)
print(ret)

ret = re.search(&quot;\d?&quot;, s)
print(ret)

s = &quot;0451-88888888&quot;
ret = re.search(&quot;0\d+-\d{8}&quot;, s)
print(ret)

out：
&lt;_sre.SRE_Match object; span=(0, 0), match=''&gt;
&lt;_sre.SRE_Match object; span=(5, 16), match='12345678905'&gt;
&lt;_sre.SRE_Match object; span=(0, 0), match=''&gt;
&lt;_sre.SRE_Match object; span=(0, 13), match='0451-88888888'&gt;
</code></pre>
<h3 id="123-边界匹配"><a class="header" href="#123-边界匹配">1.2.3 边界匹配</a></h3>
<p>r 开头引号的字符串表示正则表达式，不然有些会有转义效果</p>
<table><thead><tr><th>方法</th><th>含义</th></tr></thead><tbody>
<tr><td>^</td><td>必须以规则开头匹配（电话）</td></tr>
<tr><td>$</td><td>必须以规则结尾匹配（邮箱）</td></tr>
<tr><td>\b</td><td>位置两侧不可以都是单词字符</td></tr>
<tr><td>\B</td><td>位置两侧必须都是单词字符</td></tr>
<tr><td>\A</td><td>匹配字符串开始的位置</td></tr>
<tr><td>\Z</td><td>匹配字符串结束的位置</td></tr>
</tbody></table>
<pre><code class="language-python">s = &quot;asd&quot;

ret = re.search(r&quot;\ba\w+&quot;, s)
print(ret)

s = &quot;sasd&quot;
ret = re.search(r&quot;\ba\w+&quot;, s)
print(ret)

out:
&lt;_sre.SRE_Match object; span=(0, 3), match='asd'&gt;
None
</code></pre>
<h3 id="124-分组匹配"><a class="header" href="#124-分组匹配">1.2.4 分组匹配</a></h3>
<p><code>|</code>符号匹配两边任意一边的正则表达式即可，</p>
<p><code>pattern</code>参数写一个串</p>
<p><strong>分组：</strong></p>
<p>分组内部进行或匹配，外部相同。</p>
<p><code>group(0)</code>是所有</p>
<p>例子：</p>
<pre><code class="language-python">import re

s = &quot;我喜欢吃火锅，我喜欢吃小面，我喜欢吃拉面，我喜欢吃乌冬面，我喜欢吃烧鸡公，&quot;

ret = re.search(&quot;我喜欢吃(火锅|小面)&quot;, s)
print(ret)
print(ret.group())
print(ret.group(0))
print(ret.group(1))

ret = re.search(&quot;(我喜欢吃)(火锅|小面)&quot;, s)
print(ret)
print(ret.group())
print(ret.group(0))
print(ret.group(1))
print(ret.group(2))


out：
&lt;_sre.SRE_Match object; span=(0, 6), match='我喜欢吃火锅'&gt;
我喜欢吃火锅
我喜欢吃火锅
火锅
&lt;_sre.SRE_Match object; span=(0, 6), match='我喜欢吃火锅'&gt;
我喜欢吃火锅
我喜欢吃火锅
我喜欢吃
火锅
</code></pre>
<p><strong>复用分组匹配的内容：</strong></p>
<pre><code class="language-python">s = &quot;&lt;h1&gt;我是标题标签&lt;/h2&gt;&quot;

ret = re.match(r&quot;&lt;\w+&gt;.*&lt;/\w+&gt;&quot;, s)
print(ret)

ret = re.match(r&quot;&lt;(\w+)&gt;.*&lt;/\1&gt;&quot;, s)
print(ret)

s = &quot;&lt;h1&gt;我是标题标签&lt;/h1&gt;&quot;
ret = re.match(r&quot;&lt;(\w+)&gt;.*&lt;/\1&gt;&quot;, s)
print(ret)

s = &quot;&lt;body&gt;&lt;h1&gt;我是标题标签&lt;/h1&gt;&lt;/body&gt;&quot;
ret = re.match(r&quot;&lt;(\w+)&gt;&lt;(\w+)&gt;.*&lt;/\2&gt;&lt;/\1&gt;&quot;, s)
print(ret)

out：
&lt;_sre.SRE_Match object; span=(0, 15), match='&lt;h1&gt;我是标题标签&lt;/h2&gt;'&gt;
None
&lt;_sre.SRE_Match object; span=(0, 15), match='&lt;h1&gt;我是标题标签&lt;/h1&gt;'&gt;
&lt;_sre.SRE_Match object; span=(0, 28), match='&lt;body&gt;&lt;h1&gt;我是标题标签&lt;/h1&gt;&lt;/body&gt;'&gt;
</code></pre>
<p><strong>分组命名：</strong></p>
<p>定义：<code>(?P&lt;name&gt;正则)</code>，P 是大写</p>
<p>使用：<code>(?P=name)</code></p>
<p>例子：</p>
<pre><code class="language-python">s = &quot;&lt;body&gt;&lt;h1&gt;我是标题标签&lt;/h1&gt;&lt;/body&gt;&quot;
ret = re.match(r&quot;&lt;(?P&lt;body&gt;\w+)&gt;&lt;(?P&lt;h1&gt;\w+)&gt;.*&lt;/(?P=h1)&gt;&lt;/(?P=body)&gt;&quot;, s)
print(ret)

out:
&lt;_sre.SRE_Match object; span=(0, 28), match='&lt;body&gt;&lt;h1&gt;我是标题标签&lt;/h1&gt;&lt;/body&gt;'&gt;
</code></pre>
<h2 id="13-一些其他参数flag"><a class="header" href="#13-一些其他参数flag">1.3 一些其他参数(Flag)</a></h2>
<table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody>
<tr><td>re.IGNORECASE（re.I）</td><td>忽略大小写</td></tr>
<tr><td>re.MULTILINE（re.M）</td><td>可换行(<code>\n</code>自动进入下一行)</td></tr>
<tr><td>re.ASCII（re.A）</td><td>使\w/\W/d/\D/\s/\S/\b/\B 只匹配 ASCII 字符，不匹配 Unicode 字符</td></tr>
<tr><td>re.Unicode（re.U）</td><td>默认使用此标志位，\w/\W/d/\D/\s/\S/\b/\B 会匹配 Unicode 字符，如果指定了 re.A 标志，则 re.U 失效</td></tr>
<tr><td>re.DOTALL（re.S）</td><td>使得<code>.</code>会匹配换行符等其他字符</td></tr>
<tr><td>re.VERBOSE（re.X）</td><td>允许整个正则表达式写成多行，忽略空白字符，并可以添加<code>#</code>开头的注释，这样更美观。</td></tr>
</tbody></table>
<h2 id="14-贪婪和非贪婪"><a class="header" href="#14-贪婪和非贪婪">1.4 贪婪和非贪婪</a></h2>
<p>正则表达式默认情况下会尽可能多的匹配，</p>
<p>如：</p>
<p>asdf.png///123.png</p>
<p>如果写<code>\w+.png</code>不会匹配到 asdf.png</p>
<p>而是会匹配整个串</p>
<p>如果需要修改为非贪婪，就要在一些情况后面加上<code>?</code>操作符</p>
<p>包括：<code>+,?,*,[n-m]</code></p>
<p>在使用的时候在这些符号后面加上<code>?</code>即可更改匹配模式为非贪婪</p>
<h1 id="2可迭代器"><a class="header" href="#2可迭代器">2.可迭代器</a></h1>
<h2 id="21-可迭代对象"><a class="header" href="#21-可迭代对象">2.1 可迭代对象</a></h2>
<p>使用<code>iter()</code>来获取可迭代对象（是可迭代对象就返回对象，如果不是就报错）</p>
<p>可迭代对象就是一个可以通过 iter 方法获取到迭代器（iterator）的对象。</p>
<p>可迭代对象：</p>
<ul>
<li>对象实现了能返回迭代器的<code>__iter__()</code>方法</li>
<li>对象实现了<code>__getitem__(index)</code>方法，而且 index 参数是从 0 开始的整数（索引）</li>
</ul>
<p>Python
中内置的序列类型，如<code>list、tuple、str、bytes、dict、set、collections.deque</code>等都可以迭代，因为都实现了<code>__getitem__(index)</code>方法。</p>
<blockquote>
<p>注意：其实标准的序列还都实现了 <code>__iter__()</code> 方法</p>
</blockquote>
<h3 id="211-判断是否是一个可迭代对象"><a class="header" href="#211-判断是否是一个可迭代对象">2.1.1 判断是否是一个可迭代对象</a></h3>
<pre><code class="language-python">from collections import abc

l = [1, 2, 3, 4]

ret = isinstance(l,abc.Iterable)

print(ret)

out：
True
</code></pre>
<p>最准确的方法还是调用<code>iter(l)</code>，<code>iter</code>会考虑历史遗留的<code>__getitem__(index)</code>方法，abc.Iterable 只会考虑<code>__iter()__</code>方法。</p>
<h3 id="212-构建可迭代对象"><a class="header" href="#212-构建可迭代对象">2.1.2 构建可迭代对象</a></h3>
<ul>
<li><code>__iter__()</code></li>
<li><code>__getitem__(index)</code></li>
</ul>
<p>只要实现其中一个就是可迭代对象</p>
<p>如果实现了<code>__iter__()</code> 方法，但是该方法没有返回迭代器的时候</p>
<p>调用<code>abc.Iterable</code>会返回<code>True</code>的错误判断。</p>
<p><code>iter()</code>会抛出异常</p>
<h3 id="213iter函数"><a class="header" href="#213iter函数">2.1.3<code>iter()</code>函数</a></h3>
<p>Python 迭代器要求<code>iter()</code>必须返回特殊的迭代器对象。</p>
<p>迭代器对象必须实现<code>__next__()</code>方法，并使用<code>StopIteration</code>异常来通知迭代结束</p>
<p><code>iter()</code>函数有两种使用方法：</p>
<ul>
<li><code>iter(iterable) -&gt; iterator</code>：传入可迭代对象，返回迭代器</li>
<li><code>iter(callable,sentinel) -&gt; iterator</code>：传入两个参数，第一个必须是可调用的对象（没有参数），用于不断调用，产出各个值，第二个值是==哨符==，是一个标记值，当第一个参数的调用返回了这个值的时候，触发迭代器抛出<code>StopIteration</code>异常，==不产出哨符==</li>
</ul>
<p><strong>例子：投骰子</strong></p>
<pre><code class="language-python">import random


def d6():
    return random.randint(1,6)


d6_iter = iter(d6 , 1)
print(d6_iter)

for it in d6_iter:
    print(it)

out：
&lt;callable_iterator object at 0x000002AC2B708A58&gt;
4
6
</code></pre>
<p><strong>例子：逐行读取文件，直到遇到空行或者达到文件末尾为止</strong></p>
<pre><code class="language-python">with open('mydata.txt') as fp:
    for line in iter(fp.readline, '\n'):
        # fp.readline每次返回一行
        print(line)
</code></pre>
<h2 id="22-迭代器"><a class="header" href="#22-迭代器">2.2 迭代器</a></h2>
<p>内存中放不下数据集的时候，要使用一种惰性的获取数据的方式，即按需要一次获取一个数据对象。</p>
<p>这就是迭代器模式（Iterator pattern）</p>
<p>迭代器就是实现了无参数<code>__next__()</code>方法（无参数），返回序列中的下一个元素。</p>
<p>如果没有元素了，就抛出<code>StopIteration</code>异常。</p>
<p>即迭代器可以被<code>next()</code>函数调用，并不断返回下一个元素的值。</p>
<p>在 Python 语言内部， 迭代器 用于支持：</p>
<ul>
<li>for 循环</li>
<li>构建和扩展集合类型</li>
<li>逐行遍历文本文件</li>
<li>列表推导、字典推导和集合推导</li>
<li>元组拆包</li>
<li>调用函数时，使用*拆包实参</li>
</ul>
<h3 id="221-判断对象是否为迭代器"><a class="header" href="#221-判断对象是否为迭代器">2.2.1 判断对象是否为迭代器</a></h3>
<p>最好是使用<code>isinstance(x,abc.Iterator)</code></p>
<pre><code class="language-python">from collections import abc

l = [1,2,3,4]
it = iter(l)

print(isinstance(l, abc.Iterable))
print(isinstance(l, abc.Iterator))
print(iter(l))
print(isinstance(it, abc.Iterable))
print(isinstance(it, abc.Iterator))
print(iter(it))

out:
True
False
&lt;list_iterator object at 0x000001E5516AA2E8&gt;
True
True
&lt;list_iterator object at 0x000001E5515FB278&gt;
</code></pre>
<blockquote>
<p><strong>Python 中内置的序列类型，如 list、tuple、str、bytes、dict、set、collections.deque 等都是 可迭代的对象，但不是迭代器； 生成器一定是迭代器</strong></p>
</blockquote>
<h3 id="222__next__和__iter__"><a class="header" href="#222__next__和__iter__">2.2.2<code>__next__()</code>和<code>__iter__()</code></a></h3>
<pre><code class="language-python">class A:
    def __init__(self, data):
        self.data = data
        self.index = 0

    def __iter__(self):
        # 返回一个迭代器
        return self

    def __next__(self):
        # 返回下一个元素
        # 有一个索引在记录每次返回的位置
        try:
            ret = self.data[self.index]
            self.index += 1
        except IndexError:
            raise StopIteration()
        return ret
</code></pre>
<p>iter 方法会调用<code>__iter__</code>方法返回当前迭代器对象</p>
<p>next 方法会调用<code>__next__</code>方法返回结果，同时索引增加（index 必须开始是 0 的整数）</p>
<h3 id="223next函数获取迭代器中下一个元素"><a class="header" href="#223next函数获取迭代器中下一个元素">2.2.3<code>next()</code>函数获取迭代器中下一个元素</a></h3>
<p>除了可以用 for 循环处理迭代器中的元素外，可以直接使用<code>next()</code>方法</p>
<blockquote>
<p><strong>如果是最后一个，则 for 不会报错，<code>next()</code>方法报错，原因是 for 循环是一个上下文管理器，会自动捕获异常，而
next()不会。其他迭代上下文也是如此。（列表推导、元组拆包等）</strong></p>
</blockquote>
<p>或者为<code>next()</code>函数指定第二个参数（默认值），执行到末尾后，返回默认值，不会抛出异常</p>
<pre><code class="language-python">with open('/etc/passwd') as fd:
    while True:
        line = next(fd, None)
        if line is None:
            break
        print(line, end='')
</code></pre>
<h3 id="224-可迭代的对象与迭代器的对比"><a class="header" href="#224-可迭代的对象与迭代器的对比">2.2.4 可迭代的对象与迭代器的对比</a></h3>
<p>Python 从可迭代对象中获取迭代器。</p>
<p>for 会先调用<code>iter()</code>方法将字符串转换成迭代器。然后进行迭代。</p>
<p>如果不使用 for 循环，则使用 while 来模拟：</p>
<pre><code class="language-python">it = iter(&quot;123&quot;)

while True:
    try:
        print(next(it))
    except StopIteration:
        del it
        break
</code></pre>
<blockquote>
<p><strong>总结：</strong></p>
</blockquote>
<ul>
<li>
<p>迭代器要实现<code>__next__()</code>方法，返回迭代器中的下一个元素</p>
</li>
<li>
<p>迭代器还要实现<code>__iter__()</code>方法，返回迭代器自身。==迭代器可以迭代，迭代器都是可迭代对象==</p>
</li>
<li>
<p>可迭代对象一定要实现<code>__iter__()</code>方法，返回一个迭代器，==但是不能返回自身！==</p>
<p>也不能实现<code>__next__()</code>方法</p>
</li>
</ul>
<h1 id="练习题"><a class="header" href="#练习题">练习题：</a></h1>
<h2 id="1截取"><a class="header" href="#1截取">1.截取</a></h2>
<pre><code class="language-python">import re

s = &quot;&quot;&quot;&lt;div class=&quot;WB_text W_f14&quot; node-type=&quot;feed_list_content&quot; nick-name=&quot;林俊杰&quot;&gt;飛機上偶遇的 J（JJ）F（Fish）J （Jimmy+Jolin）組合！&lt;br&gt;&lt;a
        target=&quot;_blank&quot; render=&quot;ext&quot; extra-data=&quot;type=atname&quot;
        href=&quot;//weibo.com/n/%E6%A2%81%E9%9D%99%E8%8C%B9?from=feed&amp;loc=at&quot; usercard=&quot;name=梁静茹&quot;&gt;@梁静茹&lt;/a&gt; &lt;a
        target=&quot;_blank&quot; render=&quot;ext&quot; extra-data=&quot;type=atname&quot;
        href=&quot;//weibo.com/n/%E8%94%A1%E4%BE%9D%E6%9E%97?from=feed&amp;loc=at&quot; usercard=&quot;name=蔡依林&quot;&gt;@蔡依林&lt;/a&gt; &lt;a
        target=&quot;_blank&quot; render=&quot;ext&quot; extra-data=&quot;type=atname&quot;
        href=&quot;//weibo.com/n/%E5%A4%A2%E6%83%B3%E5%AE%B6%E6%9E%97%E5%BF%97%E7%A9%8E?from=feed&amp;loc=at&quot;
        usercard=&quot;name=夢想家林志穎&quot;&gt;@夢想家林志穎&lt;/a&gt;&lt;br&gt; 祝大家2018新年快樂！
&lt;/div&gt;
&quot;&quot;&quot;

ret = re.sub(&quot;&lt;br&gt;.*&lt;br&gt;&quot;, &quot;  &quot;, s, flags=re.S)
ret = re.findall(r&quot;(?&lt;=&gt;)(.*?)&lt;&quot;, ret, flags=re.S)
print(ret)

out:
['飛機上偶遇的 J（JJ）F（Fish）J （Jimmy+Jolin）組合！   祝大家2018新年快樂！\n']
</code></pre>
<h2 id="2邮箱验证"><a class="header" href="#2邮箱验证">2.邮箱验证</a></h2>
<p>5-20 位单词字符</p>
<p>@</p>
<p>域名</p>
<p>.com</p>
<pre><code class="language-python">import re

s = &quot;185699189@qq.com&quot;

ret = re.match(r&quot;^(\w{5,20})@(\w+.com)$&quot;, s)
print(ret.group(1))
print(ret.group(2))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1生成器"><a class="header" href="#1生成器">1.生成器</a></h1>
<p>使用<code>生成器</code>在迭代过程中，计算下一个值</p>
<p><code>生成器</code>是一个特殊的<code>迭代器</code>，每个数据是被计算出来再返回的</p>
<h2 id="11-简单生成器"><a class="header" href="#11-简单生成器">1.1 简单生成器</a></h2>
<p><code>生成器</code>是依靠 yield 关键字实现的</p>
<pre><code class="language-python"># 生成num个数字的斐波那契数列
def func(num):
    a = 0
    b = 1
    n = 0
    print(&quot;外&quot;)
    while n &lt; num:
        print(&quot;内yield前&quot;)
        yield
        n += 1
        # 这样赋值不会影响，会同时计算
        a, b = b, a+b
        print(a)
        print(&quot;内yield后&quot;)

g = func(10)
next(g)
next(g)
next(g)

out:
外
内yield前
1
内yield后
内yield前
1
内yield后
内yield前
</code></pre>
<p>yield 关键字会让代码停止在那一块。以此实现生成器。</p>
<p>生成器是迭代器，不是可迭代对象，所以要用<code>next()</code>方法调用</p>
<p><strong>生成器执行顺序：</strong></p>
<pre><code class="language-python">def func():
    print(&quot;开始&quot;)
    yield
    print(&quot;中间&quot;)
    yield &quot;返回值&quot;
    print(&quot;最后&quot;)


g = func()  # 调用生成器函数生成生成器的时候，不会执行函数内部方法
next(g)    # 第一个next()是激活生成器的，也可以理解为执行代码，遇到第一个yield停止。
ret = next(g)    # 遇到下一个yield停止
print(ret)
next(g)    # 遇到下一个yield停止，没有抛出异常

out：
开始
中间
返回值
最后
Traceback (most recent call last):
  File &quot;D:/PyCharm Workspace/Python进阶/test.py&quot;, line 13, in &lt;module&gt;
    next(g)    # 遇到下一个yield停止，没有抛出异常
StopIteration
</code></pre>
<h2 id="12-生成器表达式"><a class="header" href="#12-生成器表达式">1.2 生成器表达式</a></h2>
<p>以最简单的语出创建一个生成器</p>
<p>类比列表表达式：</p>
<pre><code class="language-python">l = [i for i in range(1,6)]

print(l)

out:
[1, 2, 3, 4, 5]
</code></pre>
<p>生成器表达式就是把上述表达式的中括号换成小括号</p>
<pre><code class="language-python">g = (i for i in range(1,6))

print(g)

print(next(g))
print(next(g))
print(next(g))
print(next(g))
print(next(g))
print(next(g))

out：
&lt;generator object &lt;genexpr&gt; at 0x000001EDE230A408&gt;
1
2
3
4
5

Traceback (most recent call last):
  File &quot;D:/PyCharm Workspace/Python进阶/test.py&quot;, line 10, in &lt;module&gt;
    print(next(g))
StopIteration
</code></pre>
<p>生成器是为协程做准备的</p>
<h2 id="13-嵌套生成器"><a class="header" href="#13-嵌套生成器">1.3 嵌套生成器</a></h2>
<pre><code class="language-python"># 生成1-9的数字
g1 = (i for i in range(1, 10))

# 生成1-9的数字的平方
g2 = (i*i for i in g1)
print(next(g2))
print(next(g2))
print(next(g2))
print(next(g2))
print(next(g2))
print(next(g2))
print(next(g2))
print(next(g2))
print(next(g2))

out:
1
4
9
16
25
36
49
64
81
</code></pre>
<h2 id="14-增强生成器"><a class="header" href="#14-增强生成器">1.4 增强生成器</a></h2>
<h3 id="141-生成器的send方法"><a class="header" href="#141-生成器的send方法">1.4.1 生成器的<code>.send()</code>方法</a></h3>
<p><code>.send()</code>是生成器的方法，<code>next()</code>是 Python 内置的方法。</p>
<p>调用<code>.send()</code>方法，第一次激活的时候必须传入 None，常用<code>next()</code>激活，然后用<code>send()</code>传参</p>
<p>之后可以传入参数，在<code>yield</code>前面接受</p>
<pre><code class="language-python">def func():
    print(&quot;开始&quot;)
    num = yield &quot;激活返回值&quot;
    print(num)
    print(&quot;执行&quot;)
    yield &quot;返回值&quot;
    print(&quot;结束&quot;)


g = func()

try:
    # print(next(g))
    print(g.send(None))
    # 第二次调用生成器的时候，开始可以传入数据，传入到当前yield，在yield前面接受
    print(g.send(1))
    print(g.send(2))
except StopIteration:
    print(&quot;Stop&quot;)


out:
开始
激活返回值
1
执行
返回值
结束
Stop
</code></pre>
<h3 id="142-查看生成器的状态"><a class="header" href="#142-查看生成器的状态">1.4.2 查看生成器的状态</a></h3>
<p>使用<code>inspect</code>模块下的<code>getgeneratorstate</code>方法。</p>
<table><thead><tr><th>状态码</th><th>含义</th></tr></thead><tbody>
<tr><td>GEN_CREATED</td><td>等待开始执行</td></tr>
<tr><td>GEN_RUNNING</td><td>正在被解释器执行，等待遇到 yield（多线程才能观察到）</td></tr>
<tr><td>GEN_SUSPENDED</td><td>在 yield 处暂停</td></tr>
<tr><td>GEN_CLOSED</td><td>执行结束</td></tr>
</tbody></table>
<pre><code class="language-python">import inspect

def func():
    print(&quot;开始&quot;)
    num = yield &quot;激活返回值&quot;
    print(num)
    print(&quot;执行&quot;)
    yield &quot;返回值&quot;
    print(&quot;结束&quot;)


g = func()

try:
    # print(next(g))
    print(inspect.getgeneratorstate(g))
    print(g.send(None))
    print(inspect.getgeneratorstate(g))
    # 第二次调用生成器的时候，开始可以传入数据，传入到当前yield，在yield前面接受
    print(g.send(1))
    print(inspect.getgeneratorstate(g))
    print(g.send(2))
except StopIteration:
    print(&quot;Stop&quot;)

print(inspect.getgeneratorstate(g))


out:
GEN_CREATED
开始
激活返回值
GEN_SUSPENDED
1
执行
返回值
GEN_SUSPENDED
结束
Stop
GEN_CLOSED
</code></pre>
<h2 id="15-yield-from"><a class="header" href="#15-yield-from">1.5 yield from</a></h2>
<h3 id="151-进行简单迭代"><a class="header" href="#151-进行简单迭代">1.5.1 进行简单迭代</a></h3>
<p>yield from 可以迭代数据：</p>
<pre><code class="language-python"># 字符串
astr='ABC'
# 列表
alist=[1,2,3]
# 字典
adict={&quot;name&quot;:&quot;wangbm&quot;,&quot;age&quot;:18}
# 生成器
agen=(i for i in range(4,8))

# 方法1
l = []
for i in (astr,alist,adict,agen):
    for j in i:
        l.append(j)

print(l)

# 方法2
def func(astr,alist,adict,agen):
    for i in (astr, alist, adict, agen):
        for j in i:
            yield j

agen=(i for i in range(4,8)) #重置
g = func(astr,alist,adict,agen)
print(g)
print(list(g))

# 方法3
def func(astr,alist,adict,agen):
    for i in (astr, alist, adict, agen):
        yield from i

agen=(i for i in range(4,8)) #重置
g = func(astr,alist,adict,agen)
print(g)
print(list(g))

out:
['A', 'B', 'C', 1, 2, 3, 'name', 'age', 4, 5, 6, 7]
&lt;generator object func at 0x000001E48760A4F8&gt;
['A', 'B', 'C', 1, 2, 3, 'name', 'age', 4, 5, 6, 7]
&lt;generator object func at 0x000001E48760A480&gt;
['A', 'B', 'C', 1, 2, 3, 'name', 'age', 4, 5, 6, 7]
</code></pre>
<h3 id="152-进阶"><a class="header" href="#152-进阶">1.5.2 进阶</a></h3>
<p>求<code>send()</code>进来的所有数的平均值</p>
<p>首先实现功能：</p>
<pre><code class="language-python">def func():
    average = 0
    count = 0
    total = 0
    while True:
        number = yield average
        count += 1
        total += number
        average = total / count

g = func()
next(g)

print(g.send(10))
print(g.send(20))
print(g.send(30))

out:
10.0
15.0
20.0
</code></pre>
<p>yield from 可以理解为一个管道</p>
<p>用来连接调用和委托生成器，可以帮助捕获异常</p>
<pre><code class="language-python">def func():
    average = 0
    count = 0
    total = 0
    while True:
        number = yield average
        count += 1
        total += number
        average = total / count
        if average &gt; 20:
            break
    return average,count,total

# 委托给func2生成器
def func2():
    while True:
        ret = yield from func()
        print(&quot;func2  1111&quot;)
        print(ret)

g = func2()
next(g)

print(g.send(10))
print(g.send(20))
print(g.send(30))
print(g.send(40))
print(g.send(50))


out:
10.0
15.0
20.0
func2  1111
(25.0, 4, 100)
0
func2  1111
(50.0, 1, 50)
0
</code></pre>
<h1 id="2魔法方法"><a class="header" href="#2魔法方法">2.魔法方法</a></h1>
<h2 id="21__getattribute__"><a class="header" href="#21__getattribute__">2.1<code>__getattribute__()</code></a></h2>
<p>实例对象属性查找顺序：</p>
<p><code>__getattribute__()</code>、实例对象、类、父类</p>
<p><code>__getattribute__()</code>可以拦截属性的查询</p>
<p>一般里面写<code>super().__getattribute__(item)</code></p>
<h2 id="22__getattr__"><a class="header" href="#22__getattr__">2.2<code>__getattr__()</code></a></h2>
<p>在上面的顺序中，最后调用的<code>__getattr__()</code>，如果没有会返回 None，防止报错（防止访问不存在的属性）</p>
<h2 id="23__setattr__"><a class="header" href="#23__setattr__">2.3<code>__setattr__()</code></a></h2>
<p>创建（实例化）一个新属性的时候调用</p>
<p>可以做一些处理。</p>
<h2 id="24__delattr__"><a class="header" href="#24__delattr__">2.4<code>__delattr__()</code></a></h2>
<p>删除实例对象的时候调用</p>
<p>调用父类 super 的或者直接使用<code>del self.__dict__[key]</code></p>
<h1 id="3描述符"><a class="header" href="#3描述符">3.描述符</a></h1>
<p>**描述符协议：**实现了<code>__get__()</code>、<code>__set__()</code>、<code>__delete__()</code>其中至少一个方法的类，就是一个描述符。</p>
<p>是用来描述实例属性的（限制）</p>
<p>以前可以使用 Property 属性来限制。</p>
<p>用法：</p>
<pre><code class="language-python">class Student:
    def __init__(self, name, math, chinese, english):
        self.name = name
        self.math = math
        self.chinese = chinese
        self.english = english

    @property
    def math(self):
        return self._math

    @math.setter
    def math(self, value):
        if 0 &lt;= value &lt;= 100:
            self._math = value
        else:
            raise ValueError(&quot;Valid value must be in [0, 100]&quot;)
</code></pre>
<h2 id="31-使用描述符进行属性限制"><a class="header" href="#31-使用描述符进行属性限制">3.1 使用描述符进行属性限制</a></h2>
<ul>
<li><code>__get__</code>：用于访问属性。它返回属性的值，若属性不存在、不合法等都可以抛出对应的异常。</li>
<li><code>__set__</code>：将在属性分配操作中调用。不会返回任何内容。</li>
<li><code>__delete__</code>：控制删除操作。不会返回内容。</li>
</ul>
<p>描述符是一个类，用描述符来进行类型判断（或范围判断）</p>
<pre><code class="language-python">class Type:
    def __init__(self, key, exceptionClass):
        self._key = key
        self._exceptionClass = exceptionClass

    def __set__(self, instance, value):
        print(&quot;set&quot;)
        if not isinstance(value, self._exceptionClass):
            raise TypeError('参数类型错误')
        self._value = value
        instance.__dict__[self._key] = value

    def __get__(self, instance, owner):
        print(&quot;get&quot;)
        return instance.__dict__[self._key]

    def __delete__(self, instance):
        print(&quot;delete&quot;)
        del instance.__dict__[self._key]


class Student:
    name = Type(&quot;name&quot;,str)
    math = Type(&quot;math&quot;,int)
    chinese = Type(&quot;math&quot;,float)
    english = Type(&quot;math&quot;,int)

    def __init__(self, name, math, chinese, english):
        self.name = name
        self.math = math
        self.chinese = chinese
        self.english = english

    def __repr__(self):
        return &quot;&lt;Student: {}, math:{}, chinese: {}, english:{}&gt;&quot;.format(self.name, self.math, self.chinese, self.english)


zs = Student(&quot;张三&quot;, 100, 100.0, 100)
print(zs)
print(zs.name)
print(zs.chinese)
# delattr(zs,&quot;chinese&quot;)
del zs.chinese
print(zs.chinese)
</code></pre>
<p>描述符里的方法的优先级都相当高。</p>
<p>除了 get 方法。</p>
<h2 id="32-构造自定义容器"><a class="header" href="#32-构造自定义容器">3.2 构造自定义容器</a></h2>
<p>需要存储数据，查询数据，修改数据，删除数据操作；</p>
<p>并且想实现创建类似于序列和映射的类，可以称之为容器。</p>
<p>可以通过重写魔法方法<code>__getitem__</code>、<code>__setitem__</code>、<code>__delitem__</code>、<code>__len__</code>来实现。</p>
<p>就是自定义一个数据结构的样子。</p>
<p>课堂作业：</p>
<ul>
<li>不会报错</li>
<li>容器最大存储量为 10</li>
<li>在存储数据到最大的时候会将最开始存储的数据删除掉，然后把新的数据存进去</li>
</ul>
<pre><code class="language-python">class C:
    def __init__(self):
        self.start = 0
        self.end = 0
        self.maxLen = 10
        self.dataList = []

    def __getitem__(self, item):
        try:
            return self.dataList[item]
        except Exception as e:
            print(e.__repr__())

    def __setitem__(self, key, value):
        try:
            if key &lt; 0 or key &gt; len(self.dataList):
                raise IndexError
            elif key &gt;= 0 and key &lt; len(self.dataList):
                self.dataList[key] = value
            elif len(self.dataList) &lt; self.maxLen:
                self.dataList.append(value)
            else:
                self.dataList = self.dataList[1:]
                self.dataList.append(value)
        except Exception as e:
            print(e.__repr__())

    def __delitem__(self, key):
        pass

    def __len__(self):
        return len(self.dataList)

    def __str__(self):
        return str(self.dataList)


c = C()
for i in range(10):
    c[i] = i
print(c)
c[10] = 10
print(c)
c[200] = 10
print(c[100])

out:
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
IndexError()
IndexError('list index out of range')
None
</code></pre>
<h1 id="4上下文管理"><a class="header" href="#4上下文管理">4.上下文管理</a></h1>
<p>帮助使用者完成一些代码</p>
<p>包括开始和结束的操作</p>
<p>使用者做执行的操作</p>
<p>一些常用的上下文管理的语句：</p>
<p>​ with …… as ……</p>
<p>结合起来就是上下文管理器</p>
<h2 id="41-自定义简单的上下文管理器"><a class="header" href="#41-自定义简单的上下文管理器">4.1 自定义简单的上下文管理器</a></h2>
<pre><code class="language-python">class Resources():
    def __enter__(self):
        print(&quot;进入&quot;)
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        print(&quot;离开&quot;)

    def operate(self):
        print('执行')


with Resources() as res:
    res.operate()
    res.operate()
    print(&quot;执行结束&quot;)

print(&quot;结束&quot;)

out:
进入
执行
执行
执行结束
离开
结束
</code></pre>
<h2 id="42-使用contextlib"><a class="header" href="#42-使用contextlib">4.2 使用<code>contextlib</code></a></h2>
<p>定义一个类比较麻烦，可以使用<code>contextlib</code>来代替简单的操作类，使用 yield 生成器来制作。</p>
<p>返回的对象在 yield 后面。</p>
<pre><code class="language-python">import contextlib

@contextlib.contextmanager
def open_file(filename,mode):
    print(&quot;上文管理&quot;)
    f = open(filename,mode)
    try:
        yield f
        print(&quot;下文管理&quot;)
    except Exception as e:
        print(e)
    finally:
        f.close()


with open_file(&quot;demo.txt&quot;,&quot;r&quot;) as f:
    text = f.read()
    print(text)

print(&quot;全部执行结束&quot;)

out:
上文管理
123,test
下文管理
全部执行结束
</code></pre>
<h1 id="5比较运算符"><a class="header" href="#5比较运算符">5.比较运算符</a></h1>
<p>如果需要进行&lt;=，&gt;=之类的比较，需要实现 eq、lt、le、gt、ge 中的 eq
加上另外任意一个即可。（需要借助<code>functools.total_ordering</code>）,如果不借助需要全部实现，这个会帮我们自动填装剩余的方法。</p>
<pre><code class="language-python">from functools import total_ordering


class House:
    def __init__(self, name, area):
        self.name = name
        self.area = area


r1 = House(&quot;room1&quot;, &quot;10000&quot;)
r2 = House(&quot;room2&quot;, &quot;1000&quot;)


@total_ordering
class House:
    def __init__(self):
        self.rooms = []

    def __str__(self):
        return str(self.rooms)

    def add_room(self, room):
        self.rooms.append(room)

    def get_area(self):
        area = sum([int(i.area) for i in self.rooms])
        return area

    # __eq__ + 四种比较重的其中一种
    def __eq__(self, other):
        return self.get_area() == other.get_area()

    def __le__(self, other):
        return self.get_area() &lt;= other.get_area()


h1 = House()
h1.add_room(r1)
h2 = House()
h2.add_room(r2)
print(h1 &lt;= h2)

out：
False
</code></pre>
<h1 id="6str-和-repr"><a class="header" href="#6str-和-repr">6.str 和 repr</a></h1>
<p>类里面会有<code>__str__==__repr__</code>，所以优先实现<code>repr</code>方法，调用<code>print</code>的时候，会优先调用<code>str</code>方法，如果没有就会调用<code>repr</code>，但是反之不会。</p>
<p><code>str</code>是给人看的，</p>
<p><code>repr</code>是给电脑看的，返回值一般是一段可以执行的代码</p>
<p>至少要实现一个<code>repr</code>来保证能<code>print</code></p>
<h1 id="7call-魔法方法"><a class="header" href="#7call-魔法方法">7.call 魔法方法</a></h1>
<p>让类的实例对象可以像函数一样去调用。</p>
<h1 id="8多继承"><a class="header" href="#8多继承">8.多继承</a></h1>
<p>继承的时候，从左到右写，顺序就是从左到右</p>
<p>在<code>__mro__</code>属性里面可以查看。</p>
<p>在使用 super（上一级）方法的时候，不过不写参数。就从上一级开始执行。但是自己类内部的代码一定会执行。</p>
<p>如果需要使用指定类的方法，那么就要这么写：</p>
<pre><code class="language-python">super(指定类的子类,self).需要调用的方法()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="线程和进程"><a class="header" href="#线程和进程">线程和进程</a></h1>
<h2 id="1threading-包"><a class="header" href="#1threading-包">1.Threading 包</a></h2>
<p><code>threading</code>封装了相当多的线程操作</p>
<ul>
<li>
<p><code>enumerate()</code>转为序列字典的时候会将所有线程打印出来，</p>
</li>
<li>
<p><code>start()</code>方法会让线程开始进行</p>
</li>
<li>
<p><code>join()</code>方法会进行阻塞</p>
</li>
</ul>
<pre><code class="language-python">import threading
import time


def func1():
    print(&quot;func1&quot;)
    time.sleep(1)


def func2():
    print(&quot;func2&quot;)
    time.sleep(1)


if __name__ == &quot;__main__&quot;:
    print(&quot;当前线程的信息&quot;, threading.enumerate())
    t1 = threading.Thread(target=func1)
    t2 = threading.Thread(target=func2)
    print(&quot;当前线程的信息&quot;, threading.enumerate())
    t1.start()
    t2.start()
    print(&quot;当前线程的信息&quot;, threading.enumerate())
    t1.join()
    t2.join()
    print(&quot;当前线程的信息&quot;, threading.enumerate())



out:
当前线程的信息 [&lt;_MainThread(MainThread, started 12236)&gt;]
当前线程的信息 [&lt;_MainThread(MainThread, started 12236)&gt;]
func1
func2
当前线程的信息[&lt;_MainThread(MainThread, started 12236)&gt;, &lt;Thread(Thread-1, started 14100)&gt;, &lt;Thread(Thread-2, started 2712)&gt;]
当前线程的信息 [&lt;_MainThread(MainThread, started 12236)&gt;]
</code></pre>
<p>线程是无序的：</p>
<pre><code class="language-python">import threading
import time


def func1():
    for i in range(10):
        print(&quot;func1&quot;)
        time.sleep(1)


def func2():
    for i in range(10):
        print(&quot;func2&quot;)
        time.sleep(1)


if __name__ == &quot;__main__&quot;:
    t1 = threading.Thread(target=func1)
    t2 = threading.Thread(target=func2)
    t1.start()
    t2.start()
</code></pre>
<p>输出会有部分内容，<code>func2</code>在<code>func1</code>前面</p>
<h2 id="2互斥锁"><a class="header" href="#2互斥锁">2.互斥锁</a></h2>
<p>对需要线程间共享的数据，使用锁来保证数据不被脏读、重复读之类的问题。</p>
<p>先看一下不加锁的问题所在：</p>
<pre><code class="language-python">import threading

num = 0


def func1():
    global num
    for i in range(1000000):
        num += 1
    print(&quot;func1处理结束：&quot;,num)


def func2():
    global num
    for i in range(1000000):
        num += 1
    print(&quot;func2处理结束：&quot;,num)


if __name__ == &quot;__main__&quot;:
    t1 = threading.Thread(target=func1)
    t2 = threading.Thread(target=func2)
    t1.start()
    t2.start()
    t1.join()
    t2.join()
    print(&quot;结束：&quot;, num)

out:
func1处理结束： 1002210
func2处理结束： 1175871
结束： 1175871
</code></pre>
<p>这里就发生了数据的重复读。</p>
<p>这里给资源加上锁就不会有这样的问题了。</p>
<p>先获取锁，然后加锁，然后解锁。就三步操作。</p>
<blockquote>
<p><strong>锁一定要在线程<code>start()</code>之前获取</strong></p>
</blockquote>
<pre><code class="language-python">import threading


num = 0


def func1():
    global num
    for i in range(100000):
        lock.acquire()
        num += 1
        lock.release()
    print(&quot;func1处理结束：&quot;,num)


def func2():
    global num
    for i in range(100000):
        lock.acquire()
        num += 1
        lock.release()
    print(&quot;func2处理结束：&quot;,num)


if __name__ == &quot;__main__&quot;:
    lock = threading.Lock()
    t1 = threading.Thread(target=func1)
    t2 = threading.Thread(target=func2)
    t1.start()
    t2.start()
    t1.join()
    t2.join()
    print(&quot;结束：&quot;, num)

out：
func1处理结束： 147648
func2处理结束： 200000
结束： 200000
</code></pre>
<p>对于读取同一个数据的线程，所有的线程都需要加锁。</p>
<blockquote>
<p><strong>锁会影响执行效率</strong></p>
</blockquote>
<h2 id="3死锁"><a class="header" href="#3死锁">3.死锁</a></h2>
<p>就是你给我笔我就把我的本子给你，</p>
<p>你说你给我本子我就把我的笔给你。</p>
<p>两个人都无法获取，都无法释放。</p>
<p>代码如下：</p>
<pre><code class="language-python">import threading
import time


class MyThread1(threading.Thread):
    def run(self):
        mutexA.acquire()
        print(self.name,&quot; --- do 1 up ------&quot;)
        time.sleep(1)
        mutexB.acquire()
        print(self.name,&quot; --- do 1 down ------&quot;)
        mutexB.release()
        mutexA.release()


class MyThread2(threading.Thread):
    def run(self):
        mutexB.acquire()
        print(self.name,&quot; --- do 2 up ------&quot;)
        time.sleep(1)
        mutexA.acquire()
        print(self.name,&quot; --- do 2 down ------&quot;)
        mutexA.release()
        mutexB.release()


if __name__ == '__main__':
    mutexA = threading.Lock()
    mutexB = threading.Lock()
    t1 = MyThread1()
    t2 = MyThread2()
    t1.start()
    t2.start()


out：
Thread-1  --- do 1 up ------
Thread-2  --- do 2 up ------
</code></pre>
<p>输出只有这两行。</p>
<p>因为两个线程都在等待对方释放锁，然后再自己释放锁。但是条件都不成立</p>
<p>产生了==死锁==。</p>
<h2 id="4gil-锁"><a class="header" href="#4gil-锁">4.GIL 锁</a></h2>
<p>多线程和多进程是不一样的。</p>
<p>多进程是真正的并行，而多线程是伪并行，实际上他只是交替执行。</p>
<p>是什么导致多线程，只能交替执行呢？是一个叫 GIL（Global Interpreter Lock ，全局解释器锁）的东西。</p>
<p>GIL 的概念：</p>
<blockquote>
<p>任何 Python 线程执行前，必须先获得 GIL 锁，然后，每执行 100 条字节码，解释器就自动释放 GIL 锁，让别的线程有机会执行。这个 GIL
全局锁实际上把所有线程的执行代码都给上了锁， 所以，多线程在 Python 中只能交替执行，即使 100 个线程跑在 100 核 CPU 上，也只能用到 1 个 核</p>
</blockquote>
<p>这个是 Python 的解释器 CPython 引入的概念。还有其他解释器。但是默认的认为 Python == CPython</p>
<p>默许了 Python 有 GIL 锁这个东西。</p>
<p>避免 GIL 锁的方法：</p>
<blockquote>
<ul>
<li>使用多进程代替</li>
<li>不使用 CPython</li>
</ul>
</blockquote>
<h2 id="5线程之间进行通信"><a class="header" href="#5线程之间进行通信">5.线程之间进行通信</a></h2>
<h3 id="51-队列"><a class="header" href="#51-队列">5.1 队列</a></h3>
<p><code>queue.Queue()</code>是实现的一个队列。</p>
<p><code>put</code>可以放入，<code>get</code>可以取，<code>qsize</code>可以获取长度</p>
<p>如果队列为空，则会一直阻塞，不会结束。</p>
<p>如果不想阻塞，可以给<code>get</code>添加<code>timeout</code>参数</p>
<p>会抛出异常</p>
<p>队列初始化的时候可以设置<code>maxsize</code>参数定义最大长度，限制<code>put</code>。</p>
<p>超出长度的时候一样是会阻塞，也可以添加 timeout 参数。</p>
<p>接下来实现经典的生产者消费者问题：</p>
<pre><code class="language-python">import random
import threading
import time
from queue import Queue

q = Queue()

def producer():
    # 生产骨头
    count = 0
    while True:
        count += 1
        s = &quot;骨头%s号&quot;%count
        print(&quot;生产了&quot;, s)
        q.put(s)
        time.sleep(random.random())


def dog():
    # 消费骨头
    num = 0
    while True:
        print(f&quot;小狗{num}吃掉了{q.get()}&quot;)
        time.sleep(random.random())
        num += 1


if __name__ == '__main__':
    t1 = threading.Thread(target=producer)
    t2 = threading.Thread(target=dog)
    t1.start()
    t2.start()
    t1.join()
    t2.join()

out:
生产了 骨头1号
小狗0吃掉了骨头1号
生产了 骨头2号
小狗1吃掉了骨头2号
生产了 骨头3号
小狗2吃掉了骨头3号
生产了 骨头4号
小狗3吃掉了骨头4号
生产了 骨头5号
小狗4吃掉了骨头5号
生产了 骨头6号
小狗5吃掉了骨头6号
生产了 骨头7号
小狗6吃掉了骨头7号
生产了 骨头8号
生产了 骨头9号
小狗7吃掉了骨头8号
生产了 骨头10号
生产了 骨头11号
小狗8吃掉了骨头9号
小狗9吃掉了骨头10号
小狗10吃掉了骨头11号
生产了 骨头12号
生产了 骨头13号
生产了 骨头14号
小狗11吃掉了骨头12号
生产了 骨头15号
生产了 骨头16号
小狗12吃掉了骨头13号
小狗13吃掉了骨头14号
生产了 骨头17号
生产了 骨头18号
生产了 骨头19号
小狗14吃掉了骨头15号
小狗15吃掉了骨头16号
生产了 骨头20号
</code></pre>
<p>可以看到有时候生产了好几个</p>
<p>有时候一次吃掉好几个</p>
<h3 id="52-线程池"><a class="header" href="#52-线程池">5.2 线程池</a></h3>
<p>在使用多线程处理任务时也不是线程越多越好，由于在切换线程的时候，需要切换上下文环境，依然会造成<code>cpu</code>的大量开销。为解决这个问题，线程池的概念被提出来了。预先创建好一个较为优化
的数量的线程，放到队列中，让过来的任务立刻能够使用，就形成了线程池。</p>
<p>创建线程池通过<code>concurrent.futures</code>库中的<code>ThreadPoolExecutor</code>实现的。</p>
<p><code>future</code>对象：在未来的某一时刻完成操作的对象。 <code>submit</code>方法可以返回一个<code>future</code>对象。</p>
<p>线程池就是，已创建的线程一直在（初始化的时候就创建了），任务来了就挑一个跑。</p>
<blockquote>
<p>是用来限制线程数量的</p>
</blockquote>
<p><code>submit</code>会把任务放入线程池中，返回 future 对象</p>
<p><code>done</code>会判断 future 是否执行完成</p>
<p><code>result</code>会获取阻塞主线程，直到获取返回值才结束阻塞。</p>
<pre><code class="language-python">import threading
from concurrent.futures import ThreadPoolExecutor
import time

# 制定最多运行N个线程
ex = ThreadPoolExecutor(max_workers=3)


def func(num):
    print(&quot;线程名：&quot;,threading.current_thread(),&quot;我的编号为&quot;,num)
    time.sleep(1)
    return &quot;我是返回值&quot;


# 返回future对象
f = ex.submit(func, 1)
print(f.done())
time.sleep(1.5)
print(f.done())
print(&quot;done结束&quot;)
print(f.result())
print(&quot;done结束，result结束&quot;)

out：
线程名： &lt;Thread(ThreadPoolExecutor-0_0, started daemon 12200)&gt; 我的编号为 1
False
True
done结束
我是返回值
done结束，result结束
</code></pre>
<p>限制的 max_workers，最多只有两个一起执行。可以一起放，但是上面的不结束下面的不执行</p>
<p><strong>使用 map 方法替换 submit 方法</strong></p>
<p>map 会将可迭代的对象进行迭代后传入方法汇总，在将方法放入池子内部</p>
<p>map 会返回一个生成器，在函数的任务结束后生成。返回值是严格按照传入的顺序返回的</p>
<p>生成器的值为 return 后的返回值。</p>
<pre><code class="language-python">import threading
from concurrent.futures import ThreadPoolExecutor
import time

# 制定最多运行N个线程
ex = ThreadPoolExecutor(max_workers=2)


def func(num):
    print(&quot;线程名：&quot;,threading.current_thread(),&quot;我的编号为&quot;,num)
    time.sleep(1)
    return num


ret = ex.map(func,[i for i in range(10)])

for i in ret :
    print(&quot;返回值是：&quot;,i)


out:
线程名： &lt;Thread(ThreadPoolExecutor-0_0, started daemon 3372)&gt; 我的编号为 0
线程名： &lt;Thread(ThreadPoolExecutor-0_1, started daemon 11292)&gt; 我的编号为 1
线程名：返回值是：  0
&lt;Thread(ThreadPoolExecutor-0_0, started daemon 3372)&gt; 我的编号为 2
线程名： &lt;Thread(ThreadPoolExecutor-0_1, started daemon 11292)&gt; 我的编号为 3
返回值是： 1
线程名： 返回值是： 2
&lt;Thread(ThreadPoolExecutor-0_0, started daemon 3372)&gt; 我的编号为 4
线程名：返回值是： 3
 &lt;Thread(ThreadPoolExecutor-0_1, started daemon 11292)&gt; 我的编号为 5
线程名：返回值是： 4
 &lt;Thread(ThreadPoolExecutor-0_0, started daemon 3372)&gt; 我的编号为 6
线程名：返回值是： 5
 &lt;Thread(ThreadPoolExecutor-0_1, started daemon 11292)&gt; 我的编号为 7
线程名： 线程名： &lt;Thread(ThreadPoolExecutor-0_0, started daemon 3372)&gt; 我的编号为返回值是： 6
返回值是： 7
&lt;Thread(ThreadPoolExecutor-0_1, started daemon 11292)&gt; 我的编号为 8
 9
返回值是： 8
返回值是： 9
</code></pre>
<p>使用<code>as_completed</code>这个函数是为<code>submit</code>而生的</p>
<p>你总想通过一种办法来解决<code>submit</code>后啥时候完成的吧 , 而不是一次次调用<code>future.done</code>或者使用<code>future.result</code>吧。
<code>concurrent.futures.as_completed(fs, timeout=None)</code> 返回一个生成器,在迭代过程中会阻塞。 直到线程完成或者异常时,产生一个<code>Future</code>对象。
同时注意, <code>map</code>方法返回是有序的, <code>as_completed</code>是那个哪个先完成/失败就返回。</p>
<p><code>wait</code> 是阻塞函数,第一个参数和<code>as_completed</code>一样, 一个可迭代的<code>future</code>序列,返回一个元组 ,包含 2 个<code>set</code> , 一个完成的，一个未完成的</p>
<p>最后说一下回调：<code>add_done_callback(fn)</code>，回调函数是在调用线程完成后再调用的，在同一个线程中.</p>
<h2 id="6进程间的通信"><a class="header" href="#6进程间的通信">6.进程间的通信</a></h2>
<h3 id="61-队列"><a class="header" href="#61-队列">6.1 队列</a></h3>
<p>主进程创建的子进程是无法获取主进程中的数据的。</p>
<p>进程间的资源是不共享的，无法使用之前的普通的队列 Queue 来实现。</p>
<p>要使用新的队列</p>
<pre><code class="language-python">import multiprocessing
q = multiprocessing.Queue()
</code></pre>
<p>放入：put</p>
<p>取出：get</p>
<blockquote>
<p>上述两个，如果手动指定方法的 block 参数为 False</p>
</blockquote>
<blockquote>
<p>那么，当之前需要阻塞的情况会立马抛出异常</p>
</blockquote>
<blockquote>
<p>1）如果 block 使用默认值，且没有设置 timeout（单位秒），消息列队如果为空，此时程序将被阻塞（停在读取状态），直到从消息列队读到消息为止，如果设置了 timeout，则会等待
timeout 秒， 若还没读取到任何消息，则抛出&quot;Queue.Empty&quot;异常； 2）如果 block 值为 False，消息列队如果为空，则会立刻抛出&quot;Queue.Empty&quot;异常；
Queue.get_nowait()：相当 Queue.get(False)； Queue.put(item,[block[,</p>
</blockquote>
<blockquote>
<blockquote>
<p>timeout]])：将 item 消息写入队列，block 默认值为 True； 1）如果 block 使用默认值，且没有设置 timeout（单位秒），消息列队如果已经没有空间可写入，
此时程序将被阻塞（停在写入状态），直到从消息列队腾出空间为止，如果设置了 timeout，则会 等待 timeout 秒，若还没空间，则抛出&quot;Queue.Full&quot;异常； 2）如果 block
值为 False，消息列队如果没有空间可写入，则会立刻抛出&quot;Queue.Full&quot;异常； Queue.put_nowait(item)：相当 Queue.put(item, False)；</p>
</blockquote>
</blockquote>
<p>判断是否为空：empty</p>
<p>判断是否满：full</p>
<p>数量：qsize</p>
<p><strong>例子：</strong></p>
<pre><code class="language-python">import multiprocessing
import random
import time

q = multiprocessing.Queue()


def producer(q):
    # 生产骨头
    count = 0
    while True:
        count += 1
        s = &quot;骨头%s号&quot;%count
        print(&quot;生产了&quot;, s)
        q.put(s)
        time.sleep(random.random())


def dog(q):
    # 消费骨头
    num = 0
    while True:
        print(f&quot;小狗{num}吃掉了{q.get()}&quot;)
        num += 1
        time.sleep(random.random())


if __name__ == '__main__':
    p1 = multiprocessing.Process(target=producer, args=(q,))
    p2 = multiprocessing.Process(target=dog,args=(q,))

    p1.start()
    p2.start()
    p1.join()
    p2.join()

out:
生产了 骨头1号
小狗0吃掉了骨头1号
生产了 骨头2号
小狗1吃掉了骨头2号
生产了 骨头3号
小狗2吃掉了骨头3号
生产了 骨头4号
小狗3吃掉了骨头4号
生产了 骨头5号
小狗4吃掉了骨头5号
生产了 骨头6号
小狗5吃掉了骨头6号
生产了 骨头7号
小狗6吃掉了骨头7号
生产了 骨头8号
小狗7吃掉了骨头8号
生产了 骨头9号
生产了 骨头10号
小狗8吃掉了骨头9号
生产了 骨头11号
</code></pre>
<p>==在进程间进行共享数据的时候，必须将数据作为参数传入进程中，不能使用全局变量。==</p>
<p>==这一点是和线程不同的==</p>
<h3 id="62-进程池"><a class="header" href="#62-进程池">6.2 进程池</a></h3>
<pre><code class="language-python">from concurrent.futures import ProcessPoolExecutor
import time


def func1():
    print(&quot;A&quot;)
    time.sleep(1)


def func2():
    print(&quot;B&quot;)
    time.sleep(1)


if __name__ == '__main__':
    p = ProcessPoolExecutor()
    f1 = p.submit(func1)
    f2 = p.submit(func2)
    print(f1)
    print(f2)
    p.shutdown()
    print(f1)
    print(f2)


out:
&lt;Future at 0x245a4dd5708 state=running&gt;
&lt;Future at 0x245a4e1c988 state=pending&gt;
A
B
&lt;Future at 0x245a4dd5708 state=finished returned NoneType&gt;
&lt;Future at 0x245a4e1c988 state=finished returned NoneType&gt;
</code></pre>
<blockquote>
<p><code>shutdown</code>方法会调用<code>join</code>和<code>close</code>，不用一个个执行</p>
</blockquote>
<blockquote>
<p><code>submit</code>方法一样是返回的一个<code>future</code>，获取返回值用<code>future.result()</code>方法来获取</p>
</blockquote>
<p><code>concurrent.futures</code>模块的基础是<code>Exectuor</code>，<code>Executor</code>是一个抽象类，它不能被直接使用。</p>
<p>但是它提供的两个子类<code>ThreadPoolExecutor</code>和<code>ProcessPoolExecutor</code>却是非常有用，顾名思义两者分别被用来创建线程池和进程池的代码。</p>
<p>我们可以将相应的<code>tasks</code>直接放入线程池/进程池，不需要维 护<code>Queue</code>来操心死锁的问题，线程池/进程池会自动帮我们调度。</p>
<p><code>Future</code>这个概念，你可以把它理解为一个在未来完成的操作，这是异步编程的基础，传统编程模式下比如我们操作<code>queue.get</code>的时候，在等待返回结果之前会产生阻塞，<code>cpu</code>不能让出来做其他事情，而<code>Future</code>的引入帮助我们在等待的这段时间可以完成其他的操作。</p>
<p><code>Executor</code>中定义了 <code>submit()</code> 方法，这个方法的作用是提交一个可执行的回调<code>task</code> ，并返回一个<code>future</code>实例。</p>
<p><code>future</code>对象代表的就是给定的调用。 <code>submit()</code> 方法实现进程池/线程池</p>
<blockquote>
<p><code>p.submit(task,i)</code>默认为异步执行， <code>p.submit(task,i).result()</code>即同步执行</p>
</blockquote>
<p><strong>进程池之间的的通信</strong></p>
<pre><code class="language-python">import multiprocessing
from concurrent.futures import ProcessPoolExecutor
import random
import time


def producer(q):
    # 生产骨头
    count = 0
    while True:
        count += 1
        s = &quot;骨头%s号&quot; % count
        print(&quot;生产了&quot;, s)
        q.put(s)
        time.sleep(random.random())


def dog(q):
    # 消费骨头
    num = 0
    while True:
        print(f&quot;小狗{num}吃掉了{q.get()}&quot;)
        num += 1
        time.sleep(random.random())


if __name__ == '__main__':
    # 进程池之间的通信不能使用下面这个Queue
    # q = multiprocessing.Queue()
    # 要使用这个队列
    q = multiprocessing.Manager().Queue()
    p = ProcessPoolExecutor()
    p1 = p.submit(producer, q)
    p2 = p.submit(dog, q)
    p.shutdown()


out:
生产了 骨头1号
小狗0吃掉了骨头1号
生产了 骨头2号
小狗1吃掉了骨头2号
生产了 骨头3号
小狗2吃掉了骨头3号
生产了 骨头4号
小狗3吃掉了骨头4号
生产了 骨头5号
生产了 骨头6号
小狗4吃掉了骨头5号
生产了 骨头7号
小狗5吃掉了骨头6号
生产了 骨头8号
生产了 骨头9号
小狗6吃掉了骨头7号
</code></pre>
<p><code>multiprocessing.Manager().Queue()</code>，进程池之间的通信必须使用这个队列。</p>
<h2 id="7协程"><a class="header" href="#7协程">7.协程</a></h2>
<p>协程不会出现资源互抢的问题</p>
<p>协程实际上就是线程内部多个函数的不停切换执行（避免耗时操作）</p>
<p>协程是依赖生成器的</p>
<p>生成器可以暂停函数，同时切换到其他函数去执行</p>
<p>关键字<code>yield</code></p>
<p>之前的生成器是为了产生数据使用的（惰性查询，惰性生成数据）</p>
<p>生成器是为了接受数据存在的，那么它就变成了协程</p>
<p>协程中最重要的是<code>send</code>方法，用来传输数据</p>
<h3 id="71-实现简单的协程"><a class="header" href="#71-实现简单的协程">7.1 实现简单的协程</a></h3>
<pre><code class="language-python">import time

def func1():
    print(&quot;A&quot;)
    yield
    time.sleep(1)

def func2():
    print(&quot;B&quot;)
    yield
    time.sleep(1)

# 产生生成器
g1 = func1()
g2 = func2()

next(g1)
next(g2)
next(g1)

out：

A
B
Traceback (most recent call last):
  File &quot;D:/PyCharm Workspace/Python进阶/test.py&quot;, line 19, in &lt;module&gt;
    next(g1)
StopIteration
</code></pre>
<p>A 和 B 同时打印，然后报错。这个不是协程，是生成器，因为没有接受数据。</p>
<p>那么给生成器加一个装饰器，在调用的时候预激活就行了。</p>
<p>预激活必须使用<code>send(None)</code>或<code>next()</code></p>
<h3 id="72-结合装饰器"><a class="header" href="#72-结合装饰器">7.2 结合装饰器</a></h3>
<pre><code class="language-python">import time
from functools import wraps

def coroutine(func):
    @wraps(func)
    def primer(*args,**kwargs):
        gen = func(*args,**kwargs)
        next(gen)
        return gen
    return primer


@coroutine
def func1():
    print(&quot;A   1&quot;)
    yield
    time.sleep(1)
    print(&quot;A   2&quot;)
    return &quot;A完毕&quot;

@coroutine
def func2():
    print(&quot;B   1&quot;)
    yield
    time.sleep(1)
    print(&quot;B   2&quot;)
    return &quot;B完毕&quot;


# 产生生成器
g1 = func1()
g2 = func2()

try:
    g1.send(None)
except StopIteration as e:
    print(e)

try:
    g2.send(None)
except StopIteration as e:
    print(e)

out：
A   1
B   1
A   2
A完毕
B   2
B完毕
</code></pre>
<p><code>submit</code>是默认异步执行，后面可以添加<code>.result()</code>来指定立即执行</p>
<h3 id="73-使用-greenlet"><a class="header" href="#73-使用-greenlet">7.3 使用 greenlet</a></h3>
<p>​ 需要使用<code>switch()</code>手动切，</p>
<p>​ 缺点</p>
<ul>
<li>
<p>如果方法很多要切，那么就很麻烦。</p>
</li>
<li>
<p>没有时间并发</p>
</li>
</ul>
<h3 id="74-使用-gevent"><a class="header" href="#74-使用-gevent">7.4 使用 gevent</a></h3>
<p>基于<code>greenlet</code>封装。</p>
<p>里面有<code>gevent.sleep(1)</code>来休眠。不支持<code>time</code>模块。</p>
<p><code>join()</code>就执行了，但是所有都执行了，因为所有方法都在一个线程里。</p>
<p><code>spawn</code>会切换。</p>
<p>尽量不用<code>join</code>，用<code>gevent.joinall([gevent.spawn(func1),……])</code></p>
<p>会一直阻塞，除非所有的全跑完。</p>
<p>为了支持<code>time</code></p>
<p>要<code>from gevent import monkey</code></p>
<p><code>monkey.patch_all()</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1偏函数"><a class="header" href="#1偏函数">1.偏函数</a></h1>
<p>可以指定函数的参数值为固定的数字</p>
<p>解除了数量的限制</p>
<pre><code class="language-python">from functiontools import partial

func2 = partial(func , c = 1)
</code></pre>
<p>不指定 key，就是按位置传。</p>
<p>按关键字传，然后调用的时候也要按关键字传。</p>
<h1 id="2新协程"><a class="header" href="#2新协程">2.新协程</a></h1>
<p><code>async</code>和<code>await</code>关键字。</p>
<p>使用<code>async</code>修饰方法，</p>
<p><code>await</code>后面切</p>
<p>进入第二个协程对象。</p>
<p>使用<code>send</code>调用。</p>
<p>还需要手动捕获异常</p>
<p>一般结合时间循环队列使用。</p>
<p>使用 asyncio 的 get_event_loop()</p>
<p>task = loop.create_task(g2)</p>
<p>添加回调函数</p>
<p>task.add_done_callback(func3)</p>
<p>loop.run_until_complete(task)</p>
<p>实现并发：</p>
<p>asyncio 的 map 方法</p>
<h1 id="3socket编程"><a class="header" href="#3socket编程">3.<code>Socket</code>编程</a></h1>
<h2 id="31udp发送数据"><a class="header" href="#31udp发送数据">3.1<code>UDP</code>发送数据</a></h2>
<p>例子</p>
<pre><code class="language-python">import socket

udp_socket = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)

data = &quot;你好&quot;.encode()

add = (&quot;192.168.1.1&quot;,8080)

udp_socket.sendto(data,add)

udp_socket.close()
</code></pre>
<h2 id="32udp接受数据"><a class="header" href="#32udp接受数据">3.2<code>UDP</code>接受数据</a></h2>
<pre><code class="language-python">import socket

udp_socket = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)

data = &quot;你好&quot;.encode()

add = (&quot;10.25.208.79&quot;,8080)

udp_socket.sendto(data,add)

print(&quot;等待接受数据&quot;)

data = udp_socket.recvfrom(1024) # 缓存大小，即一次可以接受最大的数据量
print(&quot;响应：&quot;, data)

udp_socket.close()
</code></pre>
<p><code>recvfrom</code>返回一个元组</p>
<ul>
<li>第一个是返回的数据</li>
<li>第二个是对方的<code>IP</code>地址和<code>端口</code></li>
</ul>
<p><code>b</code>表示二进制编码。需要<code>decode()</code>解码。</p>
<p>也可以指定绑定端口：</p>
<pre><code class="language-python">add = (&quot;10.25.208.79&quot;, 8888)

udp_socket.bind(add)
</code></pre>
<p>但是 UDP 不关心接受方是否接受。只关心是否发送出去。</p>
<h2 id="33tcp基础操作"><a class="header" href="#33tcp基础操作">3.3<code>TCP</code>基础操作</a></h2>
<p>主 socket 监听新来的连接，子 socket 来负责连接传输数据。</p>
<p><strong>简单实现 TCP 客户端：</strong></p>
<pre><code class="language-python">import socket

# socket.SOCK_STREAM是用来创建TCp的
tcp_client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

add = (&quot;10.25.208.65&quot;, 8080)

tcp_client_socket.connect(add)

tcp_client_socket.send(&quot;喝喝&quot;.encode())

print(&quot;发送完成，等待接受&quot;)

while True:
    ret = tcp_client_socket.recv(1024)

    print(ret.decode(&quot;gbk&quot;))

tcp_client_socket.close()
</code></pre>
<p><strong>简单 TCP 服务器：</strong></p>
<ol>
<li>创建 socket</li>
<li>绑定 IP 和端口</li>
<li>开启监听</li>
<li>创建连接的 socket</li>
<li>进行服务</li>
<li>关闭新的 socket</li>
<li>关闭总 socket</li>
</ol>
<pre><code class="language-python">import socket

# socket.SOCK_STREAM是用来创建TCp的
tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

add = (&quot;10.25.208.65&quot;, 5555)
tcp_server_socket.bind(add)

# 指定最大连接
print(&quot;开启监听&quot;)
tcp_server_socket.listen(5)

# 会返回一个元组
# 第一个元素就是新socket，用来和客户端进行数据传输的
# 第二个元素是客户端的地址信息
client_socket, add = tcp_server_socket.accept()
print(&quot;有客户端连接&quot;)
print(client_socket)
print(add)

# 发送数据
client_socket.send(&quot;开始服务&quot;.encode())
retData = client_socket.recv(1024)
print(&quot;接受数据：&quot;,retData.decode(&quot;gbk&quot;))

tcp_server_socket.close()
</code></pre>
<p><strong>完善版本的 TCP 服务器：</strong></p>
<pre><code class="language-python">import socket

# socket.SOCK_STREAM是用来创建TCp的
tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

add = (&quot;10.25.208.65&quot;, 5555)
tcp_server_socket.bind(add)

# 指定最大连接
print(&quot;开启监听&quot;)
tcp_server_socket.listen(5)

# 会返回一个元组
# 第一个元素就是新socket，用来和客户端进行数据传输的
# 第二个元素是客户端的地址信息
try:
    while True:
        client_socket, add = tcp_server_socket.accept()
        print(&quot;有客户端连接&quot;)
        print(client_socket)
        print(add)

        # 发送数据
        client_socket.send(&quot;开始服务&quot;.encode())
        try:
            while True:
                retData = client_socket.recv(1024)
                if retData:
                    print(&quot;接受数据：&quot;, retData.decode(&quot;gbk&quot;))
                else:
                    raise Exception(&quot;连接已关闭&quot;)
        except Exception as e:
            print(&quot;内部报错：&quot;, e)
        finally:
            client_socket.close()
except Exception as e:
    print(e)
finally:
    tcp_server_socket.close()
</code></pre>
<p>首次循环是为了服务多个客户端</p>
<p>第二次循环是为了单个客户端的多次发送消息</p>
<p><strong>多进程版本</strong></p>
<pre><code class="language-python">import multiprocessing
import socket


def client_server(client_socket, add):
    print(&quot;有客户端连接&quot;)
    print(client_socket)
    print(add)

    # 发送数据
    client_socket.send(&quot;开始服务&quot;.encode())

    try:
        while True:
            retData = client_socket.recv(1024)
            if retData:
                print(&quot;接受数据：&quot;, retData.decode(&quot;gbk&quot;))
            else:
                raise Exception(&quot;连接已关闭&quot;)
    except Exception as e:
        print(&quot;内部报错：&quot;, e)
    finally:
        client_socket.close()


if __name__ == '__main__':
    # socket.SOCK_STREAM是用来创建TCp的
    tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    add = (&quot;10.25.208.65&quot;, 5555)
    tcp_server_socket.bind(add)

    # 指定最大连接
    print(&quot;开启监听&quot;)
    tcp_server_socket.listen(5)

    # 会返回一个元组
    # 第一个元素就是新socket，用来和客户端进行数据传输的
    # 第二个元素是客户端的地址信息
    try:
        while True:
            client_socket, add = tcp_server_socket.accept()

            p = multiprocessing.Process(target=client_server,args=(client_socket,add))

            p.start()

    except Exception as e:
        print(e)
    finally:
        tcp_server_socket.close()
</code></pre>
<p><strong>多线程版本</strong></p>
<pre><code class="language-python">import threading
import socket


def client_server(client_socket, add):
    print(&quot;有客户端连接&quot;)
    print(client_socket)
    print(add)

    # 发送数据
    client_socket.send(&quot;开始服务&quot;.encode())

    try:
        while True:
            retData = client_socket.recv(1024)
            if retData:
                print(&quot;接受数据：&quot;, retData.decode(&quot;gbk&quot;))
            else:
                raise Exception(&quot;连接已关闭&quot;)
    except Exception as e:
        print(add, e)
    finally:
        client_socket.close()


if __name__ == '__main__':
    # socket.SOCK_STREAM是用来创建TCp的
    tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    add = (&quot;10.25.208.65&quot;, 5555)
    tcp_server_socket.bind(add)

    # 指定最大连接
    print(&quot;开启监听&quot;)
    tcp_server_socket.listen(5)

    # 会返回一个元组
    # 第一个元素就是新socket，用来和客户端进行数据传输的
    # 第二个元素是客户端的地址信息
    try:
        while True:
            client_socket, add = tcp_server_socket.accept()

            t = threading.Thread(target=client_server,args=(client_socket,add))

            t.start()

    except Exception as e:
        print(e)
    finally:
        tcp_server_socket.close()
</code></pre>
<p><strong>协程版本</strong></p>
<pre><code class="language-python"># import threading
import socket
import gevent
from gevent import monkey


def client_server(client_socket, add):
    print(&quot;有客户端连接&quot;)
    print(client_socket)
    print(add)

    # 发送数据
    client_socket.send(&quot;开始服务&quot;.encode())
    gevent.sleep(1)
    try:
        while True:
            retData = client_socket.recv(1024)
            if retData:
                print(&quot;接受数据：&quot;, retData.decode(&quot;gbk&quot;))
            else:
                raise Exception(&quot;连接已关闭&quot;)
    except Exception as e:
        print(add, e)
    finally:
        client_socket.close()


if __name__ == '__main__':

    monkey.patch_all()

    # socket.SOCK_STREAM是用来创建TCP的
    tcp_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    add = (&quot;10.25.208.65&quot;, 5555)
    tcp_server_socket.bind(add)

    # 指定最大连接
    print(&quot;开启监听&quot;)
    tcp_server_socket.listen(5)

    # 会返回一个元组
    # 第一个元素就是新socket，用来和客户端进行数据传输的
    # 第二个元素是客户端的地址信息
    try:
        while True:
            client_socket, add = tcp_server_socket.accept()

            gevent.spawn(client_server,client_socket, add)

    except Exception as e:
        print(e)
    finally:
        tcp_server_socket.close()
</code></pre>
<h2 id="34tcp详解"><a class="header" href="#34tcp详解">3.4<code>TCP</code>详解</a></h2>
<h3 id="341-三次握手"><a class="header" href="#341-三次握手">3.4.1 三次握手</a></h3>
<ol>
<li>
<p>客户端：喂，你听得到么？</p>
</li>
<li>
<p>服务端：① 嗯，我听得到你说话。② 你听得到我说话么</p>
</li>
<li>
<p>客户端：嗯，我也听得到。</p>
<p>开始聊天</p>
</li>
</ol>
<img src="https://img-blog.csdn.net/20180717202520531?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTUwMzE2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"/>
<ul>
<li>
<p>第一次握手：建立连接时，客户端发送 syn 包（syn=j）到服务器，并进入 SYN_SENT 状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence
Numbers）。</p>
</li>
<li>
<p>第二次握手：服务器收到 syn 包，必须确认客户的 SYN（ack=j+1），同时自己也发送一个 SYN 包（syn=k），即 SYN+ACK 包，此时服务器进入 SYN_RECV
状态；==其实可以理解为是两次发送数据，第一次确认，第二次自己也发送类似第一次握手的消息。但是，实际上只有一个数据包==</p>
</li>
<li>
<p>第三次握手：客户端收到服务器的 SYN+ACK 包，向服务器发送确认包 ACK(ack=k+1），此包发送完毕，客户端和服务器进入 ESTABLISHED（TCP 连接成功）状态，完成三次握手。</p>
</li>
</ul>
<h3 id="342-四次挥手"><a class="header" href="#342-四次挥手">3.4.2 四次挥手</a></h3>
<ol>
<li>
<p>客户端：我要关闭连接了，然后客户端进入半关闭状态。</p>
</li>
<li>
<p>服务端：好的，我知道了。</p>
</li>
<li>
<p>服务端：我也要关闭连接了，然后服务器进入半关闭状态。</p>
</li>
<li>
<p>客户端：好的，我知道了。</p>
</li>
</ol>
<img src="https://images2015.cnblogs.com/blog/606573/201703/606573-20170317191417963-1010313216.png"/>
<p>先由客户端向服务器端发送一个 FIN，请求关闭数据传输。</p>
<p>当服务器接收到客户端的 FIN 时，向客户端发送一个 ACK，其中 ack 的值等于 FIN+SEQ</p>
<p>然后服务器向客户端发送一个 FIN，告诉客户端应用程序关闭。</p>
<p>当客户端收到服务器端的 FIN 是，回复一个 ACK 给服务器端。其中 ack 的值等于 FIN+SEQ</p>
<p><strong>为什么要 4 次挥手？</strong></p>
<p>确保数据能够完整传输。</p>
<p>当被动方收到主动方的 FIN 报文通知时，它仅仅表示主动方没有数据再发送给被动方了。</p>
<p>但未必被动方所有的数据都完整的发送给了主动方，所以被动方不会马上关闭 SOCKET,它可能还需要发送一些数据给主动方后，</p>
<p>再发送 FIN 报文给主动方，告诉主动方同意关闭连接，所以这里的 ACK 报文和 FIN 报文多数情况下都是分开发送的。</p>
<h1 id="4元类"><a class="header" href="#4元类">4.元类</a></h1>
<p>所有可以实例化对象的类，打印 type 都是元类</p>
<p>所有不可以实例化对象的东西，打印 type 都是父级类</p>
<pre><code class="language-python">num = int()
print(type(int))
print(num)
print(type(num))

out：
&lt;class 'type'&gt;
0
&lt;class 'int'&gt;
</code></pre>
<h2 id="41-元类的使用"><a class="header" href="#41-元类的使用">4.1 元类的使用</a></h2>
<h3 id="411-定义类"><a class="header" href="#411-定义类">4.1.1 定义类：</a></h3>
<p><code>type(类名，由父类名称组成的元组(针对继承的情况，可以为空)，属性字典)</code></p>
<pre><code class="language-python">Dog = type(&quot;Dog&quot;,(),{})
dog = Dog()
print(type(Dog))
print(type(dog))

out:
&lt;class 'type'&gt;
&lt;class '__main__.Dog'&gt;
</code></pre>
<p>属性填入后，是在类属性中。</p>
<p>不是实例属性。</p>
<h3 id="412-创建带方法的类"><a class="header" href="#412-创建带方法的类">4.1.2 创建带方法的类</a></h3>
<p>方法也是属性，类型是 Function 的。</p>
<p>直接在属性字典中添加就可以了。</p>
<pre><code class="language-python">def eat(self):
    print(&quot;小狗在吃&quot;)


Dog = type(&quot;Dog&quot;,(),{&quot;eat&quot;:eat})

dog = Dog()

dog.eat()

out:
小狗在吃
</code></pre>
<blockquote>
<p>注意，定义方法的时候，第一个参数必须为<code>self</code></p>
</blockquote>
<p>创建带实例属性的类，就是把<code>init</code>方法传</p>
<h3 id="413metaclass属性"><a class="header" href="#413metaclass属性">4.1.3<code>metaclass</code>属性</a></h3>
<p>元类可以拦截类的创建过程，修改类创建的时候的一些内容。</p>
<p>例子：</p>
<p>创建类的时候将所有属性名都换成大写的。</p>
<pre><code class="language-python">def upper_attr_name(class_name,class_parents_name,class_attr):

    # 一些在创建类之前的操作
    print(class_attr)
    newAttr = {}
    for name, value in class_attr.items():
        if not name.startswith(&quot;__&quot;):
            newAttr[name.upper()] = value

    return type(class_name,class_parents_name,newAttr)


class A(object,metaclass=upper_attr_name):
    name = &quot;Hello A&quot;


# class B(object):
#     name = &quot;Hello B&quot;
#     # python2 中这么写
#     __metaclass__ = upper_attr_name


# print(A.name)
print(A.NAME)


out:
{'__module__': '__main__', '__qualname__': 'A', 'name': 'Hello A'}
Hello A
</code></pre>
<h1 id="5垃圾回收"><a class="header" href="#5垃圾回收">5.垃圾回收</a></h1>
<h2 id="51-引用计数"><a class="header" href="#51-引用计数">5.1 引用计数</a></h2>
<p>对象被引用的时候引用计数+1，引用取消的时候计数-1，计数为 0 的时候会释放内存。</p>
<h2 id="52-垃圾回收"><a class="header" href="#52-垃圾回收">5.2 垃圾回收</a></h2>
<p>内存超过一定值的时候会进行垃圾回收，保持良好的内存使用。</p>
<h3 id="521-环形结构"><a class="header" href="#521-环形结构">5.2.1 环形结构</a></h3>
<p>环形结构永远不会被外部变量引用。</p>
<p>那么这两个变量就是垃圾</p>
<p>可以手动<code>gc.collect()</code>启动垃圾回收</p>
<h3 id="522-分代回收"><a class="header" href="#522-分代回收">5.2.2 分代回收</a></h3>
<p>按某些规定扫描垃圾之后还存活的对象，会放入一代目。</p>
<p>下次扫描的时候不会扫描这些一代目的对象。</p>
<p>在某些次数过后，扫描一遍一代目。</p>
<p>还存活的放入二代目。</p>
<p>新建的都是零代目。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1-关于-python-的变量的默认值"><a class="header" href="#1-关于-python-的变量的默认值">1. 关于 Python 的变量的默认值</a></h1>
<p>运行以下代码，会有惊喜！</p>
<pre><code class="language-python">def func(x,l=[]):
    for i in range(x):
        l.append(i*i)
    print(l)

func(2)
func(3,[3,2,1])
func(3)
</code></pre>
<p>这段代码会输出：</p>
<pre><code class="language-out">[0, 1]
[3, 2, 1, 0, 1, 4]
[0, 1, 0, 1, 4]
</code></pre>
<p>惊不惊喜，意不意外。 这是因为</p>
<ul>
<li>Python 中，参数的默认值，也相当于变量一样，指向内存中的唯一的地址，除非你传进来了一个参数，改变这个参数的指向。</li>
<li>如果你在程序的运行过程中（使用了默认变量），修改了这个变量的值（可变），那么恭喜你，你的默认参数已经变了！</li>
</ul>
<h1 id="2-一行代码实现-1--100-的和"><a class="header" href="#2-一行代码实现-1--100-的和">2. 一行代码实现 1--100 的和</a></h1>
<p>简单点我们就用：</p>
<pre><code class="language-python">sum(range(1,101))
</code></pre>
<p>这里主要要记住的就是 range 是返回一个==迭代器==，==左闭右开==。</p>
<blockquote>
<p>python2.x 的 range 是返回的数组，</p>
</blockquote>
<blockquote>
<p>python3.x 的 range 是返回迭代器。</p>
</blockquote>
<p>尝试运行：</p>
<pre><code class="language-python">print(sum(range(1, 101)))

# 只是摆在这里告诉你这是最高效（NB）的写法。没任何毛病。不要死脑筋
print(&quot;5050&quot;)

print(range(1, 10))
print(list(range(1, 10)))
</code></pre>
<blockquote>
<p>out:</p>
</blockquote>
<blockquote>
<p>5050 5050 range(1, 10) [1, 2, 3, 4, 5, 6, 7, 8, 9]</p>
</blockquote>
<p>那为什么会这样呢？其实在 Python3 中
range()函数返回的对象很像一个列表，但是它确实不是一个列表，它只是在迭代的情况下返回指定索引的值，它并不会在内存中产生一个列表对象，官方解释说这样做是为了节约内存空间。通常我们称这种对象是可迭代的，或者是可迭代对象。</p>
<p>这里就要引入另外一个叫迭代器的概念，迭代器可以从一个可迭代对象中连续获取指定索引的值，直到索引结束。比如 list()函数，所以在上面的例子中，我们可以用 list()这个迭代器将
range()函数返回的对象变成一个列表。</p>
<p>由此可以看出：range()函数返回的是一个可迭代对象（类型是对象），而不是列表类型；list() 函数是对象迭代器，把对象转为一个列表，返回的变量类型为列表。</p>
<h1 id="3-如何在一个函数内部修改全局变量"><a class="header" href="#3-如何在一个函数内部修改全局变量">3. 如何在一个函数内部修改全局变量</a></h1>
<p>在函数内部使用 global 声明，修改全局变量，作用域的知识点。</p>
<pre><code class="language-python">a = 5
b = 4


def fn():
    # 在需要修改全局变量的时候，在前面加上global修饰
    global a
    print(&quot;Global a: &quot;, a)
    print(&quot;Global b: &quot;, b)
    a = 4
    # 此路不通，IDE都会告诉你不能执行
    # 全局变量在不声明global的时候不能修改，但是能读取
    # b = 5
    print(&quot;Global a: &quot;, a)


print(&quot;Global a: &quot;, a)
fn()
print(&quot;Global a: &quot;, a)
</code></pre>
<blockquote>
<p>out:</p>
</blockquote>
<blockquote>
<p>Global a: 5 Global a: 5 Global b: 4 Global a: 4 Global a: 4</p>
</blockquote>
<h1 id="4-python-的几个标准库"><a class="header" href="#4-python-的几个标准库">4. Python 的几个标准库</a></h1>
<table><thead><tr><th>库名</th><th>作用</th></tr></thead><tbody>
<tr><td>os</td><td>提供了不少与操作系统相关联的函数</td></tr>
<tr><td>sys</td><td>通常用于命令行参数</td></tr>
<tr><td>re</td><td>正则匹配</td></tr>
<tr><td>math</td><td>数学运算</td></tr>
<tr><td>datetime</td><td>处理日期时间</td></tr>
</tbody></table>
<h1 id="5-字典如何删除键和合并两个字典"><a class="header" href="#5-字典如何删除键和合并两个字典">5. 字典如何删除键和合并两个字典</a></h1>
<p>字典基操</p>
<pre><code class="language-python">dic = {&quot;name&quot;: &quot;zs&quot;, &quot;age&quot;: 18}

print(dic)

del dic[&quot;name&quot;]

print(dic)

dic2 = {&quot;name&quot;: &quot;ls&quot;}

dic.update(dic2)

print(dic)
</code></pre>
<ul>
<li>补充一下知识点，删除对象属性的时候调用<code>__delattr__()</code>或者<code>super.__delattr__()</code>或者直接使用<code>del self.__dict__[key]</code></li>
</ul>
<h1 id="6-关于-gil-锁"><a class="header" href="#6-关于-gil-锁">6. 关于 GIL 锁</a></h1>
<ul>
<li>
<p>一号解释：</p>
<p>GIL 是 python 的全局解释器锁，同一进程中假如有多个线程运行，一个线程在运行 python 程序的时候会霸占 python 解释器（加了一把锁即
GIL），使该进程内的其他线程无法运行，等该线程运行完后其他线程才能运行。如果线程运行过程中遇到耗时操作，则解释器锁解开，使其他线程运行。所以在多线程中，线程的运行仍是有先后顺序的，并不是同时进行。</p>
<p>多进程中因为每个进程都能被系统分配资源，相当于每个进程有了一个 python 解释器，所以多进程可以实现多个进程的同时运行，缺点是进程系统资源开销大。</p>
</li>
<li>
<p>二号知识点：</p>
<p>多线程和多进程是不一样的。</p>
<p>多进程是真正的并行，而多线程是伪并行，实际上他只是交替执行。</p>
<p>是什么导致多线程，只能交替执行呢？是一个叫 GIL（Global Interpreter Lock ，全局解释器锁）的东西。</p>
<p>GIL 的概念：</p>
<blockquote>
<p>任何 Python 线程执行前，必须先获得 GIL 锁，然后，每执行 100 条字节码，解释器就自动释放 GIL 锁，让别的线程有机会执行。这个 GIL
全局锁实际上把所有线程的执行代码都给上了锁， 所以，多线程在 Python 中只能交替执行，即使 100 个线程跑在 100 核 CPU 上，也只能用到 1 个 核</p>
</blockquote>
<p>这个是 Python 的解释器 CPython 引入的概念。还有其他解释器。但是默认的认为 Python == CPython</p>
<p>默许了 Python 有 GIL 锁这个东西。</p>
<p>避免 GIL 锁的方法：</p>
<blockquote>
<ul>
<li>使用多进程代替</li>
<li>不使用 CPython</li>
</ul>
</blockquote>
</li>
</ul>
<h1 id="7-python-实现列表去重"><a class="header" href="#7-python-实现列表去重">7. Python 实现列表去重</a></h1>
<p>Python 内置的集合是没有重复值的，数据到集合（set）里跑一圈就行了。</p>
<p>记住，是跑一圈！！！最后还要转成集合（list）</p>
<pre><code class="language-python">lst = [11, 12, 13, 12, 15, 11, 13]

tmp = set(lst)

print(type(tmp))

lst = [i for i in tmp]

print(lst)
</code></pre>
<blockquote>
<p>out:</p>
</blockquote>
<blockquote>
<p>&lt;class 'set'&gt; [11, 12, 13, 15]</p>
</blockquote>
<h1 id="8阐述args和kwargs"><a class="header" href="#8阐述args和kwargs">8.阐述<code>*args</code>和<code>**kwargs</code></a></h1>
<p><code>*args</code>和<code>*kwargs</code>主要用于函数定义。</p>
<ul>
<li>你可以将不定数量的参数传递给一个函数。这里的不定的意思是：预先并不知道函数使用者会传递多少个参数给你，所以在这个场景下使用这两个关键字。<code>*args</code>是用来发送一个非键值对的可变数量的参数==元组（不可变）==给一个函数</li>
<li><code>**kwargs</code>允许你将不定长度的键值对，作为参数传递给一个函数。如果你想要在一个函数里处理带名字的参数你应该使用<code>**kwargs</code>。这里传输的是字典。</li>
</ul>
<p>这里有类似前端的解包的概念。</p>
<blockquote>
<p>补充：</p>
</blockquote>
<blockquote>
<ol>
<li>对于参数的传递，不指定 key 值的时候，按顺序传递。</li>
<li>args 和 kwargs 只是大家约定俗成写这个，也就不要乱起名字了。</li>
</ol>
</blockquote>
<pre><code class="language-python">def func(a, *args, **kwargs):
    print(type(args))
    print(args)
    print(type(kwargs))
    print(kwargs)


func(10, 20, 30, b=40, d=50)
</code></pre>
<blockquote>
<p>out:</p>
</blockquote>
<blockquote>
<p>&lt;class 'tuple'&gt; (20, 30) &lt;class 'dict'&gt; {'b': 40, 'd': 50}</p>
</blockquote>
<h1 id="9解释一波装饰器"><a class="header" href="#9解释一波装饰器">9.解释一波装饰器</a></h1>
<p>对于一些可以将函数传递的语言，都可以用装饰器。</p>
<p>装饰器（decorator）接受一个 callable 对象 （可以是函数或者实现了 call 方法的类）作为参数，并返回一个 callable 对象。</p>
<p>灵魂就是将函数 A 传递到另外一个函数 B 中，然后使用 B 调用 A，这样可以给 A 增加额外的功能。</p>
<p>简单的装饰器：</p>
<pre><code class="language-python">def outer(my_func):
    print(&quot;step 1 : outer&quot;)
    def inner(num):
        print(&quot;step 2 : 进入内部函数&quot;)
        return my_func(num)
    return inner


@outer
def my_func(num):
    print(&quot;step 3 : my_func,传入的参数：&quot;, num)
    num += 1
    return &quot;加1之后：&quot; + str(num)


print(my_func(num=100))
</code></pre>
<blockquote>
<p>out:</p>
</blockquote>
<blockquote>
<p>step 1 : outer step 2 : 进入内部函数 step 3 : my_func,传入的参数： 100 加 1 之后：101</p>
</blockquote>
<p>高级装饰器：</p>
<pre><code class="language-python">def outer(str):
    print(&quot;outer&quot;)
    def outer1(func):
        print(&quot;outer1&quot;)
        def inner():
            print(str)
            print(&quot;inner&quot;)
            return func()
        return inner
    return outer1

@outer(&quot;哈哈哈&quot;)
def func():
    print(&quot;func&quot;)

func()
</code></pre>
<blockquote>
<p>out:</p>
</blockquote>
<blockquote>
<p>outer outer1 # 到此处都是装饰的时候生成的，下面才是调用的时候生成的 哈哈哈 inner func</p>
</blockquote>
<p>一个用来实现函数运行时间计算的装饰器：</p>
<pre><code class="language-python">def print_func_time(function):
    @wraps(function)
    def func_time(*args, **kwargs):
        t0 = time.perf_counter()
        result = function(*args, **kwargs)
        t1 = time.perf_counter()
        print(&quot;Total running time: %s s&quot; % (str(t1 - t0)))
        return result
    return func_time
</code></pre>
<h1 id="10-python-常见内建数据类型"><a class="header" href="#10-python-常见内建数据类型">10. Python 常见内建数据类型</a></h1>
<table><thead><tr><th>表示</th><th>含义</th></tr></thead><tbody>
<tr><td>int</td><td>整形</td></tr>
<tr><td>bool</td><td>布尔型</td></tr>
<tr><td>str</td><td>字符串</td></tr>
<tr><td>list</td><td>列表</td></tr>
<tr><td>tuple</td><td>元组</td></tr>
<tr><td>dict</td><td>字典</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="11-简述面向对象中__new__和__init__区别"><a class="header" href="#11-简述面向对象中__new__和__init__区别">11. 简述面向对象中<code>__new__</code>和<code>__init__</code>区别</a></h1>
<ul>
<li><code>__init__</code>是当实例对象创建完成后被调用的，然后设置对象属性的一些初始值。</li>
<li><code>__new__</code>是在实例创建（<code>__init__</code>）之前被调用的，因为它的任务就是创建实例然后返回该实例，是个静态方法。用来申请内存的。</li>
</ul>
<p>例子，使用 Python 实现单例模式（装饰器实现）：</p>
<pre><code class="language-python">def singleton(cls):
    _instance = {}

    def inner():
        if cls not in _instance:
            _instance[cls] = cls()
        return _instance[cls]
    return inner

@singleton
class Cls(object):
    def __init__(self):
        pass

cls1 = Cls()
cls2 = Cls()
print(id(cls1) == id(cls2))
</code></pre>
<blockquote>
<p>out:</p>
</blockquote>
<blockquote>
<p>True</p>
</blockquote>
<p>这里的核心思想就是在<code>__init__</code>执行之前给他先判断一遍是否已经有了实例对象了。</p>
<p>那么，因为<code>__new__</code>就是在<code>__init__</code>之前执行的，所以可以直接使用<code>__new__</code>来实现。</p>
<p>代码如下：</p>
<pre><code class="language-python">class A(object):
    instance = None

    def __new__(cls, *args, **kwargs):
        if cls.instance is None:
            cls.instance = object.__new__(cls, *args, **kwargs)
        return cls.instance

    def __init__(self):
        pass


A1 = A()
A2 = A()
print(id(A1) == id(A2))
</code></pre>
<blockquote>
<p>out:</p>
</blockquote>
<blockquote>
<p>True</p>
</blockquote>
<p>补充：</p>
<ol>
<li>
<p><code>__new__</code>至少要有一个参数<code>cls</code>，代表当前类，此参数在实例化时由 Python 解释器自动识别</p>
</li>
<li>
<p><code>__new__</code>必须要有返回值，返回实例化出来的实例，这点在自己实现<code>__new__</code>时要特别注意，可以<code>return父类</code>（通过 super(当前类名,
cls)）<code>__new__</code>出来的实例，或者直接是 object 的<code>__new__</code>出来的实例</p>
</li>
<li>
<p><code>__init__</code>有一个参数<code>self</code>，就是这个<code>__new__</code>返回的实例，<code>__init__</code>在<code>__new__</code>的基础上可以完成一些其它初始化的动作，<code>__init__</code>不需要返回值</p>
</li>
<li>
<p>如果<code>__new__</code>创建的是当前类的实例，会自动调用<code>__init__</code>函数，通过 return 语句里面调用的<code>__new__</code>函数的第一个参数是 cls
来保证是当前类实例，如果是其他类的类名，那么实际创建返回的就是其他类的实例，其实就不会调用当前类的<code>__init__</code>函数，也不会调用其他类的<code>__init__</code>函数。</p>
</li>
</ol>
<h1 id="12-with-是个什么东西"><a class="header" href="#12-with-是个什么东西">12. with 是个什么东西</a></h1>
<p><strong>上下文管理器：</strong></p>
<p>帮助使用者完成一些代码</p>
<p>包括开始和结束的操作</p>
<p>使用者做执行的操作</p>
<p>一些常用的上下文管理的语句：<code>with …… as ……</code></p>
<p>结合起来就是上下文管理器</p>
<p>如何自定义一个上下文管理器：</p>
<p><strong>姿势 1：</strong></p>
<pre><code class="language-python">class Resources():
    def __enter__(self):
        print(&quot;进入&quot;)
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        print(&quot;离开&quot;)

    def operate(self):
        print('执行')


with Resources() as res:
    res.operate()
    res.operate()
    print(&quot;执行结束&quot;)

print(&quot;结束&quot;)
</code></pre>
<blockquote>
<p>out: 进入 执行 执行 执行结束 离开 结束</p>
</blockquote>
<p>上面的那个太复杂了，居然要定义一个类！虽然看起来蛮清爽的。但是作为程序员怎么能不偷懒呢。</p>
<p>所以有人给我们写好了<code>contextlib.contextmanager</code>来偷懒了</p>
<p><strong>姿势 2：</strong></p>
<p>可以理解为就是在我们正式执行某个操作前的一些预先准备的动作。</p>
<p>显然，想到了装饰器，但是装饰器不能停下来啊。</p>
<p>所以我们又想到了 yield 生成器。</p>
<pre><code class="language-python">import contextlib

@contextlib.contextmanager
def open_file(filename,mode):
    print(&quot;上文管理&quot;)
    f = open(filename,mode)
    try:
        yield f
        print(&quot;下文管理&quot;)
    except Exception as e:
        print(e)
    finally:
        f.close()


with open_file(&quot;demo.txt&quot;,&quot;r&quot;) as f:
    text = f.read()
    print(text)

print(&quot;全部执行结束&quot;)
</code></pre>
<blockquote>
<p>out: 上文管理 文本内容 下文管理 全部执行结束</p>
</blockquote>
<h1 id="13-lambda-和列表推导式"><a class="header" href="#13-lambda-和列表推导式">13. lambda 和列表推导式</a></h1>
<p>需求：将 1-5 平方后，先使用<code>map()</code>打印出来，然后取比 10 大的数</p>
<pre><code class="language-python">lst = [1, 2, 3, 4, 5]

res = map(lambda x: x ** 2, lst)

print(res)
# for i in res:
#     print(i)

print([i for i in res if i &gt; 10])
</code></pre>
<blockquote>
<p>out:</p>
</blockquote>
<blockquote>
<p><code>&lt;map object at 0x00000164579EE608&gt;</code> &gt; [16, 25]</p>
</blockquote>
<p>如果放开注释，则下面的语句输出为空。</p>
<blockquote>
<p>Python2 中 map 返回列表 Python3 中 map 返回迭代器</p>
</blockquote>
<blockquote>
<p>所以若放开注释，就输出空列表。</p>
</blockquote>
<p>补充：</p>
<p><code>map()</code> 会根据提供的函数对指定序列做映射。</p>
<p>第一个参数 function 以参数序列中的每一个元素调用 function 函数，返回包含每次 function 函数返回值的新==迭代器==。</p>
<h1 id="14-随机数"><a class="header" href="#14-随机数">14. 随机数</a></h1>
<pre><code class="language-python">import random
import numpy as np

# [10,20]的随机整数，双闭区间
result = random.randint(10, 20)

# 5个随机小数（高斯分布）
res = np.random.randn(5)

# [0,1)的随机小数，左闭右开
ret = random.random()

print(&quot;[10,20]正整数：&quot;, result)
print(&quot;5个随机小数：&quot;, res)
print(&quot;[0,1)随机小数：&quot;, ret)
</code></pre>
<blockquote>
<p>[10,20]正整数： 15 5 个随机小数： [ 0.74183062 -0.71999601 2.36063785 0.81164776 0.48217159] [0,1)随机小数：
0.9043009242501265</p>
</blockquote>
<p>注意区间~~~</p>
<p>不记得就看看源码，哈哈。</p>
<h1 id="15-字符串不转义"><a class="header" href="#15-字符串不转义">15. 字符串不转义</a></h1>
<p>先看几个常见的转义：</p>
<table><thead><tr><th>转义字符</th><th>作用描述</th><th>使用率</th></tr></thead><tbody>
<tr><td><code>\</code></td><td>续行符</td><td><code>*</code></td></tr>
<tr><td><code>\\</code></td><td>反斜杠符号(<code>\</code>)</td><td><code>***</code></td></tr>
<tr><td><code>\'</code></td><td>单引号</td><td><code>*****</code></td></tr>
<tr><td><code>\&quot;</code></td><td>双引号</td><td><code>*****</code></td></tr>
<tr><td><code>\n</code></td><td>换行</td><td><code>*****</code></td></tr>
<tr><td><code>\t</code></td><td>横向制表符</td><td><code>*****</code></td></tr>
<tr><td><code>\r</code></td><td>回车</td><td><code>*****</code></td></tr>
</tbody></table>
<p>不要转义的话，就在字符串引号前面加 r 就可以了：</p>
<pre><code class="language-python">string1 = r'~!@#$?\'/'
string2 = '~!@#$?\'/'

print(string1)
print(string2)
</code></pre>
<blockquote>
<p>out：</p>
</blockquote>
<blockquote>
<p>~!@#$?'/ ~!@#$?'/</p>
</blockquote>
<p>补充：</p>
<p>关于 Python 的单引号和双引号：</p>
<p>如果想定义一个字符串中有单引号：</p>
<p>姿势 1：使用单引号和转义</p>
<pre><code class="language-python">my_str = 'I\'m a student'
</code></pre>
<p>姿势 2：不使用转义，使用双引号直接定义</p>
<pre><code class="language-python">my_str = &quot;I'm a student&quot;
</code></pre>
<p>如果想定义一个字符串包含双引号：</p>
<p>姿势 1：使用双引号和转义</p>
<pre><code class="language-python">my_str = &quot;Jason said \&quot;I like you\&quot;&quot;
</code></pre>
<p>姿势 2：不使用转义字符，利用单引号直接进行定义</p>
<pre><code class="language-python">my_str = 'Jason said &quot;I like you&quot;'
</code></pre>
<p>综上所述：</p>
<p>要包含什么，就用另一个。。。</p>
<p>至于转义，随便用哪个就行了。</p>
<h1 id="16-正则小试牛刀"><a class="header" href="#16-正则小试牛刀">16. 正则小试牛刀</a></h1>
<div class="nam"\>中国\</div\>，用正则匹配出标签里面的内容（“中国”），其中 class 的类名是不确定的
<pre><code class="language-python">import re

string = '&lt;div class=&quot;nam&quot;&gt;中国&lt;/div&gt;'

res = re.findall(r'&lt;div class=&quot;.*&quot;&gt;(.*?)&lt;/div&gt;', string)

print(res)
</code></pre>
<blockquote>
<p>out:</p>
</blockquote>
<blockquote>
<p>['中国']</p>
</blockquote>
<p><strong>知识点：</strong></p>
<ol>
<li><code>.</code>表示匹配单字符（万能匹配，什么都可以匹配），但是不能匹配<code>\n</code></li>
<li><code>*</code>表示匹配 0 或任意个前面的字符（<code>+</code>是匹配 1 或任意个；<code>？</code>是匹配 0 或 1 个）</li>
<li><code>？</code>表示非贪婪</li>
<li>括号是提取文本的</li>
</ol>
<h1 id="17-断言"><a class="header" href="#17-断言">17. 断言</a></h1>
<p><code>assert()</code>断言方法，</p>
<p>断言成功，则程序继续执行，断言失败，则程序报错</p>
<pre><code class="language-python">a = 3
assert (a &gt; 1)
print(&quot;断言成功，继续执行&quot;)

b = 4
assert b == a
print(&quot;断言失败，报错&quot;)
</code></pre>
<blockquote>
<p>out:</p>
</blockquote>
<blockquote>
<p>断言成功，继续执行 Traceback (most recent call last): File &quot;D:/PyCharm Workspace/Python 爬坑/017-断言.py&quot;, line
6, in <module> assert b == a AssertionError</p>
</blockquote>
<h1 id="18-数据库去重"><a class="header" href="#18-数据库去重">18. 数据库去重</a></h1>
<p>数据表 student 有 id,name,score,city 字段，其中 name 中的名字可有重复，需要消除重复行,请写 sql 语句</p>
<pre><code class="language-mysql">select distinct name from student
</code></pre>
<h1 id="19-10-个-linux-常用命令"><a class="header" href="#19-10-个-linux-常用命令">19. 10 个 Linux 常用命令</a></h1>
<p>ls pwd cd touch rm mkdir top cp mv cat more grep echo</p>
<ul>
<li>
<p>grep 是 linux 系统中 grep 命令是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹 配的行打印出来。grep 全称是 Global Regular Expression
Print，表示全局正则表达式版本，它的使用权限是所有用户。</p>
</li>
<li>
<p>echo 命令的功能是在显示器上显示一段文字，一般起到一个提示的作用。</p>
</li>
</ul>
<h1 id="20-python2-和-python3-区别列举-5-个"><a class="header" href="#20-python2-和-python3-区别列举-5-个">20. python2 和 python3 区别？列举 5 个</a></h1>
<ol>
<li>
<p>Python3 使用 print 必须要以小括号包裹打印内容，比如 print('hi')</p>
<p>Python2 既可以使用带小括号的方式，也可以使用一个空格来分隔打印内容，比如 print 'hi'</p>
</li>
<li>
<p>python2 range(1,10)返回列表，python3 中返回迭代器，节约内存</p>
</li>
<li>
<p>python2 中使用 ascii 编码，python 中使用 utf-8 编码</p>
</li>
<li>
<p>python2 中 unicode 表示字符串序列，str 表示字节序列</p>
<p>python3 中 str 表示字符串序列，byte 表示字节序列</p>
</li>
<li>
<p>python2 中为正常显示中文，引入 coding 声明，python3 中不需要</p>
</li>
<li>
<p>python2 中是 raw_input()函数，python3 中是 input()函数</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h2 id="21-列出-python-中可变数据类型和不可变数据类型并简述原理"><a class="header" href="#21-列出-python-中可变数据类型和不可变数据类型并简述原理">21. 列出 python 中可变数据类型和不可变数据类型，并简述原理</a></h2>
<p>Python
中一切皆对象，对象就像一个塑料盒子，里面装的是数据。对象有不同类型，例如布尔型和整型，类型决定了可以对它进行的操作。现实生活中的&quot;陶器&quot;会暗含一些信息（例如它可能很重且易碎，注意不要掉到地上）。
对象的类型还决定了它装着的数据是允许被修改的变量（可变的 mutable）还是不可被修改的常量（不可变的
immutable）。你可以把不可变对象想象成一个透明但封闭的盒子：你可以看到里面装的数据，但是无法改变它。类似地，可变对象就像一个开着口的盒子，你不仅可以看到里面的数据，还可以拿出来修改它，但你无法改变这个盒子本身，即你无法改变对象的类型。</p>
<ul>
<li>mutable：可变对象，如 List、Dict 和 Set</li>
<li>immutable：不可变对象，如 Number、String、Tuple、Frozenset</li>
</ul>
<p><strong>注意：</strong></p>
<p>​<strong>Python 赋值操作或函数参数传递，传递的永远是对象引用（即内存地址），而不是对象内容。</strong></p>
<pre><code class="language-python">In [1]: a = 1
In [2]: b = a

In [3]: id(a)
Out[3]: 9164864
In [4]: id(b)
Out[4]: 9164864

In [5]: b += 1
In [6]: a
Out[6]: 1
In [7]: b
Out[7]: 2
In [8]: id(a)  # 对象引用a还是指向Number对象1
Out[8]: 9164864
In [9]: id(b)  # 对象引用b指向了Number对象2
Out[9]: 9164896
</code></pre>
<p><strong>Python 会缓存使用非常频繁的小整数-5 至 256 、 ISO/IEC 8859-1 单字符 、 只包含大小写英文字 母的字符串 ，以对其复用，不会创建新的对象：</strong></p>
<pre><code class="language-python">1. 不会创建新对象 In [1]: a = 10
In [2]: b = 10
In [3]: id(a)
Out[3]: 9165152
In [4]: id(b)
Out[4]: 9165152
In [5]: a = '@'
In [6]: b = '@'
In [7]: id(a)
Out[7]: 139812844740424
In [8]: id(b)
Out[8]: 139812844740424
In [9]: a = 'HELLOWORLDhelloworld'
In [10]: b = 'HELLOWORLDhelloworld'
In [11]: id(a)
Out[11]: 139812785036792
In [12]: id(b)
Out[12]: 139812785036792
2. 会创建新的对象
In [1]: a = 1000
In [2]: b = 1000
In [3]: id(a)
Out[3]: 140528314730384
In [4]: id(b)
Out[4]: 140528314731824
In [5]: a = 'x*y'
In [6]: b = 'x*y'
In [7]: id(a)
Out[7]: 139897777405880
In [8]: id(b)
Out[8]: 139897777403808
In [9]: a = 'Hello World'
In [10]: b = 'Hello World'
In [11]: id(a)
Out[11]: 139897789146096
In [12]: id(b)
Out[12]: 139897789179568
</code></pre>
<p>上述测试必须早交互式环境下操作，编译环境下会做优化。</p>
<p>copy 是浅拷贝 （只拷贝内存地址）</p>
<p>deepcopy 是深拷贝 （内容重新分配）</p>
<h2 id="22-字符串基操"><a class="header" href="#22-字符串基操">22. 字符串基操</a></h2>
<p>s = &quot;ajldjlajfdljfddd&quot;，去重并从小到大排序输出&quot;adfjl&quot;</p>
<pre><code class="language-python">s = &quot;ajldjlajfdljfddd&quot;
s = list(set(s))
s.sort(reverse=False)
ret = &quot;&quot;.join(s)
print(ret)
</code></pre>
<blockquote>
<p>out：</p>
</blockquote>
<blockquote>
<p>adfjl</p>
</blockquote>
<p>首先去重是利用的集合，</p>
<p>然后转成数组才能 sort，reverse</p>
<p>然后还要拼接成字符串。</p>
<h2 id="23-lambda-函数"><a class="header" href="#23-lambda-函数">23. Lambda 函数</a></h2>
<p>用 lambda 函数实现两个数相乘</p>
<pre><code class="language-python">sum = lambda a, b: a * b
print(sum(5, 4))
</code></pre>
<blockquote>
<p>out：</p>
</blockquote>
<blockquote>
<p>20</p>
</blockquote>
<p>主要是理解 lambda 的写法，lambda 是匿名函数（可以这么理解）</p>
<p>后面用逗号隔开参数，冒号后面写返回值。可以是复杂的列表推导式，但是只能是“一句话”。</p>
<h2 id="24-字典根据键值从小到大排序"><a class="header" href="#24-字典根据键值从小到大排序">24. 字典根据键值从小到大排序</a></h2>
<p>dic={&quot;name&quot;:&quot;zs&quot;,&quot;age&quot;:18,&quot;city&quot;:&quot;深圳&quot;,&quot;tel&quot;:&quot;1362626627&quot;}</p>
<pre><code class="language-python">dic = {&quot;name&quot;: &quot;zs&quot;, &quot;age&quot;: 18, &quot;city&quot;: &quot;深圳&quot;, &quot;tel&quot;: &quot;1362626627&quot;}

lis = sorted(dic.items(), key=lambda i: i[0], reverse=False)

print(lis)

lis = dict(lis)

print(lis)
</code></pre>
<blockquote>
<p>out：</p>
</blockquote>
<blockquote>
<p>[('age', 18), ('city', '深圳'), ('name', 'zs'), ('tel', '1362626627')] {'age': 18, 'city': '深圳',
'name': 'zs', 'tel': '1362626627'}</p>
</blockquote>
<p>先使用 sorted 函数根据键值进行排序。</p>
<p>然后转成字典。</p>
<h2 id="25-collections-库"><a class="header" href="#25-collections-库">25. collections 库</a></h2>
<p>利 用 collections 库 的 Counter 方 法 统 计 字 符 串 每 个 单 词 出 现 的 次数</p>
<p>&quot;kjalfj;ldsjafl;hdsllfdhg;lahfbl;hl;ahlf;h&quot;</p>
<pre><code class="language-python">from collections import Counter

string = &quot;kjalfj;ldsjafl;hdsllfdhg;lahfbl;hl;ahlf;h&quot;

res = Counter(string)

print(res)
</code></pre>
<p>没啥好说的。。。</p>
<h2 id="26-再来正则"><a class="header" href="#26-再来正则">26. 再来正则</a></h2>
<p>字符串 a = &quot;not 404 found 张三 99 深圳&quot;，每个词中间是空格，用正则过滤掉英 文和数字，终输出&quot;张三 深圳&quot;</p>
<pre><code class="language-python">import re

a = &quot;not 404 found 张三 99 深圳&quot;
list = a.split(&quot; &quot;)
print(list)
res = re.findall(r'\d+|[a-zA-Z]+', a)

for i in res:
    if i in list:
        list.remove(i)
new_str = &quot; &quot;.join(list)

print(res)
print(new_str)
</code></pre>
<blockquote>
<p>out：</p>
</blockquote>
<blockquote>
<p>['not', '404', 'found', '张三', '99', '深圳'] ['not', '404', 'found', '99'] 张三 深圳</p>
</blockquote>
<p>使用<code>\d</code>匹配数字，<code>[a-zA-Z]</code>匹配英文字符</p>
<p><code>+</code>表示 1 或任意个，<code>|</code>表示多个匹配规则</p>
<p>匹配小数的话</p>
<p><code>\d+\.?\d*</code></p>
<p>不一定对。</p>
<h2 id="27-filter-方法"><a class="header" href="#27-filter-方法">27. filter 方法</a></h2>
<p>filter 方法求出列表所有奇数并构造新列表，a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</p>
<pre><code class="language-python">a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]


def fn(a):
    return a % 2 == 1


newList = filter(fn, a)
print(newList)
newList = [i for i in newList]
print(newList)
</code></pre>
<blockquote>
<p>out：</p>
</blockquote>
<blockquote>
<p>&lt;filter object at 0x00000172B4E1F5C8&gt; [1, 3, 5, 7, 9]</p>
</blockquote>
<p><code>filter()</code> 函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列
表。该接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判断，然后返回<code>True</code>或<code>False</code>，最后将返回<code>True</code>的元素放到新列表。</p>
<blockquote>
<p>filter 返回的是迭代器。所以要组装成列表。</p>
</blockquote>
<h2 id="28-列表推导式"><a class="header" href="#28-列表推导式">28. 列表推导式</a></h2>
<p>列表推导式求列表所有奇数并构造新列表，a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</p>
<pre><code class="language-python">res = [i for i in [x for x in range(1, 11)] if i % 2 == 1]
print(res)
</code></pre>
<p>构造列表只要在两边加<code>[]</code>就可以啦。</p>
<h2 id="29-recompile"><a class="header" href="#29-recompile">29. re.compile()</a></h2>
<p><code>re.compile()</code>是将正则表达式编译成一个对象，加快速度，并重复使用</p>
<p>就是将你的正则表达式搞成一个对象存着了。</p>
<h2 id="30-tuple-的小小的坑"><a class="header" href="#30-tuple-的小小的坑">30. tuple 的小小的坑</a></h2>
<p>a=（1，）b=(1)，c=(&quot;1&quot;) 分别是什么类型的数据？</p>
<pre><code class="language-python">print(type((1)))
print(type((&quot;1&quot;)))
print(type((1,)))
</code></pre>
<blockquote>
<p>out：</p>
</blockquote>
<blockquote>
<p>&lt;class 'int'&gt; &lt;class 'str'&gt; &lt;class 'tuple'&gt;</p>
</blockquote>
<p><code>()</code>是运算符，是运算符，是运算符。</p>
<p>重要的事情说三遍。但是在创建<code>tuple</code>的时候</p>
<p>如果需要创建只有一个元素的<code>tuple</code>，那么要加逗号<code>,</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="31-列表合并"><a class="header" href="#31-列表合并">31. 列表合并</a></h2>
<p>两个列表[1,5,7,9]和[2,2,6,8]合并为[1,2,2,3,6,7,8,9]</p>
<p>一开始可能先想到的是 append，但是要了解到，对单个元素，确实是加进去了，如果是整个东西。那么这整个东西算作一个。因为 Python 中的列表是没有元素类型限制的。</p>
<pre><code class="language-python">list1 = [1, 5, 7, 9]
list2 = [2, 2, 6, 8]

# list1.extend(list2)
list1.append(list2)
print(list1)
</code></pre>
<blockquote>
<p>out：</p>
</blockquote>
<blockquote>
<p>[1, 5, 7, 9, [2, 2, 6, 8]]</p>
</blockquote>
<p>所以这里应该用 extend，extend 可以将另一个集合中的元素<strong>逐一添加到列表中</strong>，区别于 append 整体添加。</p>
<pre><code class="language-python">list1 = [1, 5, 7, 9]
list2 = [2, 2, 6, 8]

list1.extend(list2)
print(list1)

list1.sort(reverse=False)
print(list1)
</code></pre>
<blockquote>
<p>out：</p>
</blockquote>
<blockquote>
<p>[1, 5, 7, 9, 2, 2, 6, 8] [1, 2, 2, 5, 6, 7, 8, 9]</p>
</blockquote>
<h2 id="32-os-删除文件"><a class="header" href="#32-os-删除文件">32. OS 删除文件</a></h2>
<p>Python 可以跨平台，使用 os 模块就可以了</p>
<p>Python: os.remove(文件名)</p>
<p>Linux: rm</p>
<h2 id="33-log-日志打印时间"><a class="header" href="#33-log-日志打印时间">33. Log 日志打印时间</a></h2>
<p>log 日志中，我们需要用时间戳记录 error,warning 等的发生时间，请用 datetime 模块打印当前时间戳 “2018-04-01 11:38:54”</p>
<p>题解中使用的 datetime 模块</p>
<pre><code class="language-python">import datetime
a = f'{datetime.datetime.now().strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)}    星期 ： {datetime.datetime.now().isoweekday()}'
print(a)
</code></pre>
<blockquote>
<p>out：</p>
</blockquote>
<blockquote>
<p>2019-09-15 12:50:56 星期 ： 7</p>
</blockquote>
<p>但是我们在使用 logging 日志的时候，日志本身给我们提供了打印时间的方法。</p>
<p>在 Formatter 参数中</p>
<table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody>
<tr><td>%(message)s</td><td>用户自定义要输出的信息</td></tr>
<tr><td>%(asctime)s</td><td>当前的日期时间</td></tr>
<tr><td>%(name)s</td><td>logger 实例的名称</td></tr>
<tr><td>%(module)s</td><td>使用 logger 实例的模块名</td></tr>
<tr><td>%(filename)s</td><td>使用 logger 实例的模块的文件名</td></tr>
<tr><td>%(funcName)s</td><td>使用 logger 实例的函数名</td></tr>
<tr><td>%(lineno)d</td><td>使用 logger 实例的代码行号</td></tr>
<tr><td>%(levelname)s</td><td>日志级别名称</td></tr>
<tr><td>%(levelno)s</td><td>表示日志级别的数字形式</td></tr>
<tr><td>%(threadName)s</td><td>使用 logger 实例的线程名称（测试多线程时有用）</td></tr>
<tr><td>%(thread)d</td><td>使用 logger 实例的线程号（测试多线程时有用）</td></tr>
<tr><td>%(process)d</td><td>使用 logger 实例的进程号（测试多进程时有用）</td></tr>
</tbody></table>
<p>配合 OS 和 time 模块的时候我们可以自定义 Logger 实例：</p>
<pre><code class="language-python">import os
import time
import logging
# 1. 创建logger实例，如果参数为空则返回 root logger
logger = logging.getLogger('aiotest')

# 设置总日志级别, 也可以给不同的handler设置不同的日志级别
logger.setLevel(logging.DEBUG)

# 2. 创建Handler, 输出日志到控制台和文件
# 控制台日志和日志文件使用同一个Formatter
formatter = logging.Formatter('%(asctime)s - %(filename)s[line:%(lineno)d] - &lt;%(threadName)s %(thread)d&gt;' + '- &lt;Process %(process)d&gt; - %(levelname)s: %(message)s' )

# 日志文件FileHandler
basedir = os.path.abspath(os.path.dirname(__file__))
log_dest = os.path.join(basedir, 'logs')    # 日志文件所在目录
if not os.path.isdir(log_dest):
    os.mkdir(log_dest)

filename = time.strftime('%Y-%m-%d-%H-%M-%S', time.localtime(time.time())) + '.log'

# 日志文件名，以当前时间命名
file_handler = logging.FileHandler(os.path.join(log_dest, filename), encoding='utf-8')

file_handler.setFormatter(formatter)
# 设置Formatter
file_handler.setLevel(logging.WARNING)
# 单独设置日志文件的日志级别

# 控制台日志StreamHandler
stream_handler = logging.StreamHandler()
stream_handler.setFormatter(formatter)
# stream_handler.setLevel(logging.INFO)
# 单独设置控制台日志的日志级别，注释掉则使用总日志 级别
# 3. 将handler添加到logger中
logger.addHandler(file_handler)
logger.addHandler(stream_handler)
</code></pre>
<h2 id="34-数据库优化查询的方法"><a class="header" href="#34-数据库优化查询的方法">34. 数据库优化查询的方法</a></h2>
<ul>
<li>
<p>建立外键（好像不怎么用？）</p>
</li>
<li>
<p>建立索引</p>
</li>
<li>
<p>联合查询</p>
</li>
<li>
<p>选择特定字段</p>
</li>
<li>
<p>……</p>
</li>
</ul>
<h2 id="35-绘制统计图的开源库"><a class="header" href="#35-绘制统计图的开源库">35. 绘制统计图的开源库</a></h2>
<p>pychart、matplotlib、Seaborn</p>
<h2 id="36-自定义异常"><a class="header" href="#36-自定义异常">36. 自定义异常</a></h2>
<pre><code class="language-python">def fn():
    try:
        for i in range(5):
            if i &gt; 2:
                raise Exception(&quot;My Error&quot;)
    except Exception as ret:
        print(ret)


fn()
</code></pre>
<blockquote>
<p>out：</p>
</blockquote>
<blockquote>
<p>My Error</p>
</blockquote>
<h2 id="37-和的区别"><a class="header" href="#37-和的区别">37. <code>（.*）</code>和<code>（.*？）</code>的区别</a></h2>
<p>正则表达式中，默认是贪婪匹配的。</p>
<p>加上数量通配符之后若添加<code>？</code>则会取消贪婪匹配。</p>
<p><code>(.*)</code>是贪婪匹配，会把满足正则的尽可能多的往后匹配</p>
<p><code>(.*?)</code>是非贪婪匹配，会把满足正则的尽可能少匹配</p>
<p>例子：</p>
<pre><code class="language-python">import re

s = &quot;&lt;a&gt;哈哈&lt;/a&gt;&lt;a&gt;哈哈&lt;/a&gt;&quot;

res1 = re.findall(&quot;&lt;a&gt;(.*)&lt;/a&gt;&quot;, s)
res2 = re.findall(&quot;&lt;a&gt;(.*?)&lt;/a&gt;&quot;, s)
print(res1)
print(res2)
</code></pre>
<blockquote>
<p>out：</p>
</blockquote>
<blockquote>
<p>['哈哈</a><a>哈哈'] ['哈哈', '哈哈']</p>
</blockquote>
<h2 id="38-简述-django-的-orm"><a class="header" href="#38-简述-django-的-orm">38. 简述 Django 的 orm</a></h2>
<p>ORM，全拼 Object-Relation Mapping，意为对象-关系映射实现了数据模型与数据库的解耦，通过简单的配置就可以轻松更换数据库，而不需要修改 代码只需要面向对象编程,orm
操作本质上会根据对接的数据库引擎，翻译成对应的 sql 语 句,所有使用 Django 开发的项目无需关心程序底层使用的是 MySQL、Oracle、 sqlite....，如果数据库迁移，只需要更换
Django 的数据库引擎即可</p>
<p><img src="Python/./images/Django_ORM.png" alt="" /></p>
<h2 id="39-列表推导式的骚操作"><a class="header" href="#39-列表推导式的骚操作">39. 列表推导式的骚操作</a></h2>
<p>[[1,2],[3,4],[5,6]]一行代码展开该列表，得出[1,2,3,4,5,6]</p>
<pre><code class="language-python">list1 = [[1, 2], [3, 4], [5, 6]]
list2 = [j for i in list1 for j in i]

print(list2)
</code></pre>
<blockquote>
<p>out：</p>
</blockquote>
<blockquote>
<p>[1, 2, 3, 4, 5, 6]</p>
</blockquote>
<p>使用 Numpy</p>
<pre><code class="language-python">import numpy as np
list3 = np.array(list1).flatten().tolist()
print(list3)
</code></pre>
<blockquote>
<p>out：</p>
</blockquote>
<blockquote>
<p>[1, 2, 3, 4, 5, 6]</p>
</blockquote>
<p>flatten 是将所有元素 copy 一份，并且变为一维数组。</p>
<h2 id="40-join方法"><a class="header" href="#40-join方法">40. <code>join()</code>方法</a></h2>
<p>x=&quot;abc&quot;,y=&quot;def&quot;,z=[&quot;d&quot;,&quot;e&quot;,&quot;f&quot;],分别求出 x.join(y)和 x.join(z)返回的结果</p>
<pre><code class="language-python">x = &quot;abc&quot;
y = &quot;def&quot;
z = [&quot;d&quot;,&quot;e&quot;,&quot;f&quot;]

m = x.join(y)
n = x.join(z)
print(m)
print(n)
</code></pre>
<blockquote>
<p>out：</p>
</blockquote>
<blockquote>
<p>dabceabcf dabceabcf</p>
</blockquote>
<p><code>join()</code>括号里面的是可迭代对象，x 插入可迭代对象中间（每个都插一遍），形成字符串，结果一致，有没 有突然感觉字符串的常见操作都不会玩了
顺便建议大家学下<code>os.path.join()</code>方法，拼接路径经常用到，也用到了<code>join</code>,和字符串操作中的<code>join</code>有什么区别，该问题大家可以查阅相关文档</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="41举例说明异常模块中-try-except-else-finally-的相关意义"><a class="header" href="#41举例说明异常模块中-try-except-else-finally-的相关意义">41、举例说明异常模块中 try except else finally 的相关意义</a></h2>
<ul>
<li>
<p>try..except..else 没有捕获到异常，执行 else 语句</p>
</li>
<li>
<p>try..except..finally 不管是否捕获到异常，都执行 finally 语句</p>
</li>
</ul>
<pre><code class="language-python">try:
    num = 100
    print(num)
except NameError as errorMsg:
    print(&quot;产生错误了:%s&quot; % errorMsg)
else:
    print(&quot;没有捕获到异常,执行else&quot;)

try:
    num = 100
    print(num)
except NameError as errorMsg:
    print(&quot;产生错误了:%s&quot; % errorMsg)
finally:
    print(&quot;无论是否捕获到异常,都执行finally&quot;)
</code></pre>
<blockquote>
<p>out:</p>
</blockquote>
<blockquote>
<p>100 没有捕获到异常,执行 else 100 无论是否捕获到异常,都执行 finally</p>
</blockquote>
<h2 id="42python-中交换两个数值"><a class="header" href="#42python-中交换两个数值">42、python 中交换两个数值</a></h2>
<pre><code class="language-python">a, b = 3, 4
print(a, b)
a, b = b, a
print(a, b)
</code></pre>
<blockquote>
<p>out:</p>
</blockquote>
<blockquote>
<p>3 4 4 3</p>
</blockquote>
<p>Python 中是引用机制.</p>
<p>所有的对象都是引用赋值.</p>
<p><code>=</code>赋值都是改变引用.</p>
<p>Python 的语法糖,上述的逗号连续赋值的时候不会在赋值的过程中改变.</p>
<h2 id="43zip函数用法"><a class="header" href="#43zip函数用法">43、<code>zip()</code>函数用法</a></h2>
<p><code>zip()</code>函数在运算时，会以一个或多个序列（可迭代对象）做为参数，返回一个元组的列表。同时将这些序列中并排的元素配对。</p>
<p><code>zip()</code>参数可以接受任何类型的序列，同时也可以有两个以上的参数;当传入参数的长度不 同时，zip 能自动以最短序列长度为准进行截取，获得元组。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="各种常见排序算法的比较"><a class="header" href="#各种常见排序算法的比较">各种常见排序算法的比较</a></h1>
<h2 id="一详细时间复杂度总结"><a class="header" href="#一详细时间复杂度总结">一、详细时间复杂度总结</a></h2>
<p><img src="Algorithm/./images/1282720-20171120155153899-888274770.png" alt="img" /></p>
<h2 id="二稳定性分析"><a class="header" href="#二稳定性分析">二、稳定性分析</a></h2>
<p><img src="Algorithm/./images/1282720-20171120155324930-1840541919.png" alt="img" /></p>
<blockquote>
<p>**不稳定排序算法：**选择排序、快速排序、希尔排序、堆排序</p>
</blockquote>
<blockquote>
<p>**稳定排序算法：**而冒泡排序、插入排序、归并排序和基数排序</p>
</blockquote>
<h2 id="三常见排序算法简要分析"><a class="header" href="#三常见排序算法简要分析">三、<strong>常见排序算法简要分析：</strong></a></h2>
<h3 id="1冒泡排序"><a class="header" href="#1冒泡排序">(1)冒泡排序</a></h3>
<p>冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，我想你是不会再无聊地把他们俩交换一下的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。</p>
<h3 id="2选择排序"><a class="header" href="#2选择排序">(2)选择排序</a></h3>
<p>选择排序是给每个位置选择当前元素最小的，比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，依次类推，直到第 n - 1 个元素，第 n
个元素不用选择了，因为只剩下它一个最大的元素了。那么，在一趟选择，如果当前元素比一个元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么交换后稳定性就被破坏了。比较拗口，举个例子，序列 5
8 5 2 9，我们知道第一遍选择第 1 个元素 5 会和 2 交换，那么原序列中 2 个 5 的相对前后顺序就被破坏了，所以选择排序不是一个稳定的排序算法。</p>
<h3 id="3插入排序"><a class="header" href="#3插入排序">(3)插入排序</a></h3>
<p>插入排序是在一个已经有序的小序列的基础上，一次插入一个元素。当然，刚开始这个有序的小序列只有 1
个元素，就是第一个元素。比较是从有序序列的末尾开始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置。如果碰见一个和插入元素相等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳定的。</p>
<h3 id="4快速排序"><a class="header" href="#4快速排序">(4)快速排序</a></h3>
<p>快速排序有两个方向，左边的 i 下标一直往右走，当 a[i] &lt;= a[center_index]，其中 center_index 是中枢元素的数组下标，一般取为数组第 0 个元素。而右边的 j
下标一直往左走，当 a[j] &gt; a[center_index]。如果 i 和 j 都走不动了，i &lt;= j，交换 a[i]和 a[j],重复上面的过程，直到 i &gt; j。 交换 a[j]和
a[center_index]，完成一趟快速排序。在中枢元素和 a[j]交换的时候，很有可能把前面的元素的稳定性打乱，比如序列为 5 3 3 4 3 8 9 10 11，现在中枢元素 5 和 3（第
5 个元素，下标从 1 开始计）交换就会把元素 3 的稳定性打乱，所以快速排序是一个不稳定的排序算法，不稳定发生在中枢元素和 a[j] 交换的时刻。</p>
<h3 id="5归并排序"><a class="header" href="#5归并排序">(5)归并排序</a></h3>
<p>归并排序是把序列递归地分成短序列，递归出口是短序列只有 1 个元素（认为直接有序）或者 2 个序列（1
次比较和交换），然后把各个有序的段序列合并成一个有序的长序列，不断合并直到原序列全部排好序。可以发现，在 1 个或 2 个元素时，1 个元素不会交换，2
个元素如果大小相等也没有人故意交换，这不会破坏稳定性。那么，在短的有序序列合并的过程中，稳定是是否受到破坏？没有，合并过程中我们可以保证如果两个当前元素相等时，我们把处在前面的序列的元素保存在结果序列的前面，这样就保证了稳定性。所以，归并排序也是稳定的排序算法。</p>
<h3 id="6基数排序"><a class="header" href="#6基数排序">(6)基数排序</a></h3>
<p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序，最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以其是稳定的排序算法。</p>
<h3 id="7希尔排序shell"><a class="header" href="#7希尔排序shell">(7)希尔排序(shell)</a></h3>
<p>希尔排序是按照不同步长对元素进行插入排序，当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；当元素基本有序了，步长很小，
插入排序对于有序的序列效率很高。所以，希尔排序的时间复杂度会比
O(n^2)好一些。由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以 shell
排序是不稳定的。</p>
<h3 id="8堆排序"><a class="header" href="#8堆排序">(8)堆排序</a></h3>
<p>我们知道堆的结构是节点 i 的孩子为 2 _ i 和 2 _ i + 1 节点，大顶堆要求父节点大于等于其 2 个子节点，小顶堆要求父节点小于等于其 2 个子节点。在一个长为 n
的序列，堆排序的过程是从第 n / 2 开始和其子节点共 3 个值选择最大（大顶堆）或者最小（小顶堆），这 3 个元素之间的选择当然不会破坏稳定性。但当为 n / 2 - 1， n / 2 - 2，
... 1 这些个父节点选择元素时，就会破坏稳定性。有可能第 n / 2 个父节点交换把后面一个元素交换过去了，而第 n / 2 - 1 个父节点把后面一个相同的元素没 有交换，那么这 2
个相同的元素之间的稳定性就被破坏了。所以，堆排序不是稳定的排序算法。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="递归解法"><a class="header" href="#递归解法">递归解法</a></h2>
<pre><code>F(n) = n; n = 0,1
F(n) = F(n-1) + F(n-2),n &gt;= 2;
</code></pre>
<p>斐波那契数列的推导式如上，相当简单，所以很容易就能写出递归的解法。</p>
<pre><code class="language-python">import time
from functools import wraps


def print_func_time(function):
    @wraps(function)
    def func_time(*args, **kwargs):
        t0 = time.perf_counter()
        result = function(*args, **kwargs)
        t1 = time.perf_counter()
        print(&quot;Total running time: %s s&quot; % (str(t1 - t0)))
        return result

    return func_time


def fiBo(n):
    if n &lt;= 1:
        return n
    else:
        return fiBo(n - 1) + fiBo(n - 2)


@print_func_time
def solution(n):
    print(fiBo(n))


# 0 1 1 2 3 5 8

if __name__ == '__main__':
    solution(40)
</code></pre>
<blockquote>
<p>out：</p>
</blockquote>
<blockquote>
<p>102334155 Total running time: 41.485671385 s</p>
</blockquote>
<p>显然，才 40，时间效率就很低下了。</p>
<p>这是为什么呢？</p>
<p>当我们计算 5 的时候，会进行下面这样的计算：</p>
<pre><code>|--F(1)
                  |--F(2)|
           |--F(3)|      |--F(0)
           |      |
    |--F(4)|      |--F(1)
    |      |
    |      |      |--F(1)
    |      |--F(2)|
    |             |--F(0)
F(5)|
    |             |--F(1)
    |      |--F(2)|
    |      |      |--F(0)
    |--F(3)|
           |
           |--F(1)
</code></pre>
<p>为了计算 fibo(5)，需要计算 fibo(3)，fibo(4)；而为了计算 fibo(4)，需要计算 fibo(2)，fibo(3)……最终为了得到 fibo(5)的结果，fibo(0)被计算了
3 次，fibo(1)被计算了 5 次，fibo(2)被计算了 2 次。可以看到，它的计算次数几乎是指数级的</p>
<p>因此，虽然递归算法简洁，但是在这个问题中，它的时间复杂度却是难以接受的。除此之外，递归函数调用的越来越深，它们在不断入栈却迟迟不出栈，空间需求越来越大，虽然访问速度高，但大小是有限的，<strong>最终可能导致栈溢出</strong>。
在 linux 中，我们可以通过下面的命令查看栈空间的软限制：</p>
<pre><code class="language-shell">$ ulimit -s
8192
</code></pre>
<p>可以看到，默认栈空间大小只有 8M。一般来说，8M 的栈空间对于一般程序完全足够。如果 8M 的栈空间不够使用，那么就需要重新审视你的代码设计了。</p>
<h2 id="改进递归"><a class="header" href="#改进递归">改进递归</a></h2>
<p>既然我们知道最初版本的递归存在大量的重复计算，那么我们完全可以考虑将已经计算的值保存起来，从而<strong>避免重复计算</strong>，该版本代码实现如下：</p>
<pre><code class="language-python">def fiBo(n, lst):
    if n &lt; 2:
        return n
    else:
        lst[n] = fiBo(n-1, lst) + lst[n-2]
        return lst[n]


@print_func_time
def solution(n, lst):
    print(fiBo(n, lst))


# 0 1 1 2 3 5 8

if __name__ == '__main__':
    arr = [0]+[1]*40
    solution(40, arr)
</code></pre>
<blockquote>
<p>out：</p>
</blockquote>
<blockquote>
<p>102334155 Total running time: 2.6667000000035745e-05 s</p>
</blockquote>
<p>显然可见其效率还是不错的，时间复杂度为 O(n)。</p>
<p>但是特别注意的是，这种改进版的递归，虽然避免了重复计算，但是调用链仍然比较长。</p>
<h2 id="迭代解法"><a class="header" href="#迭代解法">迭代解法</a></h2>
<p>显然，让你来算，你肯定不会说我先算 40，然后发现要算 39。</p>
<p>你肯定是算：</p>
<p>0+1=1</p>
<p>1+1=2</p>
<p>2+1=3</p>
<p>3+5=5</p>
<p>5+3=8</p>
<p>……</p>
<p>我们是正向计算的，而且是不断向后计算的。</p>
<p>理解到区别了没。</p>
<p>那么，我们是否也可以这样进行计算呢，显然，是可以的。</p>
<pre><code class="language-python">def fiBo(n):
    n = n+1
    pre1 = 0
    pre2 = 1
    if n &lt; 2:
        return n
    loop = 1
    ret = 0
    while loop &lt; n:
        ret = pre1 + pre2
        pre2 = pre1
        pre1 = ret
        loop += 1
        # 可以使用Python的语法糖代替上面的循环体
        # tmp = pre1 + pre2
        # ret, pre2, pre1, loop = tmp, pre1, tmp, loop + 1
    return ret


@print_func_time
def solution(n):
    print(fiBo(n))


# 0 1 1 2 3 5 8

if __name__ == '__main__':
    solution(40)
</code></pre>
<blockquote>
<p>out：</p>
</blockquote>
<blockquote>
<p>102334155</p>
</blockquote>
<blockquote>
<p>Total running time: 2.0102999999993543e-05 s</p>
</blockquote>
<p>时间复杂度为 O(n)。</p>
<h2 id="尾递归解法"><a class="header" href="#尾递归解法">尾递归解法</a></h2>
<p>同样的思路，但是采用尾递归的方法来计算。</p>
<p>要计算第 n 个斐波那契数，我们可以先计算第一个，第二个，如果未达到 n，则继续递归计算。</p>
<pre><code class="language-python">def fiBoProcess(n, pre1, pre2, begin):
    if n == begin:
        return pre1 + pre2
    else:
        begin += 1
        return fiBoProcess(n, pre2, pre1 + pre2, begin)


def fiBo(n):
    if n &lt; 2:
        return n
    else:
        return fiBoProcess(n, 0, 1, 2)


@print_func_time
def solution(n):
    print(fiBo(n))


# 0 1 1 2 3 5 8


if __name__ == '__main__':
    solution(40)
</code></pre>
<blockquote>
<p>out：</p>
</blockquote>
<blockquote>
<p>102334155 Total running time: 2.338399999995966e-05 s</p>
</blockquote>
<p>可见，其效率并不逊于迭代法。尾递归在函数返回之前的最后一个操作仍然是递归调用。尾递归的好处是，进入下一个函数之前，已经获得了当前函数的结果，因此不需要保留当前函数的环境，内存占用自然也是比最开始提到的递归要小。时间复杂度为
O(n)。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1-两数之和"><a class="header" href="#1-两数之和">1-两数之和</a></h1>
<p>万里长征始于足下。</p>
<p>给定一个整数数组 <code>nums</code> 和一个目标值 <code>target</code>，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>
<p>示例:</p>
<p>给定 <code>nums = [2, 7, 11, 15], target = 9</code></p>
<p>因为 <code>nums[0] + nums[1] = 2 + 7 = 9</code> 所以返回 <code>[0, 1]</code></p>
<p>来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/two-sum</p>
<h2 id="解法-1双重循环"><a class="header" href="#解法-1双重循环">解法 1：双重循环</a></h2>
<p>乍一看，挺简单，不就两重循环么。说干就干。</p>
<pre><code class="language-python">class Solution:
    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:
        length = len(nums)
        ret = []
        isFind=False
        for i in range(length):
            for j in range(length):
                if i==j:
                    continue
                elif nums[i] + nums[j] == target:
                    isFind=True
                    ret.append(i)
                    ret.append(j)
                if isFind:
                    return ret
        return ret
</code></pre>
<p>这里再提供一个计算函数执行时间的装饰器（学以致用）</p>
<pre><code class="language-pyt">def print_func_time(function):
    @wraps(function)
    def func_time(*args, **kwargs):
        t0 = time.perf_counter()
        result = function(*args, **kwargs)
        t1 = time.perf_counter()
        print(&quot;Total running time: %s s&quot; % (str(t1 - t0)))
        return result
    return func_time
</code></pre>
<p>当然，事情没有那么简单，显然而且必然的，在最后一组数据下超时了。</p>
<pre><code class="language-python">此处数据过长，就不贴了，自己去超时的地方看看就ok了
</code></pre>
<p>自己本地跑也是要 11-12s 左右的（视电脑不同而不同。）</p>
<pre><code class="language-python">Total running time: 12.628380413 s
[8010, 8011]
</code></pre>
<p>暂时没有什么错误发生，那么接下来就是考虑优化的事情了。</p>
<ul>
<li>
<p>首先就是我们的 ret 不必要存在，可以直接返回的时候封装成<code>list</code>就可以了，可以省掉一点 append 操作的时间。</p>
</li>
<li>
<p>然后就是我们的 isFind 判断是不必要的，题目中已经假设了必然有且只有一个结果，我们发现结果的时候直接返回就可以了。</p>
</li>
<li>
<p>再接着，我们的<code>j</code>不必要从头开始遍历，会造成冗余的循环。只要从<code>i+1</code>的地方开始就可以了。</p>
</li>
</ul>
<p>修改后的代码长这样：</p>
<pre><code class="language-python">def twoSum(self, nums: List[int], target: int) -&gt; List[int]:
    length = len(nums)
    for i in range(length):
        for j in range(i+1,length):
            if nums[i] + nums[j] == target:
                return [i,j]
    return []
</code></pre>
<p>时间下降了很多：</p>
<pre><code class="language-python">Total running time: 6.893857144 s
[8010, 8011]
</code></pre>
<p>当然，这显然不符合我们的要求，虽然题目不说，但是，我们肯定要压缩到 1s 以内的。</p>
<p>考虑到，普通 index 的遍历速度 &lt; enumerate &lt;iterator。</p>
<p>但是我们这边需要我们遍历的索引。所以我们考虑使用 enumerate 而不是使用 iterator。</p>
<p>Python 中加法操作好像比较耗时，在大量操作后，iterator 的操作时间已经比 enumerate 直接取索引高很多了。</p>
<p>所以不考虑使用 iterator，在迭代内部计算索引。（实操证明过了，不信可以自己实验）</p>
<p>时间再次下降 1 秒：</p>
<pre><code class="language-python">def twoSum(self, nums: List[int], target: int) -&gt; List[int]:
        length = len(nums)
        # newNums = sorted(enumerate(nums),key=lambda x:x[1])
        for i,item in enumerate(nums):
            for j in range(i+1,length):
                if item+nums[j] == target:
                    return [i,j]
</code></pre>
<pre><code class="language-python">Total running time: 5.895048940000001 s
[8010, 8011]
</code></pre>
<p>这时候我们再考虑，<code>target</code>值是两者相加得到（数据组中有负数存在需要考虑）。</p>
<ul>
<li><code>target&gt;=0</code>的情况下，必然有一个数是小于<code>target</code>的</li>
<li><code>target&lt;0</code>的情况下，必然有一个数是大于<code>target</code>的</li>
</ul>
<p>那么，我们可以先对数组进行一下排序，以对循环进行剪枝：</p>
<pre><code class="language-python">def twoSum(self, nums: List[int], target: int) -&gt; List[int]:
        length = len(nums)
        newNums = sorted(enumerate(nums),key=lambda x:x[1])

        if target &gt;= 0:
            for i in range(length):
                if i &gt; target:
                    break
                for j in range(i + 1, length):
                    if newNums[i][1] + newNums[j][1] == target:
                        return [newNums[i][0], newNums[j][0]]
            return []
        elif target &lt; 0:
            for i in range(length):
                if i &lt; target:
                    break
                for j in range(i + 1, length):
                    if newNums[i][1] + newNums[j][1] == target:
                        return [newNums[i][0], newNums[j][0]]
            return []
</code></pre>
<p>我们发现已经低于 0.01 秒了。已经能通过 LeetCode 的提交了。但是你还是 Too young too simple。</p>
<p>那是因为我们的数据有点特殊，我们在此把<code>target</code>替换成（25196+25194）= 50390</p>
<p>我们发现，时间还是超时了（当然是本地跑的，10s 左右）</p>
<pre><code class="language-python">Total running time: 10.42657594 s
[12597, 12598]
</code></pre>
<p>当然不能因为特殊而特殊啦</p>
<p>本着科学研究的精神，我们进行一下升华</p>
<h2 id="解法-2哈希表"><a class="header" href="#解法-2哈希表">解法 2：哈希表</a></h2>
<p>我们反过来考虑一下，我们何苦去它有的里面找有两个数相加得到目标值呢。凭啥听他的一定要到它里面找。</p>
<p>（当然得从里面找）</p>
<p>但是，我们可以考虑一下，我从<code>list</code>中取第<code>i</code>个值，然后计算出<code>target-list[i]</code>，然后我去 list 里面找，我计算出来的这个差值是否在 list
中，如果在，那就对了，如果不在，就取<code>i+1</code>进行下一步运算。</p>
<p>当然不能用双重循环啦，那跟第一种方法没区别了。</p>
<p>我们考虑到哈希表，Python 中内置的字典<code>dict</code>就是一个哈希表：</p>
<pre><code class="language-python">def twoSum(self, nums: List[int], target: int) -&gt; List[int]:
        hashmap = {}
        for index, num in enumerate(nums):
            another_num = target - num
            if another_num in hashmap:
                return [hashmap[another_num], index]
            hashmap[num] = index
        return None
</code></pre>
<p>同时我们边存边判断，这样可以减少一次循环。</p>
<p>你可能考虑到，哈希表，不存在重复值，但是我的数组可能存在重复值，会不会有影响。</p>
<p>看代码：</p>
<ol>
<li>我们外层循环是对<code>enumerate(nums)</code>进行循环的，所以每一个原有的值都会遍历到</li>
<li>题目中有说到有且只有一个答案。那么，重复值引起的有两种选择的情况也是不存在的。</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2-两数相加"><a class="header" href="#2-两数相加">2-两数相加</a></h1>
<p>给出两个<strong>非空</strong>的链表用来表示两个非负的整数。其中，它们各自的位数是按照<strong>逆序</strong>的方式存储的，并且它们的每个节点只能存储<strong>一位</strong>数字。</p>
<p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>
<p>您可以假设除了数字<strong>0</strong>之外，这两个数都不会以<strong>0</strong>开头。</p>
<p>示例：</p>
<p>​ 输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) ​ 输出：7 -&gt; 0 -&gt; 8 ​ 原因：342 + 465 = 807</p>
<p>来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/add-two-numbers</p>
<p>本操作类似大数字的加法，思想类似循环字符串大数字的相加。</p>
<p>再加上链表的基本操作，包括两个链表的连接。</p>
<p>一开始思想比较混乱的时候，脑子里怎么想的就怎么来，写出如下代码：</p>
<pre><code class="language-python">def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:
        flag = 0
        ret = []
        while l1 != None and l2 !=None:
            midNum = l1.val + l2.val + flag
            if midNum &gt;= 10:
                flag, midNum = divmod(midNum, 10)
            else:
                flag = 0
            ret.append(midNum)
            l1 = l1.next
            l2 = l2.next
        l3 = ListNode(ret[0])
        mid = l3
        if l1 == None and l2 == None and flag != 0:
            ret.append(flag)
            flag = 0
        for i in ret[1:]:
            mid.next = ListNode(i)
            mid = mid.next
        l1 = l1 if l1 else l2
        while l1 != None and flag != 0:
            midNum = l1.val + flag
            if midNum &gt;= 10:
                flag, midNum = divmod(midNum, 10)
            else:
                flag = 0
            mid.next = ListNode(midNum)
            l1 = l1.next
            mid = mid.next
        if l1 != None:
            mid.next = l1
        if flag != 0:
            while mid.next!=None:
                mid = mid.next
            mid.next = ListNode(flag)
        return l3
</code></pre>
<p><code>flag</code>用来判断是否需要进位。</p>
<p><code>ret</code>是一个辅助工具，用来存储相加后得到的值，然后再转成<code>ListNode</code>，原因是无法写出动态生成<code>l3</code>的链表（自己太菜，后来去掉了这个辅助）</p>
<p>然后<code>divmod(除数，被除数)</code>函数返回一个元组<code>tuple（商，余数）</code>。我们的商就用来增加<code>l3</code>的节点，余数就作为进位判断。</p>
<p>在一开始，需要处理短链表的全部和长链表等长的部分。</p>
<p><img src="Algorithm/D:%5CTypora%E7%AC%94%E8%AE%B0%5Cimages%5C1565611968649.png" alt="1565611968649" /></p>
<p>整体思路如上。代码实现就如上了。</p>
<p>接下来进行一些合并，去除掉一些不必要的代码：</p>
<pre><code class="language-python">def addTwoNumbers2(self, l1, l2):
        target = ListNode(0)  # 作为根节点的引用
        p = target
        add = 0  # 作为上一次相加是否需要进1的依据
        while l1 and l2:
            p.next = ListNode((l1.val + l2.val + add) % 10)
            add = (l1.val + l2.val + add) // 10
            p, l1, l2 = p.next, l1.next, l2.next
        l1 = l1 if l1 else l2
        while add:
            if l1:
                p.next = ListNode((l1.val + add) % 10)
                add = (l1.val + add) // 10
                p, l1 = p.next, l1.next
            else:
                p.next = ListNode(add)
                p = p.next
                break
        p.next = l1
        return target.next
</code></pre>
<p>为了去掉<code>ret</code>数组，我们在一开始直接初始化<code>ListNode(0)</code>作为头结点（返回的时候返回<code>target.next</code>）即可去掉头结点</p>
<p>在两链表一一对应的部分，我们执行如下代码：</p>
<pre><code class="language-python">while l1 and l2:
	p.next = ListNode((l1.val + l2.val + add) % 10)
	add = (l1.val + l2.val + add) // 10
	p, l1, l2 = p.next, l1.next, l2.next
</code></pre>
<p>然后经过这一步赋值操作，则可以得到剩下的链表或者空：</p>
<pre><code class="language-python">l1 = l1 if l1 else l2
</code></pre>
<p>接下来判断是否需要进位，如果不需要，则直接追加剩余部分或空：</p>
<pre><code class="language-python">p.next = l1
</code></pre>
<p>如果需要进位</p>
<pre><code class="language-python">while add:
	if l1:
		p.next = ListNode((l1.val + add) % 10)
		add = (l1.val + add) // 10
		p, l1 = p.next, l1.next
	else:
		p.next = ListNode(add)
        p = p.next
        break
</code></pre>
<p>则判断剩余长链表是否有值，如果没有，则直接追加要进位的 1（<code>else</code>语句）</p>
<p>如果有，则执行<code>if</code>里面的语句，进行两数相加，直到不需要进位，最后直接追加剩余部分就可以了。</p>
<p>以上的条件分支比第一次少了很多，主要是要头脑清晰。</p>
<p>再来分析一下第二次所做的判断。</p>
<p>在处理到两者相等的时候，不去思考是否有剩余的值，先判断是否需要进位，在有进位的基础下，合并了一部分操作。具体需要自行体会。</p>
<p>思考顺序和角度不同写出来的代码也不同。无所谓对错。</p>
<p>两种方案的耗时和空间使用都差不多，只是第一种代码量少一点。比较符合常规的思考。</p>
<p>第二种需要在第一种的基础上进行更深层次的思考。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="3-无重复字符的最长子串"><a class="header" href="#3-无重复字符的最长子串">3-无重复字符的最长子串</a></h1>
<p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p>
<p>示例 1:</p>
<p>​ 输入: &quot;abcabcbb&quot; ​ 输出: 3 ​ 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</p>
<p>示例 2:</p>
<p>​ 输入: &quot;bbbbb&quot; ​ 输出: 1 ​ 解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</p>
<p>示例 3:</p>
<p>​ 输入: &quot;pwwkew&quot; ​ 输出: 3 ​ 解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</p>
<p>来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters</p>
<p>首先想到的就是遍历。</p>
<p>从头到尾，每一个位置<code>i</code>，都向后搜索到<code>len(s)</code>的位置，然后用一个<code>set</code>保存不重复的值，如果出现重复值则退出本次循环，重置一些状态，返回<code>set</code>中元素的个数，就是本次找到的最长子串。</p>
<pre><code class="language-python">class Solution:
    def lengthOfLongestSubstring(self, s: str) -&gt; int:
        lenList = []
        currentLen = 0
        sss = set()
        for i in range(len(s)):
            for j in range(i, len(s)):
                if s[j] in sss:
                    lenList.append(currentLen)
                    currentLen = 0
                    sss.clear()
                    break
                else:
                    sss.add(s[j])
                    currentLen += 1
                    if j == len(s)-1:
                        lenList.append(currentLen)
                        currentLen = 0
                        sss.clear()
                        break
        return max(lenList) if len(lenList)!=0 else 0
</code></pre>
<p>显然，双层循环，时间复杂度为<code>O(n²)</code></p>
<p><strong>进阶</strong>（滑动窗口）</p>
<p>现在假设我们有一个可伸缩的长方形的框，初始长度是<code>1</code>，然后我们拿这个框，从头去套我们的字符串。</p>
<p>那么如果框中没有重复值，我们就更新最大长度，然后框的长度<code>+1</code>，如果加<code>1</code>后框中无重复值，则重复上述操作。最后返回最大值。</p>
<p>若果遇到重复值，则只要将我们的框，从上一个这个值出现的位置的后一位截取到最后，即可。</p>
<p>这样只需要进行一次遍历。时间复杂度为<code>O(n)</code></p>
<pre><code class="language-python">class Solution:
    def lengthOfLongestSubstring(self, s: str) -&gt; int:
        if s == &quot;&quot;:
            return 0
        maxLen = 0
        currentLen = 1
        sss = []
        for i in s:
            if i not in sss:
                sss.append(i)
                maxLen = max(currentLen, maxLen)
            else:
                sss = sss[sss.index(i)+1:]
                sss.append(i)
                currentLen = len(sss)
            currentLen += 1
        return maxLen
</code></pre>
<p><code>O(n)</code>的时间效率当然是比<code>O(n²)</code>高出不少的。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-hrefhttpsleetcode-cncomproblemsmedian-of-two-sorted-arrays4-寻找两个有序数组的中位数a"><a class="header" href="#a-hrefhttpsleetcode-cncomproblemsmedian-of-two-sorted-arrays4-寻找两个有序数组的中位数a"><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">4. 寻找两个有序数组的中位数</a></a></h1>
<p>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。</p>
<p>请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p>
<p>你可以假设 nums1 和 nums2 不会同时为空。</p>
<p>示例 1:</p>
<p>​ nums1 = [1, 3] ​ nums2 = [2]</p>
<p>则中位数是 2.0</p>
<p>示例 2:</p>
<p>​ nums1 = [1, 2] ​ nums2 = [3, 4]</p>
<p>则中位数是 (2 + 3)/2 = 2.5</p>
<p>来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/median-of-two-sorted-arrays</p>
<p>看到时间复杂度为 O(log(m+n))，理所当然的想到，小根堆（大根堆）</p>
<p>因为构建根堆的时间复杂度就是 log(N)。</p>
<p>当然，如果没有这个条件限制，那么会产生以下的思考。</p>
<h2 id="姿势-1"><a class="header" href="#姿势-1">姿势 1</a></h2>
<p>直接整合排序找中位数：</p>
<pre><code class="language-python">class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -&gt; float:
        nums1 = nums1 + nums2
        nums1.sort()
        length = len(nums1)
        if length % 2 == 0:
            k1 = nums1[int(length / 2) - 1]
            k2 = nums1[int(length / 2)]
            return (k1 + k2) / 2
        else:
            return nums1[int(length / 2)]
</code></pre>
<p>简单粗暴，但是时间复杂度肯定不符合要求，虽然跑测试通过了。</p>
<p>可能在调用自带的 sort 方法的时候会自动做优化，但是肯定也不符合要求。</p>
<blockquote>
<p><strong>sort 与 sorted 区别：</strong></p>
</blockquote>
<blockquote>
<p>sort 是应用在 list 上的方法，sorted 可以对所有可迭代的对象进行排序操作。</p>
</blockquote>
<blockquote>
<p>list 的 sort 方法返回的是对已经存在的列表进行操作，无返回值，而内建函数 sorted 方法返回的是一个新的 list，而不是在原来的基础上进行的操作。</p>
</blockquote>
<h2 id="姿势-2"><a class="header" href="#姿势-2">姿势 2</a></h2>
<p>再就想到的是将两个列表整合起来排序，由于是两个有序数组，可以使用链表的合并。</p>
<p>优化一点就是，合并到中位数就停止。</p>
<p>有序链表的合并属于数据结构基础知识，不再赘述。</p>
<p>时间复杂度肯定不达标，大概是 O(N)</p>
<h2 id="姿势-3"><a class="header" href="#姿势-3">姿势 3</a></h2>
<p>正主，小根堆。</p>
<p>借助的是 heapq 实现小根堆。</p>
<p>这个肯定是符合时间复杂度要求的，但是这个效率和内存不太满意。</p>
<pre><code class="language-python">import heapq


class TopkHeap(object):
   def __init__(self, k):
       self.k = k
       self.data = []

   def push(self, elem):
       if len(self.data) &lt; self.k:
           heapq.heappush(self.data, elem)
       else:
           topk_small = self.data[0]
           if elem &gt; topk_small:
               heapq.heapreplace(self.data, elem)

   def TopK(self):
        return [x for x in reversed([heapq.heappop(self.data) for x in range(len(self.data))])]



class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -&gt; float:
        len1 = len(nums1)
        len2 = len(nums2)
        nums = nums1+nums2
        # 如果即奇数个，则直接取中位数，也就是第k大的值
        if (len1+len2) % 2 != 0:
            k = int((len1+len2)/2+1)
            th = TopkHeap(k)
            for i in nums:
                th.push(i)
            return th.TopK()[-1]
        # 如果是偶数个
        else:
            k = int((len1+len2)/2+1)
            th = TopkHeap(k)
            for i in nums:
                th.push(i)
            data = th.TopK()
            return (data[-1]+data[-2])/2
</code></pre>
<h2 id="姿势-4"><a class="header" href="#姿势-4">姿势 4</a></h2>
<p>官方说的，二分法？没怎么看懂。感觉还是比较复杂的。</p>
<p>https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/4-xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-shu/</p>
<p>这个回答挺好的。但是我没法复述了。。。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-hrefhttpsleetcode-cncomproblemslongest-palindromic-substring5-最长回文子串a"><a class="header" href="#a-hrefhttpsleetcode-cncomproblemslongest-palindromic-substring5-最长回文子串a"><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">5. 最长回文子串</a></a></h1>
<p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p>
<p>示例 1：</p>
<p>输入: &quot;babad&quot; 输出: &quot;bab&quot; 注意: &quot;aba&quot; 也是一个有效答案。</p>
<p>示例 2：</p>
<p>输入: &quot;cbbd&quot; 输出: &quot;bb&quot;</p>
<p>来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/longest-palindromic-substring</p>
<h2 id="1-暴力法"><a class="header" href="#1-暴力法">1. 暴力法</a></h2>
<p>最先想到的应该是暴力法。</p>
<p>这中间是有很多优化的想法的。</p>
<p>从头开始两层 for 循环截取字符串，然后判断字符串是否回文是最基本的想法。</p>
<p>但是这样的循环会出现很多重复的操作。</p>
<p>但是可以换一种思路。取头<code>index1</code>，尾<code>index2</code>。</p>
<p>循环头<code>index1</code>，循环尾<code>index2</code>，判断截取出来的字符串是否是回文串，如果不是，<code>index2</code>自减。</p>
<p>​ 循环尾 index2：</p>
<p>​ 判断截取出来的字符串是否是回文串，如果不是，index2 自减。</p>
<p>如果是，那么要和之前保存的最长的回文串<code>ret</code>进行长度比较。如果比<code>ret</code>长，则替换。</p>
<p>==直接跳出第二层循环==，因为本次外循环中，就算有<code>index2</code>还满足条件，那也比<code>ret</code>短了。</p>
<p>这是一个剪枝操作。<code>leetcode</code>上的时间大概是<code>1600ms</code>，虽然通过了，但是不太满意。</p>
<pre><code class="language-python">class Solution:
    def longestPalindrome(self, s: str) -&gt; str:
        length = len(s)
        ret = &quot;&quot;
        # 从头index1开始
        for index1 in range(length):
            # 从尾index2开始
            for index2 in range(-1, -(length + 1), -1):
                # 如果两者相同，那么才判断是否相同。不同肯定不是回文串。
                if s[index1] == s[index2]:
                    # 截取字符串并反转判断是否是回文串
                    str1 = s[index1:index2 + length + 1]
                    str2 = str1[::-1]
                    if str1 == str2:
                        if len(str1) &gt; len(ret):
                            ret = str1
                        # 如果是，那么不管怎么样都退出内循环。
                        break
        return ret
</code></pre>
<h2 id="2-中心拓展法"><a class="header" href="#2-中心拓展法">2. 中心拓展法</a></h2>
<p>我们观察到回文中心的两侧互为镜像。因此，回文可以从它的中心展开，并且只有<code>2n - 1</code>个这样的中心。</p>
<p>你可能会问，为什么会是 <code>2n−1</code> 个，而不是 <code>n</code> 个中心？</p>
<p>原因在于所含字母数为偶数的回文的中心可以处于两字母之间（例如 “abba” 的中心在两个‘b’ 之间）。</p>
<pre><code class="language-python">class Solution:
    def longestPalindrome(self, s: str) -&gt; str:
        if s is None or len(s) &lt; 1:
            return &quot;&quot;
        start = 0
        end = 0
        for i in range(len(s)):
            # 从i的位置开始向两侧检索，分界线在i。长度一定是奇数。
            len1 = self.expandAroundCenter(s, i, i)
            # 从i和i+1的位置向两侧检索，分界线在中间。长度一定是偶数。
            len2 = self.expandAroundCenter(s, i, i+1)
            length = max(len1, len2)
            if length &gt; end - start + 1:
                # 如果长度是偶数，则左边界向右挪1，
                # 如果是奇数，这样操作的数值是不会变的。
                start = i - (length - 1) // 2
                # 向后的正常取值就可以了，本身就是向后扩展的。
                end = i + length // 2
        return s[start:end + 1]

    def expandAroundCenter(self, s: str, left: int, right: int):
        L, R = left, right
        while L &gt;= 0 and R &lt; len(s) and s[L] == s[R]:
            L -= 1
            R += 1
        return R - L - 1
</code></pre>
<h2 id="5-动态规划"><a class="header" href="#5-动态规划">5. 动态规划</a></h2>
<p>解决这类 “最优子结构” 问题，可以考虑使用 “动态规划”：</p>
<p>1、定义 “状态”； 2、找到 “状态转移方程”。</p>
<p>记号说明： 下文中，使用记号 <code>s[l, r]</code> 表示原始字符串的一个子串，<code>l</code>、<code>r</code> 分别是区间的左右边界的索引值，使用左闭、右闭区间表示左右边界可以取到。举个例子，当
<code>s = 'babad'</code> 时，<code>s[0, 1] = 'ba'</code> ，<code>s[2, 4] = 'bad'</code>。</p>
<p>1、定义 “状态”，这里 “状态”数组是二维数组。</p>
<p><code>dp[l][r]</code> 表示子串 <code>s[l, r]</code>（包括区间左右端点）是否构成回文串，是一个二维布尔型数组。即如果子串 <code>s[l, r]</code> 是回文串，那么 <code>dp[l][r] = true</code>。</p>
<p>2、找到 “状态转移方程”。</p>
<p>首先，我们很清楚一个事实：</p>
<p>1、当子串只包含 <code>1</code> 个字符，它一定是回文子串；</p>
<p>2、当子串包含 <code>2</code> 个以上字符的时候：如果 <code>s[l, r]</code> 是一个回文串，例如 <code>“abccba”</code>，那么这个回文串两边各往里面收缩一个字符（如果可以的话）的子串
<code>s[l + 1, r - 1]</code> 也一定是回文串，即：如果 <code>dp[l][r] == true</code> 成立，一定有 <code>dp[l + 1][r - 1] = true</code> 成立。</p>
<p>根据这一点，我们可以知道，给出一个子串 <code>s[l, r]</code> ，如果 <code>s[l] != s[r]</code>，那么这个子串就一定不是回文串。如果 <code>s[l] == s[r]</code> 成立，就接着判断
<code>s[l + 1] 与 s[r - 1]</code>，这很像中心扩散法的逆方法。</p>
<p>事实上，当 <code>s[l] == s[r]</code> 成立的时候，<code>dp[l][r]</code> 的值由 <code>dp[l + 1][r - l]</code>
决定，这一点也不难思考：当左右边界字符串相等的时候，整个字符串是否是回文就完全由“原字符串去掉左右边界”的子串是否回文决定。但是这里还需要再多考虑一点点：“原字符串去掉左右边界”的子串的边界情况。</p>
<p>1、当原字符串的元素个数为 3 个的时候，如果左右边界相等，那么去掉它们以后，只剩下 1 个字符，它一定是回文串，故原字符串也一定是回文串；</p>
<p>2、当原字符串的元素个数为 2 个的时候，如果左右边界相等，那么去掉它们以后，只剩下 0 个字符，显然原字符串也一定是回文串。</p>
<p>把上面两点归纳一下，只要 <code>s[l + 1, r - 1]</code>
至少包含两个元素，就有必要继续做判断，否则直接根据左右边界是否相等就能得到原字符串的回文性。而“<code>s[l + 1, r - 1] 至少包含两个元素</code>”等价于 <code>l + 1 &lt; r - 1</code>，整理得
<code>l - r &lt; -2</code>，或者 <code>r - l &gt; 2</code>。</p>
<p>综上，如果一个字符串的左右边界相等，以下二者之一成立即可： 1、去掉左右边界以后的字符串不构成区间，即“ <code>s[l + 1, r - 1]</code> 至少包含两个元素”的反面，即
<code>l - r &gt;= -2</code>，或者 <code>r - l &lt;= 2</code>； 2、去掉左右边界以后的字符串是回文串，具体说，它的回文性决定了原字符串的回文性。</p>
<p>于是整理成“状态转移方程”：</p>
<pre><code class="language-python">dp[l, r] = (s[l] == s[r] and (l - r &gt;= -2 or dp[l + 1, r - 1]))
</code></pre>
<p>或者</p>
<pre><code class="language-python">dp[l, r] = (s[l] == s[r] and (r - l &lt;= 2 or dp[l + 1, r - 1]))
</code></pre>
<p>编码实现细节：因为要构成子串 <code>l</code> 一定小于等于 <code>r</code> ，我们只关心 “状态”数组“上三角”的那部分取值。理解上面的“状态转移方程”中的
(<code>r - l &lt;= 2 or dp[l + 1, r - 1]</code>) 这部分是关键，因为 <code>or</code> 是短路运算，因此，如果收缩以后不构成区间，那么就没有必要看继续 <code>dp[l + 1, r - 1]</code>
的取值。</p>
<p>读者可以思考一下：为什么在动态规划的算法中，不用考虑回文串长度的奇偶性呢。想一想，答案就在状态转移方程里面。</p>
<p>具体编码细节在代码的注释中已经体现。</p>
<pre><code class="language-python">class Solution:
    def longestPalindrome(self, s: str) -&gt; str:
        size = len(s)
        if size &lt;= 1:
            return s
        # 二维 dp 问题
        # 状态：dp[l,r]: s[l:r] 包括 l，r ，表示的字符串是不是回文串
        # 设置为 None 是为了方便调试，看清楚代码执行流程
        dp = [[False for _ in range(size)] for _ in range(size)]

        longest_l = 1
        res = s[0]

        # 因为只有 1 个字符的情况在最开始做了判断
        # 左边界一定要比右边界小，因此右边界从 1 开始
        for r in range(1, size):
            for l in range(r):
                # 状态转移方程：如果头尾字符相等并且中间也是回文
                # 在头尾字符相等的前提下，如果收缩以后不构成区间（最多只有 1 个元素），直接返回 True 即可
                # 否则要继续看收缩以后的区间的回文性
                # 重点理解 or 的短路性质在这里的作用
                if s[l] == s[r] and (r - l &lt;= 2 or dp[l + 1][r - 1]):
                    dp[l][r] = True
                    cur_len = r - l + 1
                    if cur_len &gt; longest_l:
                        longest_l = cur_len
                        res = s[l:r + 1]
            # 调试语句
            # for item in dp:
            #     print(item)
            # print('---')
        return res
</code></pre>
<p>以上需要相当长时间的理解和阅读。</p>
<h2 id="4-膜拜大佬"><a class="header" href="#4-膜拜大佬">4. 膜拜大佬</a></h2>
<pre><code class="language-python">class Solution:
    def longestPalindrome(self, s: str) -&gt; str:
        if (len(s) &lt;= 1) or s == s[::-1]:
            return s
        start = 0
        maxlen = 0
        for i in range(len(s)):
            str1 = s[i - maxlen: i + 1]
            str2 = s[i - maxlen - 1: i + 1]

            if (i - maxlen) &gt;= 0 and (str1 == str1[::-1]):
                start, maxlen = i - maxlen, len(str1)
            if (i - maxlen - 1) &gt;= 0 and (str2 == str2[::-1]):
                start, maxlen = i - maxlen - 1, len(str2)
        return s[start: start + maxlen]
</code></pre>
<p>贴上大佬代码贡阅读。</p>
<p>不太理解。。。。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-hrefhttpsleetcode-cncomproblemszigzag-conversion6-z-字形变换a"><a class="header" href="#a-hrefhttpsleetcode-cncomproblemszigzag-conversion6-z-字形变换a"><a href="https://leetcode-cn.com/problems/zigzag-conversion/">6. Z 字形变换</a></a></h1>
<p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。</p>
<p>比如输入字符串为 &quot;LEETCODEISHIRING&quot; 行数为 3 时，排列如下：</p>
<pre><code>L   C   I   R
E T O E S I I G
E   D   H   N
</code></pre>
<p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：<code>&quot;LCIRETOESIIGEDHN&quot;</code>。</p>
<p>请你实现这个将字符串进行指定行数变换的函数：</p>
<pre><code>string convert(string s, int numRows);
</code></pre>
<p>示例 1:</p>
<pre><code>输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 3
输出: &quot;LCIRETOESIIGEDHN&quot;
</code></pre>
<p>示例 2:</p>
<pre><code>输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 4
输出: &quot;LDREOEIIECIHNTSG&quot;
解释:

L     D     R
E   O E   I I
E C   I H   N
T     S     G
</code></pre>
<p>来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/zigzag-conversion</p>
<h2 id="姿势-1模拟法"><a class="header" href="#姿势-1模拟法">姿势 1：模拟法</a></h2>
<p>模拟构建 Z 字型的顺序将最后的二维数组构建出来，最后再将数组还原成字符串，虽然能通过。但是效率很低下。</p>
<pre><code class="language-python">class Solution:
    def computecolumns(self, length:int, numRows: int) -&gt; int:
        s1, y1 = divmod(length, 2 * numRows - 2)
        s2, y2 = divmod(y1, numRows)
        return s1 * (numRows - 1) + s2 + y2


    def convert(self, s: str, numRows: int) -&gt; str:
        length = len(s)
        if numRows == 1 or length == 0:
            return s
        maxRow = numRows
        maxCol = self.computecolumns(length,numRows)
        lst = [[-1 for i in range(maxCol)] for i in range(maxRow)]
        # 记录方向,True向下，False向上
        flag = False
        # 记录当前行号，行号从1开始，和numRows对应
        line = 1
        # 记录当前列号，从0开始
        col = 0
        # index
        i = 0
        while i &lt; length:
            lst[line-1][col] = i
            i += 1
            if line == numRows or line == 1:
                flag = not flag
            if flag:
                line += 1
            else:
                line -= 1
                col += 1
        return &quot;&quot;.join([s[j] for i in lst for j in i if j != -1])
</code></pre>
<h2 id="姿势-2按行访问"><a class="header" href="#姿势-2按行访问">姿势 2：按行访问</a></h2>
<p>实际上，我们并不需要对每个元素的位置定义那么精准。</p>
<p>只需要知道他在哪一行就可以了。访问到当前行的时候，加入字符就可以了。</p>
<pre><code class="language-python">class Solution:
    def convert(self, s: str, numRows: int) -&gt; str:
        length = len(s)
        if numRows == 1: return s
        lst = [[] for i in range(min(numRows, length))]
        line = 0
        flag = False
        for item in s:
            lst[line].append(item)
            if line == numRows - 1 or line == 0:
                flag = not flag
            line += 1 if flag else -1
        return &quot;&quot;.join([j for i in lst for j in i])
</code></pre>
<h2 id="姿势-3找规律"><a class="header" href="#姿势-3找规律">姿势 3：找规律</a></h2>
<p>这个需要一定的思考时间。</p>
<p><strong>思路：</strong></p>
<p>按照与逐行读取 <code>Z</code> 字形图案相同的顺序访问字符串。</p>
<p><strong>算法：</strong></p>
<p>首先访问<code>行0</code>中的所有字符，接着访问<code>行1</code>，然后<code>行2</code>，依此类推...</p>
<p>对于所有整数<code>k</code>，</p>
<ul>
<li>
<p>行<code>0</code>中的字符位于索引<code>k(2*numRows-2)</code>处；</p>
</li>
<li>
<p>行<code>numRows-1</code>中的字符位于索引<code>k(2*numRows-2)+numRows-1</code>处；</p>
</li>
<li>
<p>内部的<code>行i</code>中的字符位于索引<code>k(2*numRows-2)+i</code>以及<code>k(2*numRows-2)-i</code></p>
<p>即，主列的在<code>+i</code>处，非主列的在<code>-i</code>处，并且非主列的只需要增加一个。</p>
</li>
</ul>
<p>Python 代码如下：</p>
<pre><code class="language-python">class Solution:
    def convert(self, s: str, numRows: int) -&gt; str:
        if numRows == 1:
            return s
        ret = &quot;&quot;
        n = len(s)
        cycleLen = 2 * numRows - 2
        for i in range(numRows):
            for j in range(0, n, cycleLen):
                if j + i &gt;= n: break
                ret += s[i + j]
                # 如果非首行尾行，两个主列之间只需要增加一个字母。并且增加的这个字母的索引不能超出范围。
                if i != 0 and i != numRows - 1 and j + cycleLen - i &lt; n:
                    ret += s[j + cycleLen - i]
        return ret
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-hrefhttpsleetcode-cncomproblemsreverse-integer7-整数反转a"><a class="header" href="#a-hrefhttpsleetcode-cncomproblemsreverse-integer7-整数反转a"><a href="https://leetcode-cn.com/problems/reverse-integer/">7. 整数反转</a></a></h1>
<p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p>
<p>示例 1:</p>
<pre><code>输入: 123
输出: 321
</code></pre>
<p>示例 2:</p>
<pre><code>输入: -123
输出: -321
</code></pre>
<p>示例 3:</p>
<pre><code>输入: 120
输出: 21
</code></pre>
<p>注意:</p>
<p>假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31, 2^31 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</p>
<p>来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/reverse-integer</p>
<h2 id="姿势-1转为字符串再处理"><a class="header" href="#姿势-1转为字符串再处理">姿势 1:转为字符串再处理</a></h2>
<pre><code class="language-python">class Solution:
    def reverse(self, x: int) -&gt; int:
        ret = 0
        string = str(x)
        if x &lt; 0:
            string = string[1:]
            string = string[::-1]
            ret = -int(string)
        else:
            ret = int(string[::-1])
        if ret &lt; -2147483648 or ret &gt; 2147483647:
            return 0
        return ret
</code></pre>
<h2 id="姿势-2使用栈"><a class="header" href="#姿势-2使用栈">姿势 2:使用栈</a></h2>
<p>本质和上述方法差不多,不过多解释和书写.</p>
<h2 id="姿势-3直接进行数学计算"><a class="header" href="#姿势-3直接进行数学计算">姿势 3:直接进行数学计算</a></h2>
<pre><code class="language-python">class Solution:
    def reverse(self, x: int) -&gt; int:
        y, res = abs(x), 0
        of = (1 &lt;&lt; 31) - 1 if x &gt; 0 else 1 &lt;&lt; 31
        while y != 0:
            res = res * 10 + y % 10
            if res &gt; of:
                return 0
            y //= 10
        return res if x &gt; 0 else -res
</code></pre>
<p>时间效率和转为字符串之后再操作差不多</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="反转链表-②"><a class="header" href="#反转链表-②">反转链表 ②</a></h1>
<p>反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。</p>
<p>说明: 1 ≤ m ≤ n ≤ 链表长度。</p>
<p>示例:</p>
<p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4 输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</p>
<p>来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/reverse-linked-list-ii
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
struct ListNode {
	int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};

class Solution {
public:
    ListNode* reverseList(ListNode* head,int m,int n) {
		// 计算需要逆置的节点个数
		int change_len = n-m+1;
		// 初始化开始逆置的节点的前驱
		ListNode *pre_head = NULL;
		// 最终转换后的链表的头节点，用于返回，非特殊情况就是head
		ListNode *result = head;
		// 移动head到开始修改的节点
		while(head &amp;&amp; --m){
			pre_head = head;
			head = head-&gt;next;
		}
		// 将modify_list_tail指向当前的head，即逆置后的链表尾部
		ListNode *modify_list_tail = head;
		ListNode *new_head = NULL;
		while(head &amp;&amp; change_len){
			ListNode *next = head-&gt;next;
			head-&gt;next = new_head;
			new_head = head;
			head = next;
			change_len--;
		}
		modify_list_tail-&gt;next = head;
		if(pre_head){
			pre_head-&gt;next = new_head;
		}else{
			result = new_head;
		}
		return result;
    }
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="链表逆序"><a class="header" href="#链表逆序">链表逆序</a></h1>
<p>反转一个单链表。</p>
<p>示例:</p>
<p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL 输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p>
<p>进阶: 你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p>
<p>来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/reverse-linked-list
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h2 id="1双指针迭代法"><a class="header" href="#1双指针迭代法">1.双指针迭代法</a></h2>
<p>已知链表头结点指针 head，将链表逆序。（不可以申请额外的空间）</p>
<p>给出链表的节点：</p>
<pre><code class="language-c++">struct ListNode {
	int val;
    ListNode *next;
    // 构造函数
    ListNode(int x) : val(x), next(NULL) {}
};
</code></pre>
<p>C++解法 1：</p>
<pre><code class="language-c++">class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode *new_head = NULL;
        while(head){
        	ListNode *next = head-&gt;next;
        	head-&gt;next = new_head;
        	new_head = head;
        	head = next;
        }
        return new_head;
    }
};
</code></pre>
<p>首先保存头结点的下一个节点 next，</p>
<p>然后将旧链表的头节点指向新链表的头结点，</p>
<p>然后将新链表的头节点指向旧链表的头节点（因为旧链表的头节点此时已经成为了新链表的新的头结点）</p>
<p>最后将头结点指向 next（向后移动）</p>
<p>Python3 实现：</p>
<pre><code class="language-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def reverseList(self, head: ListNode) -&gt; ListNode:
        new = None
        while head is not None:
            nextEl = head.next
            head.next = new
            new = head
            head = nextEl
        return new
</code></pre>
<h2 id="2递归"><a class="header" href="#2递归">2.递归</a></h2>
<p>此方法的思想类似上面的思想，只不过需要放置环路存在。</p>
<pre><code class="language-python">class Solution:
    def reverseList(self, head: ListNode) -&gt; ListNode:
        if not head or not head.next:
            return head
        start = self.reverseList(head.next)
        head.next.next = head
        head.next = None
        return start
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
                
    </body>
</html>
